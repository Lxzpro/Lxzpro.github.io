<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis 进阶特性笔记</title>
      <link href="/posts/35823.html"/>
      <url>/posts/35823.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、缓存机制"><a href="#一、缓存机制" class="headerlink" title="一、缓存机制"></a>一、缓存机制</h2><p>MyBatis 提供<strong>二级缓存机制</strong>，用于提升查询性能：</p><table><thead><tr><th>缓存级别</th><th>作用范围</th><th>开启方式</th><th>特点</th></tr></thead><tbody><tr><td>一级缓存</td><td>单个 SqlSession（当前事务共享）</td><td>默认开启</td><td>生命周期与 SqlSession 一致，查询结果自动缓存</td></tr><tr><td>二级缓存</td><td>多个 SqlSession（所有事务共享）</td><td>需手动配置开启</td><td>跨 SqlSession 共享，需实体类实现序列化</td></tr></tbody></table><h3 id="缓存特性对比"><a href="#缓存特性对比" class="headerlink" title="缓存特性对比"></a>缓存特性对比</h3><table><thead><tr><th>维度</th><th>一级缓存</th><th>二级缓存</th></tr></thead><tbody><tr><td>作用域</td><td>小</td><td>大</td></tr><tr><td>与数据库距离</td><td>近</td><td>远</td></tr><tr><td>访问速度</td><td>快</td><td>慢</td></tr><tr><td>缓存容量</td><td>小</td><td>大</td></tr><tr><td>命中率</td><td>高</td><td>低</td></tr></tbody></table><h2 id="二、插件机制"><a href="#二、插件机制" class="headerlink" title="二、插件机制"></a>二、插件机制</h2><p>MyBatis 基于<strong>拦截器（Interceptor）</strong> 实现插件功能，可对以下<strong>四大核心对象</strong>进行拦截增强：</p><ul><li><code>ParameterHandler</code>：参数处理</li><li><code>ResultSetHandler</code>：结果集处理</li><li><code>StatementHandler</code>：SQL 语句处理</li><li><code>Executor</code>：执行器（SQL 执行逻辑）</li></ul><p><strong>作用</strong>：在 SQL 执行的全生命周期（如参数解析、结果封装、SQL 执行前后）插入自定义逻辑，实现功能扩展（如分页、SQL 监控）。</p><h2 id="三、PageHelper-分页插件"><a href="#三、PageHelper-分页插件" class="headerlink" title="三、PageHelper 分页插件"></a>三、PageHelper 分页插件</h2><p>PageHelper 是 MyBatis 生态中主流的<strong>分页插件</strong>，基于 MyBatis 插件机制实现，自动对查询 SQL 进行分页改写。</p><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><p>通过拦截 <code>Executor</code> 或 <code>StatementHandler</code>，在 SQL 执行前自动拼接 <code>LIMIT</code> 语句（或数据库方言对应的分页语法）。</p><h3 id="分页参数"><a href="#分页参数" class="headerlink" title="分页参数"></a>分页参数</h3><ul><li><code>pageNum</code>：当前页码</li><li><code>pageSize</code>：每页条数</li><li><code>startIndex</code>：分页起始索引（公式：<code>startIndex = (pageNum - 1) * pageSize</code>）</li></ul><h2 id="四、MyBatisX-逆向生成"><a href="#四、MyBatisX-逆向生成" class="headerlink" title="四、MyBatisX 逆向生成"></a>四、MyBatisX 逆向生成</h2><p>MyBatisX 是 IDEA 插件，支持<strong>根据数据库表一键生成</strong> MyBatis 开发所需的：</p><ul><li>实体类（Entity）</li><li>Mapper 接口</li><li>Mapper XML 文件</li><li>基础 CRUD 代码</li></ul><h3 id="生成步骤"><a href="#生成步骤" class="headerlink" title="生成步骤"></a>生成步骤</h3><ol><li>配置生成选项：<ul><li><code>module path</code>：模块路径</li><li><code>base package</code>：基础包名</li><li><code>relative package</code>：实体类 &#x2F; 接口的相对包路径（如 <code>entity</code>、<code>mapper</code>）</li><li><code>tableName</code>：数据库表名</li><li><code>className</code>：生成的类名策略（驼峰或与表名一致）</li></ul></li><li>选择注解、模板：<ul><li>注解支持：MyBatis-Plus、JPA 等</li><li>模板选择：<code>default-all</code>（生成完整 CRUD 代码）或 <code>default-empty</code>（生成空结构）</li><li>可选配置：Lombok 支持、toString&#x2F;hashCode&#x2F;equals 方法生成等</li></ul></li></ol><h2 id="五、各特性价值总结"><a href="#五、各特性价值总结" class="headerlink" title="五、各特性价值总结"></a>五、各特性价值总结</h2><table><thead><tr><th>特性</th><th>核心价值</th><th>适用场景</th></tr></thead><tbody><tr><td>缓存机制</td><td>减少数据库访问，提升查询性能</td><td>读多写少的业务场景</td></tr><tr><td>插件机制</td><td>无侵入扩展 MyBatis 核心流程</td><td>分页、SQL 监控、数据脱敏等</td></tr><tr><td>PageHelper 分页</td><td>简化分页逻辑，自动生成分页 SQL</td><td>所有需要分页的查询场景</td></tr><tr><td>MyBatisX 逆向生成</td><td>自动生成基础 CRUD 代码，提升开发效率</td><td>新项目初始化、表结构变更后</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 动态 SQL 笔记</title>
      <link href="/posts/23148.html"/>
      <url>/posts/23148.html</url>
      
        <content type="html"><![CDATA[<p>动态 SQL 是 MyBatis 核心特性之一，支持<strong>根据不同条件动态拼接 SQL 语句</strong>，灵活适配复杂业务场景。</p><h2 id="一、核心标签分类"><a href="#一、核心标签分类" class="headerlink" title="一、核心标签分类"></a>一、核心标签分类</h2><table><thead><tr><th>标签类型</th><th>包含标签</th><th>作用</th></tr></thead><tbody><tr><td>条件判断</td><td><code>&lt;if&gt;</code>、<code>&lt;where&gt;</code>、<code>&lt;choose&gt;</code></td><td>按条件动态拼接 SQL 片段</td></tr><tr><td>片段控制</td><td><code>&lt;trim&gt;</code>、<code>&lt;set&gt;</code></td><td>智能处理 SQL 片段的前缀、后缀（如 <code>WHERE</code>、<code>SET</code> 关键字）</td></tr><tr><td>循环遍历</td><td><code>&lt;foreach&gt;</code></td><td>遍历集合 &#x2F; 数组，动态生成批量操作 SQL</td></tr><tr><td>片段复用</td><td><code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code></td><td>抽取可复用的 SQL 片段，提升代码复用性</td></tr></tbody></table><h2 id="二、条件判断标签"><a href="#二、条件判断标签" class="headerlink" title="二、条件判断标签"></a>二、条件判断标签</h2><h3 id="1"><a href="#1" class="headerlink" title="1. &lt;if&gt; + &lt;where&gt;"></a>1. <code>&lt;if&gt;</code> + <code>&lt;where&gt;</code></h3><p><strong>作用</strong>：根据条件动态拼接 <code>WHERE</code> 子句，自动处理 <code>AND</code>&#x2F;<code>OR</code> 关键字冗余问题。</p><p><strong>示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">  select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">      emp_name=#&#123;empName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary != null&quot;</span>&gt;</span></span><br><span class="line">      and emp_salary&gt;#&#123;empSalary&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>empName</code> 和 <code>empSalary</code> 都不为空，生成 <code>WHERE emp_name=? AND emp_salary&gt;?</code>。</li><li>若某条件不满足，<code>&lt;where&gt;</code> 会自动剔除多余的 <code>AND</code>&#x2F;<code>OR</code>。</li></ul><h3 id="2"><a href="#2" class="headerlink" title="2. &lt;choose&gt; + &lt;when&gt; + &lt;otherwise&gt;"></a>2. <code>&lt;choose&gt;</code> + <code>&lt;when&gt;</code> + <code>&lt;otherwise&gt;</code></h3><p><strong>作用</strong>：多条件分支，仅执行<strong>第一个满足条件</strong>的分支（类似 Java <code>if-else if-else</code>）。</p><p><strong>示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  select emp_id,emp_name,emp_salary from t_emp where</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="symbol">&amp;lt;</span> 3000<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>1=1<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>empName</code> 不为空，执行 <code>emp_name=?</code>；</li><li>若 <code>empName</code> 为空但 <code>empSalary &lt; 3000</code>，执行 <code>emp_salary &lt; 3000</code>；</li><li>若都不满足，执行 <code>1=1</code>（查询所有）。</li></ul><h2 id="三、片段控制标签"><a href="#三、片段控制标签" class="headerlink" title="三、片段控制标签"></a>三、片段控制标签</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1. &lt;trim&gt;"></a>1. <code>&lt;trim&gt;</code></h3><p><strong>作用</strong>：通过自定义前缀、后缀和覆盖规则，灵活控制 SQL 片段的拼接（可替代 <code>&lt;where&gt;</code>、<code>&lt;set&gt;</code>）。</p><p><strong>属性说明</strong>：</p><ul><li><code>prefix</code>：为 SQL 片段添加前缀（如 <code>WHERE</code>）。</li><li><code>suffix</code>：为 SQL 片段添加后缀。</li><li><code>prefixOverrides</code>：覆盖前缀的冗余关键字（如 <code>AND</code>、<code>OR</code>）。</li><li><code>suffixOverrides</code>：覆盖后缀的冗余关键字（如 <code>,</code>）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByTrim&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp</span><br><span class="line">  <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">      emp_name=#&#123;empName&#125; and</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;gt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">      emp_salary&gt;#&#123;empSalary&#125; and</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empAge <span class="symbol">&amp;lt;</span>= 20&quot;</span>&gt;</span></span><br><span class="line">      emp_age=#&#123;empAge&#125; or</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empGender==&#x27;male&#x27;&quot;</span>&gt;</span></span><br><span class="line">      emp_gender=#&#123;empGender&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-1"><a href="#2-1" class="headerlink" title="2. &lt;set&gt;"></a>2. <code>&lt;set&gt;</code></h3><p><strong>作用</strong>：专用于 <code>UPDATE</code> 语句，自动处理 <code>SET</code> 子句中冗余的 <code>,</code>。</p><p><strong>示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span></span><br><span class="line">  update t_emp</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">      emp_name=#&#123;empName&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">      emp_salary=#&#123;empSalary&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、循环遍历标签"><a href="#四、循环遍历标签" class="headerlink" title="四、循环遍历标签 &lt;foreach&gt;"></a>四、循环遍历标签 <code>&lt;foreach&gt;</code></h2><p><strong>作用</strong>：遍历集合 &#x2F; 数组，动态生成批量操作 SQL（如批量插入、批量查询 <code>IN</code> 条件）。</p><p><strong>属性说明</strong>：</p><ul><li><code>collection</code>：要遍历的集合 &#x2F; 数组（必填）。</li><li><code>item</code>：遍历过程中每个元素的别名（必填）。</li><li><code>separator</code>：元素之间的分隔符（如 <code>,</code>、<code>;</code>）。</li><li><code>open</code>：SQL 片段的前缀（如 <code>values</code>、<code>(</code>）。</li><li><code>close</code>：SQL 片段的后缀（如 <code>)</code>）。</li><li><code>index</code>：遍历 List 时为<strong>索引</strong>，遍历 Map 时为<strong>键</strong>。</li></ul><p><strong>示例 1：批量插入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;values&quot;</span> <span class="attr">index</span>=<span class="string">&quot;myIndex&quot;</span>&gt;</span></span><br><span class="line">  (#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生成 SQL：<code>values (?,0,?,?), (?,1,?,?)</code></p><p><strong>示例 2：批量更新（需开启 <code>allowMultiQueries=true</code>）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeBatch&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span></span><br><span class="line">    update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生成 SQL：<code>update ... where ...; update ... where ...</code></p><h2 id="五、SQL-片段复用"><a href="#五、SQL-片段复用" class="headerlink" title="五、SQL 片段复用 &lt;sql&gt; + &lt;include&gt;"></a>五、SQL 片段复用 <code>&lt;sql&gt;</code> + <code>&lt;include&gt;</code></h2><p><strong>作用</strong>：抽取可复用的 SQL 片段（如列名、条件），通过 <code>&lt;include&gt;</code> 引用，提升代码复用性。</p><p><strong>示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 抽取可复用的列名片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumn&quot;</span>&gt;</span></span><br><span class="line">  emp_id,emp_name,emp_age,emp_salary,emp_gender</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引用片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumn&quot;</span>/&gt;</span></span><br><span class="line">  from `t_emp` where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="六、特殊字符转义"><a href="#六、特殊字符转义" class="headerlink" title="六、特殊字符转义"></a>六、特殊字符转义</h2><p>在 XML 中，以下特殊字符需使用<strong>转义字符</strong>，否则会导致解析错误：</p><table><thead><tr><th>原始字符</th><th>转义字符</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td><code>&amp;amp;</code></td></tr><tr><td><code>&lt;</code></td><td><code>&amp;lt;</code></td></tr><tr><td><code>&gt;</code></td><td><code>&amp;gt;</code></td></tr><tr><td><code>&quot;</code></td><td><code>&amp;quot;</code></td></tr><tr><td><code>&#39;</code></td><td><code>&amp;apos;</code></td></tr></tbody></table><p><strong>示例</strong>：<code>empSalary &amp;lt; 3000</code> 表示 <code>empSalary &lt; 3000</code>。</p><h2 id="七、动态-SQL-优势"><a href="#七、动态-SQL-优势" class="headerlink" title="七、动态 SQL 优势"></a>七、动态 SQL 优势</h2><ul><li><strong>灵活性</strong>：根据业务条件动态生成 SQL，适配复杂查询场景。</li><li><strong>简洁性</strong>：通过标签自动处理 SQL 冗余（如多余的 <code>AND</code>、<code>SET</code> 后的 <code>,</code>）。</li><li><strong>复用性</strong>：通过 <code>&lt;sql&gt;</code> 抽取片段，减少重复代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 延迟加载（懒加载）笔记</title>
      <link href="/posts/22421.html"/>
      <url>/posts/22421.html</url>
      
        <content type="html"><![CDATA[<p>延迟加载（懒加载）是 MyBatis 分步查询的重要特性，指<strong>关联数据仅在被访问时才会触发查询</strong>，而非在主查询时一次性加载，可大幅优化性能。</p><h2 id="一、延迟加载的开启配置"><a href="#一、延迟加载的开启配置" class="headerlink" title="一、延迟加载的开启配置"></a>一、延迟加载的开启配置</h2><p>需在 MyBatis 全局配置中开启以下两项：</p><ol><li><code>mybatis.configuration.lazy-loading-enabled=true</code>：<strong>全局开启延迟加载</strong>。</li><li><code>mybatis.configuration.aggressive-lazy-loading=false</code>：关闭 “激进式懒加载”（确保仅在访问关联属性时才触发分步查询，而非加载主对象时一次性加载所有关联）。</li></ol><h2 id="二、延迟加载与分步查询的关系"><a href="#二、延迟加载与分步查询的关系" class="headerlink" title="二、延迟加载与分步查询的关系"></a>二、延迟加载与分步查询的关系</h2><p>延迟加载是分步查询的<strong>性能增强特性</strong>：</p><ul><li>分步查询负责将关联查询拆分为多次单表查询；</li><li>延迟加载负责控制这些分步查询的<strong>执行时机</strong>（仅当关联属性被访问时才执行）。</li></ul><h2 id="三、作用与优势"><a href="#三、作用与优势" class="headerlink" title="三、作用与优势"></a>三、作用与优势</h2><ul><li><strong>性能优化</strong>：避免加载未使用的关联数据，减少数据库查询次数和数据传输量。</li><li><strong>按需加载</strong>：仅在业务需要时加载关联数据，贴合实际使用场景。</li></ul><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ul><li>延迟加载仅在<strong>分步查询</strong>场景下生效，若关联查询是通过 <code>JOIN</code> 实现的，无法触发延迟加载。</li><li>若需临时禁用某条 SQL 的延迟加载，可在 <code>&lt;select&gt;</code> 标签中通过 <code>fetchType=&quot;eager&quot;</code> 强制立即加载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 分步查询（含超级分步）笔记</title>
      <link href="/posts/58332.html"/>
      <url>/posts/58332.html</url>
      
        <content type="html"><![CDATA[<p>分步查询是 MyBatis 处理<strong>关联关系（一对一、一对多）</strong> 的高效方式，核心是将复杂关联查询拆分为多次独立单表查询，按需加载数据，支持延迟加载，同时降低代码耦合度。</p><h2 id="一、核心标签与属性"><a href="#一、核心标签与属性" class="headerlink" title="一、核心标签与属性"></a>一、核心标签与属性</h2><p>分步查询通过 <code>resultMap</code> 中的关联标签实现，核心属性如下：</p><table><thead><tr><th>标签</th><th>作用场景</th><th>核心属性</th></tr></thead><tbody><tr><td><code>association</code></td><td>一对一关联</td><td><code>select</code>：下一步查询的 Mapper 方法全路径<br><br><code>javaType</code>：关联对象的类型<br><br><code>column</code>：传递给下一步的参数列</td></tr><tr><td><code>collection</code></td><td>一对多关联</td><td><code>select</code>：下一步查询的 Mapper 方法全路径<br><br><code>ofType</code>：集合中元素的类型<br><br><code>column</code>：传递给下一步的参数列</td></tr></tbody></table><ul><li><code>select</code>：必须指定「命名空间 + 方法名」，确保能找到目标查询方法</li><li><code>column</code>：支持单个参数（<code>column=&quot;字段名&quot;</code>）或多个参数（<code>column=&quot;&#123;paramKey=字段名, ...&#125;&quot;</code>）</li></ul><h2 id="二、基础分步查询实现"><a href="#二、基础分步查询实现" class="headerlink" title="二、基础分步查询实现"></a>二、基础分步查询实现</h2><h3 id="1-一对一分步查询（association）"><a href="#1-一对一分步查询（association）" class="headerlink" title="1. 一对一分步查询（association）"></a>1. 一对一分步查询（<code>association</code>）</h3><p><strong>场景</strong>：查询订单（Order）时，分步加载关联的客户（Customer）信息</p><h4 id="相关表结构"><a href="#相关表结构" class="headerlink" title="相关表结构"></a>相关表结构</h4><ul><li><code>t_order</code>：id、address、amount、customer_id（关联 t_customer 的 id）</li><li><code>t_customer</code>：id、customer_name、phone</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mybatis.mapper.OrderCustomerStepMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 步骤1：独立查询客户（被分步调用的基础方法） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCustomerById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.mybatis.bean.Customer&quot;</span>&gt;</span></span><br><span class="line">        select * from t_customer where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 步骤2：自定义订单结果集，通过 association 分步关联客户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;OrderCustomerStepRM&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.mybatis.bean.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">property</span>=<span class="string">&quot;amount&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 一对一分步查询：调用 getCustomerById 方法，传递 customer_id 作为参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span>  &lt;!<span class="attr">--</span> <span class="attr">Order</span> <span class="attr">类中关联客户的属性名</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">                     javaType=&quot;com.example.mybatis.bean.Customer&quot;  <span class="comment">&lt;!-- 关联对象类型 --&gt;</span></span><br><span class="line">                     select=&quot;com.example.mybatis.mapper.OrderCustomerStepMapper.getCustomerById&quot;  <span class="comment">&lt;!-- 下一步查询方法 --&gt;</span></span><br><span class="line">                     column=&quot;customer_id&quot;/&gt;  <span class="comment">&lt;!-- 传递当前查询的 customer_id 字段值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 步骤3：查询订单的入口方法（触发分步查询） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrderByIdAndCustomerStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;OrderCustomerStepRM&quot;</span>&gt;</span></span><br><span class="line">        select * from t_order where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-一对多分步查询（collection）"><a href="#2-一对多分步查询（collection）" class="headerlink" title="2. 一对多分步查询（collection）"></a>2. 一对多分步查询（<code>collection</code>）</h3><p><strong>场景</strong>：查询客户（Customer）时，分步加载其关联的所有订单（Order）信息</p><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mybatis.mapper.OrderCustomerStepMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 步骤1：独立查询客户的所有订单（被分步调用的基础方法） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrdersByCustomerId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.mybatis.bean.Order&quot;</span>&gt;</span></span><br><span class="line">        select * from t_order where customer_id = #&#123;cId&#125;  <span class="comment">&lt;!-- 参数 cId 对应 column 传递的值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 步骤2：自定义客户结果集，通过 collection 分步关联订单 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerOrdersStepRM&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.mybatis.bean.Customer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">property</span>=<span class="string">&quot;phone&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 一对多分步查询：调用 getOrdersByCustomerId 方法，传递 id 作为参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span>  &lt;!<span class="attr">--</span> <span class="attr">Customer</span> <span class="attr">类中关联订单集合的属性名</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">                    ofType=&quot;com.example.mybatis.bean.Order&quot;  <span class="comment">&lt;!-- 集合中元素类型 --&gt;</span></span><br><span class="line">                    select=&quot;com.example.mybatis.mapper.OrderCustomerStepMapper.getOrdersByCustomerId&quot;  <span class="comment">&lt;!-- 下一步查询方法 --&gt;</span></span><br><span class="line">                    column=&quot;id&quot;/&gt;  <span class="comment">&lt;!-- 传递当前查询的客户 id 字段值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 步骤3：查询客户的入口方法（触发分步查询） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCustomerByIdAndOrdersStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;CustomerOrdersStepRM&quot;</span>&gt;</span></span><br><span class="line">        select * from t_customer where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、超级分步查询（多层关联）"><a href="#三、超级分步查询（多层关联）" class="headerlink" title="三、超级分步查询（多层关联）"></a>三、超级分步查询（多层关联）</h2><p><strong>场景</strong>：查询订单 → 分步查询客户 → 再分步查询该客户的所有订单（三层关联：订单 → 客户 → 客户的所有订单）</p><p>核心逻辑：在第一层分步查询的关联标签（<code>association</code>&#x2F;<code>collection</code>）中，嵌套另一个 <code>resultMap</code>，触发第二层分步查询。</p><h3 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mybatis.mapper.OrderCustomerStepMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 基础方法：查询客户（被第一层分步调用） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCustomerById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.mybatis.bean.Customer&quot;</span>&gt;</span></span><br><span class="line">        select * from t_customer where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 基础方法：查询客户的所有订单（被第二层分步调用） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrdersByCustomerId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.mybatis.bean.Order&quot;</span>&gt;</span></span><br><span class="line">        select * from t_order where customer_id = #&#123;cId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 第二层 resultMap：客户 + 客户的订单（供超级分步查询嵌套使用） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersRM&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.mybatis.bean.Customer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">property</span>=<span class="string">&quot;phone&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 客户关联订单：第二层分步查询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">ofType</span>=<span class="string">&quot;com.example.mybatis.bean.Order&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">select</span>=<span class="string">&quot;com.example.mybatis.mapper.OrderCustomerStepMapper.getOrdersByCustomerId&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 第一层 resultMap：订单 + 客户 + 客户的订单（超级分步查询核心） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;OrderCustomerWithOrdersSuperStepRM&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.mybatis.bean.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">property</span>=<span class="string">&quot;amount&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 订单关联客户：第一层分步查询，嵌套客户的订单分步查询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">javaType</span>=<span class="string">&quot;com.example.mybatis.bean.Customer&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">&quot;com.example.mybatis.mapper.OrderCustomerStepMapper.getCustomerById&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">resultMap</span>=<span class="string">&quot;CustomerWithOrdersRM&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- 嵌套第二层 resultMap，触发超级分步 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 超级分步查询入口：查询订单，同时加载客户及客户的所有订单 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrderWithCustomerAndOrdersSuperStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;OrderCustomerWithOrdersSuperStepRM&quot;</span>&gt;</span></span><br><span class="line">        select * from t_order where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="超级分步查询执行流程"><a href="#超级分步查询执行流程" class="headerlink" title="超级分步查询执行流程"></a>超级分步查询执行流程</h3><ol><li>调用入口方法 <code>getOrderWithCustomerAndOrdersSuperStep</code>，查询目标订单基本信息</li><li>触发第一层分步查询：通过 <code>association</code> 调用 <code>getCustomerById</code>，传递 <code>customer_id</code> 查询客户信息</li><li>触发第二层分步查询：通过嵌套的 <code>CustomerWithOrdersRM</code> 中的 <code>collection</code>，调用 <code>getOrdersByCustomerId</code>，传递客户 <code>id</code> 查询所有订单</li><li>最终返回：订单对象 → 包含客户对象 → 客户对象包含订单集合</li></ol><h2 id="四、分步查询的优势"><a href="#四、分步查询的优势" class="headerlink" title="四、分步查询的优势"></a>四、分步查询的优势</h2><ol><li><strong>性能优化</strong>：按需加载数据，避免一次性查询大量冗余字段，支持延迟加载（仅访问关联属性时才执行分步查询）</li><li><strong>代码解耦</strong>：复杂关联拆分为独立单表查询方法，维护成本低，可复用</li><li><strong>灵活性高</strong>：支持多层嵌套（超级分步），满足复杂业务场景的关联查询需求</li></ol><h2 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h2><ol><li><code>column</code> 传递多参数时，格式为 <code>column=&quot;&#123;param1=字段1, param2=字段2&#125;&quot;</code>，对应目标方法的 <code>@Param</code> 注解参数名</li><li>嵌套分步查询时，需确保每层 <code>select</code> 指向的方法路径正确（命名空间 + 方法名）</li><li>延迟加载需在 MyBatis 全局配置中开启（<code>lazyLoadingEnabled=true</code>），否则会一次性执行所有分步查询</li><li>避免过度嵌套：多层分步查询会增加数据库连接次数，需平衡性能与业务需求</li></ol>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 结果封装与关联查询笔记</title>
      <link href="/posts/50789.html"/>
      <url>/posts/50789.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、返回普通数据"><a href="#一、返回普通数据" class="headerlink" title="一、返回普通数据"></a>一、返回普通数据</h2><p>用于封装<strong>基本类型</strong>（如 Long、Integer）或<strong>普通对象</strong>（如实体类），通过 <code>resultType</code> 配置。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 封装实体类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  select * from `t_emp` where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 封装基本类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">  select count(*) from `t_emp`</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h3><ul><li>若开启 <code>mapUnderscoreToCamelCase = true</code>（MyBatis 全局配置），可自动将数据库下划线命名（如 <code>emp_name</code>）映射为 Java 驼峰命名（如 <code>empName</code>）。</li></ul><h2 id="二、返回-List、Map"><a href="#二、返回-List、Map" class="headerlink" title="二、返回 List、Map"></a>二、返回 List、Map</h2><h3 id="1-返回-List"><a href="#1-返回-List" class="headerlink" title="1. 返回 List"></a>1. 返回 List</h3><p><code>resultType</code> 配置为集合的<strong>元素类型</strong>（MyBatis 会自动封装为 List）。</p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  select * from `t_emp`</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应接口方法：<code>List&lt;Employee&gt; getEmpList();</code></p><h3 id="2-返回-Map"><a href="#2-返回-Map" class="headerlink" title="2. 返回 Map"></a>2. 返回 Map</h3><ul><li>单条记录映射为 Map：<code>resultType</code> 配置为 <code>map</code>。</li><li>多条记录以某字段为键映射为 Map：使用 <code>@MapKey</code> 注解指定键字段。</li></ul><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单条记录转 Map --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select * from `t_emp` where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多条记录转 Map（以 id 为键） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpMapList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  select * from `t_emp`</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单条记录转 Map</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getEmpMap</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多条记录转 Map（@MapKey 指定键为 id）</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;Long, Employee&gt; <span class="title function_">getEmpMapList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="三、自定义结果集（resultMap）"><a href="#三、自定义结果集（resultMap）" class="headerlink" title="三、自定义结果集（resultMap）"></a>三、自定义结果集（<code>resultMap</code>）</h2><p>当数据库字段与实体属性命名不匹配（且未开启驼峰映射），或需处理<strong>一对一、一对多</strong>关联时，使用 <code>resultMap</code> 自定义映射规则。</p><h3 id="基础映射示例（单表字段映射）"><a href="#基础映射示例（单表字段映射）" class="headerlink" title="基础映射示例（单表字段映射）"></a>基础映射示例（单表字段映射）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;EmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- id 标签：映射主键字段 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- result 标签：映射普通字段 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empSalary&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用自定义 resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;EmpResultMap&quot;</span>&gt;</span></span><br><span class="line">  select * from `t_emp` where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关联关系映射（association-与-collection）"><a href="#关联关系映射（association-与-collection）" class="headerlink" title="关联关系映射（association 与 collection）"></a>关联关系映射（<code>association</code> 与 <code>collection</code>）</h3><h4 id="1-一对一（association-标签）"><a href="#1-一对一（association-标签）" class="headerlink" title="1. 一对一（association 标签）"></a>1. 一对一（<code>association</code> 标签）</h4><p>用于映射<strong>对象类型的关联属性</strong>（如员工关联部门）。</p><ul><li><code>javaType</code>：指定关联对象的类型。</li><li><code>select</code>：分步查询时，指定调用的 Mapper 方法。</li><li><code>column</code>：分步查询时，传递的参数列。</li></ul><p>示例场景：查询订单时关联查询客户信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;OrderResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Order&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderNo&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 一对一关联客户 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Customer&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.CustomerMapper.getCustomerById&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-一对多（collection-标签）"><a href="#2-一对多（collection-标签）" class="headerlink" title="2. 一对多（collection 标签）"></a>2. 一对多（<code>collection</code> 标签）</h4><p>用于映射<strong>集合类型的关联属性</strong>（如客户关联多个订单）。</p><ul><li><code>ofType</code>：指定集合中元素的类型。</li><li><code>select</code>：分步查询时，指定调用的 Mapper 方法。</li><li><code>column</code>：分步查询时，传递的参数列。</li></ul><p>示例场景：查询客户时关联查询所有订单</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Customer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 一对多关联订单 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Order&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.OrderMapper.getOrdersByCustomerId&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、分步查询与延迟加载"><a href="#四、分步查询与延迟加载" class="headerlink" title="四、分步查询与延迟加载"></a>四、分步查询与延迟加载</h2><ul><li><strong>分步查询</strong>：将关联查询拆分为多次单表查询，减少一次性数据量（如先查员工，再按需查部门）。</li><li><strong>延迟加载</strong>：按需加载关联数据（如查询员工时不主动加载部门，当调用部门属性时才加载）。</li></ul><h2 id="五、MyBatis-默认别名规则（不重要，最佳实现是写全类名）"><a href="#五、MyBatis-默认别名规则（不重要，最佳实现是写全类名）" class="headerlink" title="五、MyBatis 默认别名规则（不重要，最佳实现是写全类名）"></a>五、MyBatis 默认别名规则（不重要，最佳实现是写全类名）</h2><p>MyBatis 对常见 Java 类型提供了默认别名，可简化 <code>resultType</code> 配置，但<strong>推荐写全类名以提升可读性</strong>。</p><table><thead><tr><th>别名</th><th>Java 类型</th><th>别名</th><th>Java 类型</th><th>别名</th><th>Java 类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td><td>long</td><td>Long</td><td>object[]</td><td>Object[]</td></tr><tr><td>_char（3.5.10+）</td><td>char</td><td>short</td><td>Short</td><td>map</td><td>Map</td></tr><tr><td>_character（3.5.10+）</td><td>char</td><td>int</td><td>Integer</td><td>hashmap</td><td>HashMap</td></tr><tr><td>_long</td><td>long</td><td>integer</td><td>Integer</td><td>list</td><td>List</td></tr><tr><td>_short</td><td>short</td><td>double</td><td>Double</td><td>arraylist</td><td>ArrayList</td></tr><tr><td>_int</td><td>int</td><td>float</td><td>Float</td><td>collection</td><td>Collection</td></tr><tr><td>_integer</td><td>int</td><td>boolean</td><td>Boolean</td><td>iterator</td><td>Iterator</td></tr><tr><td>_double</td><td>double</td><td>date</td><td>Date</td><td></td><td></td></tr><tr><td>_float</td><td>float</td><td>decimal</td><td>BigDecimal</td><td></td><td></td></tr><tr><td>_boolean</td><td>boolean</td><td>bigdecimal</td><td>BigDecimal</td><td></td><td></td></tr><tr><td>string</td><td>String</td><td>biginteger</td><td>BigInteger</td><td></td><td></td></tr><tr><td>byte</td><td>Byte</td><td>object</td><td>Object</td><td></td><td></td></tr><tr><td>char（3.5.10+）</td><td>Character</td><td>date[]</td><td>Date[]</td><td></td><td></td></tr><tr><td>character（3.5.10+）</td><td>Character</td><td>decimal[]</td><td>BigDecimal[]</td><td></td><td></td></tr><tr><td></td><td></td><td>bigdecimal[]</td><td>BigDecimal[]</td><td></td><td></td></tr><tr><td></td><td></td><td>biginteger[]</td><td>BigInteger[]</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 参数传递</title>
      <link href="/posts/57750.html"/>
      <url>/posts/57750.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、-与-的核心区别"><a href="#一、-与-的核心区别" class="headerlink" title="一、#{} 与 ${} 的核心区别"></a>一、<code>#&#123;&#125;</code> 与 <code>$&#123;&#125;</code> 的核心区别</h2><table><thead><tr><th>语法</th><th>底层实现</th><th>编译方式</th><th>安全特性</th><th>适用场景</th></tr></thead><tbody><tr><td><code>#&#123;&#125;</code></td><td><code>PreparedStatement</code></td><td>预编译</td><td>防 SQL 注入</td><td>大部分参数传递场景（推荐优先用）</td></tr><tr><td><code>$&#123;&#125;</code></td><td><code>Statement</code></td><td>字符串拼接</td><td>有 SQL 注入风险</td><td>表名、列名动态拼接（需手动防注入）</td></tr></tbody></table><h2 id="二、参数传递场景与取值方式"><a href="#二、参数传递场景与取值方式" class="headerlink" title="二、参数传递场景与取值方式"></a>二、参数传递场景与取值方式</h2><h3 id="1-单个参数"><a href="#1-单个参数" class="headerlink" title="1. 单个参数"></a>1. 单个参数</h3><ul><li><p><strong>普通类型（如 Long、String）</strong>：</p><p>  示例方法：<code>Employee getEmpById(Long id);</code></p><p>  XML 取值：<code>#&#123;id&#125;</code></p></li><li><p><strong>List 类型</strong>：</p><p>  示例方法：<code>List&lt;Employee&gt; getEmpByIds(List&lt;Long&gt; ids);</code></p><p>  XML 取值：<code>#&#123;ids[0]&#125;</code>（取列表第一个元素，可遍历）</p></li><li><p><strong>对象类型</strong>：</p><p>  示例方法：<code>int addEmp(Employee emp);</code>（Employee 含 <code>name</code>、<code>age</code> 属性）</p><p>  XML 取值：<code>#&#123;name&#125;</code>、<code>#&#123;age&#125;</code></p></li><li><p><strong>Map 类型</strong>：</p><p>  示例方法：<code>Employee getEmpByMap(Map&lt;String, Object&gt; map);</code>（map 含 <code>id</code>、<code>name</code> 键）</p><p>  XML 取值：<code>#&#123;id&#125;</code>、<code>#&#123;name&#125;</code></p></li></ul><h3 id="2-多个参数"><a href="#2-多个参数" class="headerlink" title="2. 多个参数"></a>2. 多个参数</h3><ul><li><p><strong>无 <code>@Param</code> 注解</strong>（新版 MyBatis 兼容，不推荐）：</p><p>  示例方法：<code>Employee getEmp(Long id, String name);</code></p><p>  XML 取值：<code>#&#123;param1&#125;</code>（id）、<code>#&#123;param2&#125;</code>（name）</p></li><li><p><strong>有 <code>@Param</code> 注解</strong>（推荐，明确参数名）：</p><p>  示例方法：<code>Employee getEmp(@Param(&quot;id&quot;) Long id, @Param(&quot;name&quot;) String name);</code></p><p>  XML 取值：<code>#&#123;id&#125;</code>、<code>#&#123;name&#125;</code></p></li><li><p><strong>混合参数（扩展场景）</strong>：</p><p>  示例方法：<code>List&lt;Employee&gt; getEmp(@Param(&quot;id&quot;) Long id, @Param(&quot;ext&quot;) Map&lt;String, Object&gt; ext, @Param(&quot;ids&quot;) List&lt;Long&gt; ids, @Param(&quot;emp&quot;) Employee emp);</code></p><p>  XML 取值：</p><ul><li>单个参数：<code>#&#123;id&#125;</code></li><li>Map 内属性：<code>#&#123;ext.name&#125;</code>、<code>#&#123;ext.age&#125;</code></li><li>List 元素：<code>#&#123;ids[0]&#125;</code>、<code>#&#123;ids[1]&#125;</code></li><li>对象属性：<code>#&#123;emp.email&#125;</code>、<code>#&#123;emp.age&#125;</code></li></ul></li></ul><h2 id="三、最佳实践"><a href="#三、最佳实践" class="headerlink" title="三、最佳实践"></a>三、最佳实践</h2><ol><li>优先使用 <code>#&#123;&#125;</code> 进行参数传递，避免 SQL 注入风险。</li><li>若需动态拼接表名、列名（如分表场景），使用 <code>$&#123;&#125;</code> 时必须手动做 SQL 注入防护（如参数白名单校验）。</li><li>即使只有一个参数，也建议使用 <code>@Param</code> 注解明确参数名，提升代码可读性与可维护性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis Mapper XML 核心知识笔记(入门)</title>
      <link href="/posts/63725.html"/>
      <url>/posts/63725.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Mapper-XML-基础结构"><a href="#一、Mapper-XML-基础结构" class="headerlink" title="一、Mapper XML 基础结构"></a>一、Mapper XML 基础结构</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;全限定接口名&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CRUD 标签在此定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;?xml ... ?&gt;</code>：XML 文档声明，指定版本和编码。</li><li><code>&lt;!DOCTYPE ... &gt;</code>：MyBatis Mapper 的 DTD 约束，用于校验 XML 结构合法性。</li><li><code>&lt;mapper namespace=&quot;...&quot;&gt;</code>：命名空间，需与对应的 Mapper 接口<strong>全类名</strong>一致，是 XML 与接口绑定的关键。</li></ul><h2 id="二、Mapper-XML-与-DAO-接口的映射关系"><a href="#二、Mapper-XML-与-DAO-接口的映射关系" class="headerlink" title="二、Mapper XML 与 DAO 接口的映射关系"></a>二、Mapper XML 与 DAO 接口的映射关系</h2><table><thead><tr><th>DAO 层概念</th><th>Mapper XML 对应配置</th><th>说明</th></tr></thead><tbody><tr><td>DAO 接口</td><td><code>&lt;mapper namespace=&quot;接口全类名&quot;&gt;</code></td><td>命名空间与接口全类名一一对应</td></tr><tr><td>DAO 方法</td><td>CRUD 标签的 <code>id</code> 属性</td><td><code>id</code> 需与接口方法名完全一致</td></tr><tr><td>方法返回值类型</td><td>CRUD 标签的 <code>resultType</code> 或 <code>resultMap</code></td><td>对应方法的返回值类型（实体类、基本类型等）</td></tr><tr><td>方法参数</td><td>CRUD 标签内的 <code>#&#123;参数名&#125;</code></td><td>对应方法的参数，支持 OGNL 表达式取值</td></tr></tbody></table><h2 id="三、CRUD-标签使用（以员工表-t-emp-为例）"><a href="#三、CRUD-标签使用（以员工表-t-emp-为例）" class="headerlink" title="三、CRUD 标签使用（以员工表 t_emp 为例）"></a>三、CRUD 标签使用（以员工表 <code>t_emp</code> 为例）</h2><h3 id="1-查询（）"><a href="#1-查询（）" class="headerlink" title="1. 查询（&lt;select&gt;）"></a>1. 查询（<code>&lt;select&gt;</code>）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;实体类全类名&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM t_emp WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;实体类全类名&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>id</code>：与 Mapper 接口方法名一致。</li><li><code>resultType</code>：指定查询结果的封装类型（实体类、List 等）。</li></ul><h3 id="2-新增（）"><a href="#2-新增（）" class="headerlink" title="2. 新增（&lt;insert&gt;）"></a>2. 新增（<code>&lt;insert&gt;</code>）</h3><h4 id="普通新增"><a href="#普通新增" class="headerlink" title="普通新增"></a>普通新增</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">  INSERT INTO t_emp(emp_name, emp_salary) </span><br><span class="line">  VALUES(#&#123;empName&#125;, #&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自增-ID-自动回填"><a href="#自增-ID-自动回填" class="headerlink" title="自增 ID 自动回填"></a>自增 ID 自动回填</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;实体类中ID属性名&quot;</span>&gt;</span></span><br><span class="line">  INSERT INTO t_emp(emp_name, emp_salary) </span><br><span class="line">  VALUES(#&#123;empName&#125;, #&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>useGeneratedKeys=&quot;true&quot;</code>：开启自增主键回填功能。</li><li><code>keyProperty=&quot;empId&quot;</code>：指定实体类中接收自增 ID 的属性名。</li></ul><h3 id="3-修改（）"><a href="#3-修改（）" class="headerlink" title="3. 修改（&lt;update&gt;）"></a>3. 修改（<code>&lt;update&gt;</code>）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">  UPDATE t_emp </span><br><span class="line">  SET emp_salary=#&#123;empSalary&#125; </span><br><span class="line">  WHERE emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-删除（）"><a href="#4-删除（）" class="headerlink" title="4. 删除（&lt;delete&gt;）"></a>4. 删除（<code>&lt;delete&gt;</code>）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span>&gt;</span></span><br><span class="line">  DELETE FROM t_emp WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、核心优势与规范"><a href="#四、核心优势与规范" class="headerlink" title="四、核心优势与规范"></a>四、核心优势与规范</h2><ul><li><strong>解耦性</strong>：SQL 与 Java 代码分离，便于维护和优化。</li><li><strong>映射规范</strong>：<code>namespace</code> 与接口全类名一致，<code>id</code> 与方法名一致，保证 XML 与接口的强绑定。</li><li><strong>参数与结果映射</strong>：通过 <code>#&#123;参数名&#125;</code> 取参，<code>resultType/resultMap</code> 封装结果，简化数据操作流程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 数据库优化完全笔记</title>
      <link href="/posts/131.html"/>
      <url>/posts/131.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、整体优化策略（8-大维度）"><a href="#一、整体优化策略（8-大维度）" class="headerlink" title="一、整体优化策略（8 大维度）"></a>一、整体优化策略（8 大维度）</h2><h3 id="1-选择合适的存储引擎"><a href="#1-选择合适的存储引擎" class="headerlink" title="1. 选择合适的存储引擎"></a>1. 选择合适的存储引擎</h3><ul><li>核心原则：引擎作用于<strong>单个表</strong>，需根据表的业务场景选型（而非全局统一）</li><li>常用引擎：InnoDB（默认首选，支持事务、行锁、外键，适合高并发 &#x2F; 数据一致性场景）、MyISAM（读多写少、无事务需求，如日志表）</li></ul><h3 id="2-优化-MySQL-服务配置（my-ini-配置文件）"><a href="#2-优化-MySQL-服务配置（my-ini-配置文件）" class="headerlink" title="2. 优化 MySQL 服务配置（my.ini 配置文件）"></a>2. 优化 MySQL 服务配置（my.ini 配置文件）</h3><ul><li>关键参数：<ul><li><code>DEFAULT_STORAGE_ENGINE</code>：指定默认存储引擎（推荐设为 InnoDB）</li><li><code>INNODB_BUFFER_POOL_SIZE</code>：InnoDB 缓存池大小（建议设为物理内存的 50%-70%，提升数据缓存命中率）</li><li>其他补充：<code>max_connections</code>（最大连接数）、<code>query_cache_size</code>（查询缓存，按需开启）等</li></ul></li></ul><h3 id="3-创建高效索引"><a href="#3-创建高效索引" class="headerlink" title="3. 创建高效索引"></a>3. 创建高效索引</h3><ul><li>核心目标：减少全表扫描，加速查询</li><li>设计原则：<ul><li>针对查询频繁的字段（where、join、order by 字段）建立索引</li><li>避免过度索引（索引会降低写入性能）</li><li>复合索引遵循「最左前缀原则」</li></ul></li></ul><h3 id="4-合理使用主外键"><a href="#4-合理使用主外键" class="headerlink" title="4. 合理使用主外键"></a>4. 合理使用主外键</h3><ul><li>作用：保证数据完整性（外键关联父表主键）</li><li>注意：避免不必要的外键（高并发写入场景可适当舍弃，通过程序保证一致性）</li></ul><h3 id="5-系统层优化（表结构-架构层面）"><a href="#5-系统层优化（表结构-架构层面）" class="headerlink" title="5. 系统层优化（表结构 &#x2F; 架构层面）"></a>5. 系统层优化（表结构 &#x2F; 架构层面）</h3><ul><li>优化表结构与字段类型：<ul><li>字段类型尽量精准（如用 tinyint 代替 int，varchar 代替 char 存储变长字符串）</li><li>避免 NULL 字段（用默认值替代，如 0 代替 NULL）</li></ul></li><li>架构扩展：<ul><li>分库分表：解决单库 &#x2F; 单表数据量过大问题（水平分表 &#x2F; 垂直分表）</li><li>读写分离：主库写入、从库查询，分散数据库压力</li></ul></li></ul><h3 id="6-查询语句优化（核心重点，详见下文）"><a href="#6-查询语句优化（核心重点，详见下文）" class="headerlink" title="6. 查询语句优化（核心重点，详见下文）"></a>6. 查询语句优化（核心重点，详见下文）</h3><h3 id="7-程序代码层面优化"><a href="#7-程序代码层面优化" class="headerlink" title="7. 程序代码层面优化"></a>7. 程序代码层面优化</h3><ul><li>使用缓存：将热点数据存入 Redis&#x2F;Memcached，减少数据库查询</li><li>引入 NoSQL 数据库：非结构化 &#x2F; 高并发读写场景（如用户行为日志）用 MongoDB 等，分流 MySQL 压力</li></ul><h3 id="8-硬件与集群优化"><a href="#8-硬件与集群优化" class="headerlink" title="8. 硬件与集群优化"></a>8. 硬件与集群优化</h3><ul><li>提升服务器硬件：增加 CPU 核心、扩大物理内存、使用 SSD 硬盘（提升 IO 性能）</li><li>搭建数据库集群：主从复制、MGR（MySQL Group Replication），提高可用性与并发处理能力</li></ul><h2 id="二、查询语句优化（18-条实战准则）"><a href="#二、查询语句优化（18-条实战准则）" class="headerlink" title="二、查询语句优化（18 条实战准则）"></a>二、查询语句优化（18 条实战准则）</h2><h3 id="1-避免使用-SELECT-，明确指定字段名"><a href="#1-避免使用-SELECT-，明确指定字段名" class="headerlink" title="1. 避免使用 SELECT *，明确指定字段名"></a>1. 避免使用 SELECT *，明确指定字段名</h3><ul><li>反例：<code>SELECT * FROM t;</code></li><li>正例：<code>SELECT id, name, age FROM t;</code></li><li>理由：减少数据传输量，避免不必要字段加载，且利于索引覆盖查询</li></ul><h3 id="2-避免-WHERE-子句中对字段做-NULL-判断"><a href="#2-避免-WHERE-子句中对字段做-NULL-判断" class="headerlink" title="2. 避免 WHERE 子句中对字段做 NULL 判断"></a>2. 避免 WHERE 子句中对字段做 NULL 判断</h3><ul><li>反例：<code>SELECT * FROM t WHERE age IS NULL;</code></li><li>正例：字段默认设为 0，查询 <code>SELECT * FROM t WHERE age = 0;</code></li><li>理由：NULL 判断会导致引擎放弃索引，触发全表扫描</li></ul><h3 id="3-避免使用！-或-操作符"><a href="#3-避免使用！-或-操作符" class="headerlink" title="3. 避免使用！&#x3D; 或 &lt;&gt; 操作符"></a>3. 避免使用！&#x3D; 或 &lt;&gt; 操作符</h3><ul><li>反例：<code>SELECT * FROM t WHERE age != 99;</code></li><li>正例：<code>SELECT * FROM t WHERE age &gt; 99 OR age &lt; 99;</code>（等价逻辑，可走索引）</li><li>理由：!&#x3D;&#x2F;&lt;&gt;&#96; 会导致全表扫描</li></ul><h3 id="4-避免用-OR-连接查询条件，改用-UNION-ALL"><a href="#4-避免用-OR-连接查询条件，改用-UNION-ALL" class="headerlink" title="4. 避免用 OR 连接查询条件，改用 UNION ALL"></a>4. 避免用 OR 连接查询条件，改用 UNION ALL</h3><ul><li>反例：<code>SELECT * FROM t WHERE num = 10 OR num = 20;</code></li><li>正例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> num <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> num <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li>理由：OR 会触发全表扫描，UNION ALL 可分别走索引（注意：UNION 去重，UNION ALL 不去重，优先用后者）</li></ul><h3 id="5-用-EXISTS-代替-IN，NOT-EXISTS-代替-NOT-IN；范围查询用-BETWEEN-AND-代替-IN"><a href="#5-用-EXISTS-代替-IN，NOT-EXISTS-代替-NOT-IN；范围查询用-BETWEEN-AND-代替-IN" class="headerlink" title="5. 用 EXISTS 代替 IN，NOT EXISTS 代替 NOT IN；范围查询用 BETWEEN AND 代替 IN"></a>5. 用 EXISTS 代替 IN，NOT EXISTS 代替 NOT IN；范围查询用 BETWEEN AND 代替 IN</h3><ul><li>场景 1：子查询关联查询<ul><li><p>反例：<code>SELECT * FROM emp WHERE id IN (SELECT empId FROM kill_emp);</code></p></li><li><p>正例：<code>SELECT * FROM emp a WHERE EXISTS (SELECT &#39;x&#39; FROM kill_emp WHERE empId = a.id);</code></p><p>  （注：EXISTS 检查存在性，效率高于 IN；’x’ 可替换为任意常量，无需实际字段）</p></li></ul></li><li>场景 2：连续范围查询<ul><li>反例：<code>SELECT * FROM t WHERE id IN (1,2,3,...,9);</code></li><li>正例：<code>SELECT * FROM t WHERE id BETWEEN 1 AND 9;</code></li></ul></li></ul><h3 id="6-避免-LIKE-前缀模糊匹配（-开头）"><a href="#6-避免-LIKE-前缀模糊匹配（-开头）" class="headerlink" title="6. 避免 LIKE 前缀模糊匹配（% 开头）"></a>6. 避免 LIKE 前缀模糊匹配（% 开头）</h3><ul><li>反例：<code>SELECT * FROM t WHERE name LIKE &#39;%abc%&#39;;</code>（全表扫描）</li><li>正例：<code>SELECT * FROM t WHERE name LIKE &#39;abc%&#39;;</code>（可走索引）</li><li>理由：前缀模糊匹配无法利用索引，后缀 &#x2F; 中间模糊需借助全文索引</li></ul><h3 id="7-避免对-WHERE-子句中的字段做表达式运算"><a href="#7-避免对-WHERE-子句中的字段做表达式运算" class="headerlink" title="7. 避免对 WHERE 子句中的字段做表达式运算"></a>7. 避免对 WHERE 子句中的字段做表达式运算</h3><ul><li>反例：<code>SELECT * FROM t WHERE num / 2 = 100;</code></li><li>正例：<code>SELECT * FROM t WHERE num = 100 * 2;</code></li><li>理由：字段侧运算会导致引擎无法使用索引</li></ul><h3 id="8-避免对-WHERE-子句中的字段使用函数"><a href="#8-避免对-WHERE-子句中的字段使用函数" class="headerlink" title="8. 避免对 WHERE 子句中的字段使用函数"></a>8. 避免对 WHERE 子句中的字段使用函数</h3><ul><li>反例：<code>SELECT * FROM t WHERE SUBSTRING(name, 1, 3) = &#39;abc&#39;;</code>（查询以 abc 开头）</li><li>正例：<code>SELECT * FROM t WHERE name LIKE &#39;abc%&#39;;</code></li><li>理由：函数操作会破坏字段索引结构，触发全表扫描</li></ul><h3 id="9-禁止在-左边做函数-算数运算-表达式操作"><a href="#9-禁止在-左边做函数-算数运算-表达式操作" class="headerlink" title="9. 禁止在 &#x3D; 左边做函数 &#x2F; 算数运算 &#x2F; 表达式操作"></a>9. 禁止在 &#x3D; 左边做函数 &#x2F; 算数运算 &#x2F; 表达式操作</h3><ul><li>核心原则：索引字段需保持「原生形态」出现在查询条件左侧，否则无法命中索引</li></ul><h3 id="10-复合索引遵循「最左前缀原则」"><a href="#10-复合索引遵循「最左前缀原则」" class="headerlink" title="10. 复合索引遵循「最左前缀原则」"></a>10. 复合索引遵循「最左前缀原则」</h3><ul><li>示例：创建复合索引 <code>idx_name_age (name, age)</code></li><li>有效查询：<code>WHERE name = &#39;张三&#39;</code>（匹配最左字段）、<code>WHERE name = &#39;张三&#39; AND age = 20</code>（顺序与索引一致）</li><li>无效查询：<code>WHERE age = 20</code>（跳过最左字段，无法走索引）</li></ul><h3 id="11-优先使用数字型字段"><a href="#11-优先使用数字型字段" class="headerlink" title="11. 优先使用数字型字段"></a>11. 优先使用数字型字段</h3><ul><li>场景：存储手机号、身份证号等含数字信息的内容</li><li>理由：数字型字段查询效率高于字符型（字符型需额外做字符编码转换）</li></ul><h3 id="12-合理选择-CHAR-与-VARCHAR"><a href="#12-合理选择-CHAR-与-VARCHAR" class="headerlink" title="12. 合理选择 CHAR 与 VARCHAR"></a>12. 合理选择 CHAR 与 VARCHAR</h3><ul><li>CHAR：固定长度字符串（如性别、手机号），查询快，浪费存储空间</li><li>VARCHAR：变长字符串（如姓名、地址），节省空间，查询略慢（需计算长度）</li><li>原则：长度固定用 CHAR，长度不固定用 VARCHAR</li></ul><h3 id="13-先过滤再分组（WHERE-代替-HAVING）"><a href="#13-先过滤再分组（WHERE-代替-HAVING）" class="headerlink" title="13. 先过滤再分组（WHERE 代替 HAVING）"></a>13. 先过滤再分组（WHERE 代替 HAVING）</h3><ul><li>反例：<code>SELECT COUNT(*), school FROM student GROUP BY school HAVING school LIKE &#39;黑龙江%&#39;;</code></li><li>正例：<code>SELECT COUNT(*), school FROM student WHERE school LIKE &#39;黑龙江%&#39; GROUP BY school;</code></li><li>理由：HAVING 是分组后过滤，WHERE 是分组前过滤，减少分组的数据量</li></ul><h3 id="14-批量删除用-TRUNCATE-代替-DELETE（适合全表清空）"><a href="#14-批量删除用-TRUNCATE-代替-DELETE（适合全表清空）" class="headerlink" title="14. 批量删除用 TRUNCATE 代替 DELETE（适合全表清空）"></a>14. 批量删除用 TRUNCATE 代替 DELETE（适合全表清空）</h3><ul><li>反例：<code>DELETE FROM t;</code>（逐行删除，日志量大，可回滚）</li><li>正例：<code>TRUNCATE TABLE t;</code>（快速清空，日志量小，不可回滚）</li><li>注意：仅适用于全表清空，需谨慎使用（无事务回滚机制）</li></ul><h3 id="15-用表连接（JOIN）代替子查询"><a href="#15-用表连接（JOIN）代替子查询" class="headerlink" title="15. 用表连接（JOIN）代替子查询"></a>15. 用表连接（JOIN）代替子查询</h3><ul><li>反例：<code>SELECT ename, job, deptno FROM emp WHERE deptno = (SELECT deptno FROM dept WHERE deptname = &#39;开发部&#39;);</code></li><li>正例：<code>SELECT a.ename, a.job, a.deptno FROM emp a JOIN dept b ON a.deptno = b.deptno WHERE b.deptname = &#39;开发部&#39;;</code></li><li>理由：JOIN 效率高于子查询，MySQL 对 JOIN 优化更成熟</li></ul><h3 id="16-用-代替-，"><a href="#16-用-代替-，" class="headerlink" title="16. 用 &gt;&#x3D; 代替 &gt;，&lt;&#x3D; 代替 &lt;"></a>16. 用 &gt;&#x3D; 代替 &gt;，&lt;&#x3D; 代替 &lt;</h3><ul><li>反例：<code>SELECT * FROM t WHERE age &lt; 50;</code></li><li>正例：<code>SELECT * FROM t WHERE age &lt;= 49;</code>（等价逻辑，索引效率更高）</li><li>理由：数据库索引对闭区间查询的优化更友好</li></ul><h3 id="17-使用完全限定列名（含表别名）"><a href="#17-使用完全限定列名（含表别名）" class="headerlink" title="17. 使用完全限定列名（含表别名）"></a>17. 使用完全限定列名（含表别名）</h3><ul><li>反例：<code>SELECT stuName, stuAge, schoolName FROM student a LEFT JOIN school b ON a.schoolId = b.id;</code>（可能字段歧义）</li><li>正例：<code>SELECT a.stuName, a.stuAge, b.schoolName FROM student a LEFT JOIN school b ON a.schoolId = b.id;</code></li><li>理由：明确字段归属表，避免多表连接时字段名冲突，提升查询解析效率</li></ul><h3 id="18-多表连接时，小表在前，大表在后"><a href="#18-多表连接时，小表在前，大表在后" class="headerlink" title="18. 多表连接时，小表在前，大表在后"></a>18. 多表连接时，小表在前，大表在后</h3><ul><li>反例：<code>SELECT ename, dname FROM dept a JOIN emp b ON a.deptno = b.deptno;</code>（dept 小表、emp 大表，顺序不合理）</li><li>正例：<code>SELECT ename, dname FROM emp a JOIN dept b ON a.deptno = b.deptno;</code>（大表在前，小表在后）</li><li>理由：MySQL 执行多表连接时，会先加载前表数据，小表在前可减少后续大表的匹配次数</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 安装与维护核心笔记</title>
      <link href="/posts/53992.html"/>
      <url>/posts/53992.html</url>
      
        <content type="html"><![CDATA[<p>本文档整理了 MySQL 数据库的删除、服务管理、常用命令及数据备份恢复操作，适用于日常基础运维参考。</p><h2 id="一、MySQL-数据库删除"><a href="#一、MySQL-数据库删除" class="headerlink" title="一、MySQL 数据库删除"></a>一、MySQL 数据库删除</h2><ol><li>先通过命令停止 MySQL 服务，避免文件占用。</li><li>进入系统 “控制面板 - 程序和功能”，找到 MySQL 相关程序并卸载。</li><li>删除 MySQL 安装目录下的残留文件（如默认路径 <code>C:\Program Files\MySQL</code>）。</li><li>清除注册表残留（可选，新手谨慎操作），通过 <code>regedit</code> 打开注册表，删除 <code>HKEY_LOCAL_MACHINE\SOFTWARE\MySQL</code> 等相关键值。</li></ol><h2 id="二、MySQL-服务管理"><a href="#二、MySQL-服务管理" class="headerlink" title="二、MySQL 服务管理"></a>二、MySQL 服务管理</h2><p>通过命令行或系统工具可快速查看、启动、关闭 MySQL 服务，具体操作如下：</p><table><thead><tr><th>操作目的</th><th>执行方式</th><th>具体命令 &#x2F; 步骤</th></tr></thead><tbody><tr><td>查看服务列表</td><td>运行对话框</td><td>按下 <code>Win+R</code>，输入 <code>services.msc</code> 回车，在列表中找到 MySQL 服务</td></tr><tr><td>启动服务</td><td>命令提示符（管理员）</td><td>输入 <code>net start mysql</code> 回车</td></tr><tr><td>关闭服务</td><td>命令提示符（管理员）</td><td>输入 <code>net stop mysql</code> 回车</td></tr></tbody></table><h2 id="三、MySQL-常用核心命令"><a href="#三、MySQL-常用核心命令" class="headerlink" title="三、MySQL 常用核心命令"></a>三、MySQL 常用核心命令</h2><p>所有命令需在 MySQL 命令行环境中执行，先通过登录命令进入交互模式。</p><h3 id="1-登录与退出"><a href="#1-登录与退出" class="headerlink" title="1. 登录与退出"></a>1. 登录与退出</h3><ul><li>登录：打开命令提示符，输入 <code>mysql -uroot -proot</code> 回车（第一个 <code>root</code> 是用户名，第二个 <code>root</code> 是密码，需根据实际情况替换）。</li><li>退出：在 MySQL 交互模式（显示 <code>mysql&gt;</code>）下，输入 <code>exit</code> 回车。</li></ul><h3 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h3><table><thead><tr><th>操作需求</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>查看所有数据库</td><td><code>show databases;</code></td><td>结尾需加英文分号，列出当前 MySQL 中所有库</td></tr><tr><td>选择指定数据库</td><td><code>use test;</code></td><td>将当前操作的数据库切换为 <code>test</code>（<code>test</code> 需替换为实际库名）</td></tr><tr><td>查看当前所在数据库</td><td><code>select database();</code></td><td>确认当前正在操作的数据库</td></tr><tr><td>创建数据库</td><td><code>create database oa;</code></td><td>创建名为 <code>oa</code> 的数据库</td></tr><tr><td>删除数据库</td><td><code>drop database oa;</code></td><td>永久删除 <code>oa</code> 数据库，操作前需确认数据备份</td></tr></tbody></table><h3 id="3-数据表操作"><a href="#3-数据表操作" class="headerlink" title="3. 数据表操作"></a>3. 数据表操作</h3><table><thead><tr><th>操作需求</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>查看当前库所有表</td><td><code>show tables;</code></td><td>需先通过 <code>use 库名</code> 选定数据库</td></tr><tr><td>创建数据表</td><td><code>create table t_emp(id int, empName varchar(20));</code></td><td>在当前库中创建 <code>t_emp</code> 表，包含 <code>id</code>（整数）和 <code>empName</code>（20 位字符串）字段</td></tr><tr><td>删除数据表</td><td><code>drop table t_emp;</code></td><td>永久删除 <code>t_emp</code> 表，操作前需确认数据备份</td></tr></tbody></table><h2 id="四、数据备份与恢复"><a href="#四、数据备份与恢复" class="headerlink" title="四、数据备份与恢复"></a>四、数据备份与恢复</h2><p>通过 <code>mysqldump</code> 工具实现备份，通过 <code>source</code> 命令实现恢复，操作需在命令提示符（非 MySQL 交互模式）中执行。</p><h3 id="1-数据备份（导出）"><a href="#1-数据备份（导出）" class="headerlink" title="1. 数据备份（导出）"></a>1. 数据备份（导出）</h3><table><thead><tr><th>备份范围</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>单个数据库</td><td><code>mysqldump -uroot -proot oa &gt; c:/oa_backup.sql</code></td><td>将 <code>oa</code> 库备份到 <code>C</code> 盘根目录，文件名为 <code>oa_backup.sql</code></td></tr><tr><td>所有数据库</td><td><code>mysqldump -uroot -proot --all-databases &gt; c:/oa_all_backup.sql</code></td><td>备份 MySQL 中所有库到 <code>C</code> 盘 <code>oa_all_backup.sql</code> 文件</td></tr><tr><td>单个数据表</td><td><code>mysqldump -uroot -proot oa emp &gt; c:/oa_emp.sql</code></td><td>将 <code>oa</code> 库中的 <code>emp</code> 表备份到 <code>C</code> 盘 <code>oa_emp.sql</code> 文件</td></tr></tbody></table><h3 id="2-数据恢复（导入）"><a href="#2-数据恢复（导入）" class="headerlink" title="2. 数据恢复（导入）"></a>2. 数据恢复（导入）</h3><ol><li>先通过 <code>mysql -uroot -proot</code> 登录 MySQL。</li><li>若恢复单个数据库，需先创建并选择该库：<code>create database oa;</code> → <code>use oa;</code>。</li><li>执行恢复命令：<code>source c:/oa_backup.sql;</code>（路径需与备份文件一致，结尾加英文分号）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发核心笔记：自定义 MyAtomicInteger 与 CAS 机制详解</title>
      <link href="/posts/33380.html"/>
      <url>/posts/33380.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、核心目标"><a href="#一、核心目标" class="headerlink" title="一、核心目标"></a>一、核心目标</h2><p>本文围绕自定义 <code>MyAtomicInteger</code> 类展开，拆解其底层实现逻辑，掌握 <strong>CAS 无锁编程思想</strong>、<code>volatile</code> 可见性保障、<code>Unsafe</code> 类的核心作用，理解 Java 原子类（如 <code>AtomicInteger</code>）的底层原理，解决多线程下变量自增的线程安全问题。</p><h2 id="二、自定义-MyAtomicInteger-完整代码（无修改）"><a href="#二、自定义-MyAtomicInteger-完整代码（无修改）" class="headerlink" title="二、自定义 MyAtomicInteger 完整代码（无修改）"></a>二、自定义 MyAtomicInteger 完整代码（无修改）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAtomicInteger</span> &#123;</span><br><span class="line">    <span class="comment">// 核心依赖：Unsafe类（直接操作内存、执行CAS原子指令）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// value变量在对象中的内存偏移地址（Unsafe操作内存需要此地址）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心变量：用volatile修饰，保证多线程可见性、禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块：初始化valueOffset（类加载时执行，仅一次）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 通过反射获取value字段</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 获取value字段在MyAtomicInteger对象中的内存偏移地址</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(valueField);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程安全的自增操作（返回自增后的值）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋锁：CAS失败则不断重试，直到成功（无锁核心）</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get(); <span class="comment">// 获取当前value最新值（volatile保证可见性）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>; <span class="comment">// 计算自增后的新值</span></span><br><span class="line">            <span class="comment">// 执行CAS对比交换：成功则返回新值，失败则重新自旋</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;自旋等待中。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前value值（volatile保证每次读取都是内存最新值）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS核心方法：对比并交换（原子操作）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Unsafe的原生CAS方法：this=当前对象，valueOffset=内存偏移，expect=预期值，update=新值</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反射获取Unsafe实例（Unsafe默认禁止外部直接访问）</span></span><br><span class="line">    <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取Unsafe类的静态私有属性&quot;theUnsafe&quot;</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 突破访问权限限制（private→可访问）</span></span><br><span class="line">            theUnsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 3. 静态属性无需传入对象，传null即可获取实例</span></span><br><span class="line">            <span class="keyword">return</span> (Unsafe) theUnsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、核心组件拆解（每部分的作用与意义）"><a href="#三、核心组件拆解（每部分的作用与意义）" class="headerlink" title="三、核心组件拆解（每部分的作用与意义）"></a>三、核心组件拆解（每部分的作用与意义）</h2><h3 id="1-Unsafe-类：Java-底层-“魔法工具类”"><a href="#1-Unsafe-类：Java-底层-“魔法工具类”" class="headerlink" title="1. Unsafe 类：Java 底层 “魔法工具类”"></a>1. Unsafe 类：Java 底层 “魔法工具类”</h3><ul><li><strong>定位</strong>：Java 提供的底层操作工具类，直接操作内存、执行 CPU 原子指令，是实现无锁编程的核心依赖。</li><li><strong>特点</strong>：<ul><li>构造方法私有，仅允许 JDK 内部类访问，外部需通过反射获取实例；</li><li>功能强大但风险高（直接操作内存可能导致程序崩溃），官方不推荐普通开发直接使用。</li></ul></li><li><strong>核心用法（本类中）</strong>：<ul><li><code>objectFieldOffset(Field field)</code>：获取字段在对象中的内存偏移地址；</li><li><code>compareAndSwapInt(Object obj, long offset, int expect, int update)</code>：执行 CAS 原子操作，对比 obj 对象 offset 地址的值是否为 expect，是则更新为 update，返回 true；否则返回 false。</li></ul></li></ul><h3 id="2-valueOffset：内存偏移地址"><a href="#2-valueOffset：内存偏移地址" class="headerlink" title="2. valueOffset：内存偏移地址"></a>2. valueOffset：内存偏移地址</h3><ul><li><strong>作用</strong>：<code>value</code> 变量在 <code>MyAtomicInteger</code> 对象中的内存地址偏移量。</li><li><strong>为什么需要</strong>：Unsafe 操作内存时，需要通过 “对象实例 + 内存偏移” 精准定位到 <code>value</code> 变量的内存位置，才能直接读写该变量的值。</li><li><strong>初始化时机</strong>：静态代码块中初始化（类加载时执行一次），避免每次 CAS 操作都计算偏移地址，提升效率。</li></ul><h3 id="3-volatile-修饰的-value-变量"><a href="#3-volatile-修饰的-value-变量" class="headerlink" title="3. volatile 修饰的 value 变量"></a>3. volatile 修饰的 value 变量</h3><ul><li><strong>核心作用</strong>：保证 <code>value</code> 的 <strong>可见性</strong> 和 <strong>禁止指令重排</strong>：<ul><li>可见性：一个线程修改 <code>value</code> 后，其他线程能立刻读取到内存中的最新值（避免读取到本地缓存的旧值）；</li><li>禁止指令重排：确保 <code>value</code> 的读写操作按代码顺序执行，不会被 JVM 优化打乱。</li></ul></li><li><strong>注意</strong>：volatile 仅保证可见性，不保证原子性（如 <code>value++</code> 仍非线程安全），需配合 CAS 才能实现原子更新。</li></ul><h3 id="4-自旋锁-CAS：无锁编程的核心逻辑"><a href="#4-自旋锁-CAS：无锁编程的核心逻辑" class="headerlink" title="4. 自旋锁 + CAS：无锁编程的核心逻辑"></a>4. 自旋锁 + CAS：无锁编程的核心逻辑</h3><h4 id="（1）自旋锁：for-死循环"><a href="#（1）自旋锁：for-死循环" class="headerlink" title="（1）自旋锁：for(;;) 死循环"></a>（1）自旋锁：<code>for(;;)</code> 死循环</h4><ul><li><strong>作用</strong>：CAS 操作失败时，线程不阻塞（避免锁竞争的上下文切换开销），而是重新读取最新值重试，直到成功。</li><li><strong>优势</strong>：低开销（无阻塞 &#x2F; 唤醒的上下文切换），高并发场景下吞吐量比 <code>synchronized</code> 锁更高。</li><li><strong>缺点</strong>：竞争激烈时，失败线程会不断自旋，消耗 CPU 资源（可通过限制重试次数优化）。</li></ul><h4 id="（2）CAS-机制：Compare-and-Swap（比较并交换）"><a href="#（2）CAS-机制：Compare-and-Swap（比较并交换）" class="headerlink" title="（2）CAS 机制：Compare and Swap（比较并交换）"></a>（2）CAS 机制：Compare and Swap（比较并交换）</h4><ul><li><strong>定义</strong>：一种 CPU 原子指令支持的无锁同步机制，核心是 “先对比，再更新”，保证操作的原子性（不可打断）。</li><li><strong>核心参数</strong>（3 个）：<ul><li>内存地址 V（<code>valueOffset</code> 对应的内存位置）；</li><li>预期值 A（线程读取到的 <code>value</code> 快照，如 <code>current</code>）；</li><li>新值 B（线程想要更新的值，如 <code>next</code>）。</li></ul></li><li><strong>执行逻辑</strong>（原子性）：<ol><li>对比内存地址 V 中的实际值与预期值 A；</li><li>若相等：说明变量未被其他线程修改，将内存值更新为 B，返回 true；</li><li>若不相等：说明变量已被修改，放弃更新，返回 false。</li></ol></li></ul><h3 id="5-反射获取-Unsafe：突破访问限制"><a href="#5-反射获取-Unsafe：突破访问限制" class="headerlink" title="5. 反射获取 Unsafe：突破访问限制"></a>5. 反射获取 Unsafe：突破访问限制</h3><ul><li><strong>原因</strong>：Unsafe 类的 <code>theUnsafe</code> 属性是静态私有（<code>private static final Unsafe theUnsafe</code>），外部无法直接访问。</li><li><strong>步骤</strong>：<ol><li>通过 <code>Class.getDeclaredField()</code> 获取该属性；</li><li>调用 <code>setAccessible(true)</code> 突破私有访问限制；</li><li>静态属性通过 <code>field.get(null)</code> 获取实例（无需传入对象）。</li></ol></li></ul><h2 id="四、核心流程：多线程下-incrementAndGet-如何保证线程安全？"><a href="#四、核心流程：多线程下-incrementAndGet-如何保证线程安全？" class="headerlink" title="四、核心流程：多线程下 incrementAndGet () 如何保证线程安全？"></a>四、核心流程：多线程下 incrementAndGet () 如何保证线程安全？</h2><p>以两个线程同时调用 <code>incrementAndGet()</code> 为例，流程如下：</p><ol><li>线程 1、线程 2 同时调用 <code>get()</code>，通过 volatile 可见性获取到 <code>value = 0</code>（当前最新值）；</li><li>两者均计算新值 <code>next = 1</code>；</li><li>线程 1 先执行 <code>compareAndSet(0, 1)</code>：<ul><li>Unsafe 定位到 <code>value</code> 的内存地址，对比实际值（0）与预期值（0）相等；</li><li>原子更新内存值为 1，返回 true，线程 1 直接返回 1；</li></ul></li><li>线程 2 执行 <code>compareAndSet(0, 1)</code>：<ul><li>对比内存实际值（1）与预期值（0）不相等，返回 false；</li><li>线程 2 进入自旋，重新调用 <code>get()</code> 获取最新值（1），计算新值（2）；</li><li>再次执行 CAS 操作，对比 1 与内存值（1）相等，更新为 2，返回 true 并返回 2；</li></ul></li><li>最终 <code>value</code> 正确自增，无线程安全问题（不会出现值覆盖）。</li></ol><h2 id="五、关键知识点：为什么这样设计能保证线程安全？"><a href="#五、关键知识点：为什么这样设计能保证线程安全？" class="headerlink" title="五、关键知识点：为什么这样设计能保证线程安全？"></a>五、关键知识点：为什么这样设计能保证线程安全？</h2><h3 id="1-原子性保障：CAS-指令-硬件支持"><a href="#1-原子性保障：CAS-指令-硬件支持" class="headerlink" title="1. 原子性保障：CAS 指令 + 硬件支持"></a>1. 原子性保障：CAS 指令 + 硬件支持</h3><p>CAS 操作由 CPU 底层原子指令（如 x86 的 <code>cmpxchg</code>）实现：</p><ul><li>单核 CPU：一条指令完成 “对比 + 交换”，天然原子性；</li><li>多核 CPU：通过总线锁定（Lock 前缀指令）阻止其他核心同时操作该内存地址，确保原子性。</li></ul><h3 id="2-可见性保障：volatile-修饰"><a href="#2-可见性保障：volatile-修饰" class="headerlink" title="2. 可见性保障：volatile 修饰"></a>2. 可见性保障：volatile 修饰</h3><ul><li>线程修改 <code>value</code> 后，会立刻将值刷新到主内存；</li><li>其他线程读取 <code>value</code> 时，会跳过本地缓存，直接从主内存读取最新值。</li></ul><h3 id="3-无锁设计：避免锁竞争开销"><a href="#3-无锁设计：避免锁竞争开销" class="headerlink" title="3. 无锁设计：避免锁竞争开销"></a>3. 无锁设计：避免锁竞争开销</h3><ul><li>相比 <code>synchronized</code> 等互斥锁，CAS 无需创建锁、释放锁，也避免了线程阻塞 &#x2F; 唤醒的上下文切换（重量级操作）；</li><li>竞争失败的线程仅自旋重试，开销远低于锁竞争。</li></ul><h2 id="六、使用场景与实战示例"><a href="#六、使用场景与实战示例" class="headerlink" title="六、使用场景与实战示例"></a>六、使用场景与实战示例</h2><h3 id="1-适用场景"><a href="#1-适用场景" class="headerlink" title="1. 适用场景"></a>1. 适用场景</h3><ul><li>多线程下的计数器、累加器（如接口访问次数统计、任务执行进度计数）；</li><li>低 - 中并发场景的变量原子更新（高并发下自旋消耗 CPU，可改用 <code>ReentrantLock</code>）。</li></ul><h3 id="2-实战验证（线程安全测试）"><a href="#2-实战验证（线程安全测试）" class="headerlink" title="2. 实战验证（线程安全测试）"></a>2. 实战验证（线程安全测试）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAtomicIntegerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyAtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomicInteger</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 3个线程</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[threadNum];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个线程执行1000次自增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终计数：&quot;</span> + count.get()); <span class="comment">// 必然输出 3000（无线程安全问题）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、常见问题与注意事项"><a href="#七、常见问题与注意事项" class="headerlink" title="七、常见问题与注意事项"></a>七、常见问题与注意事项</h2><h3 id="1-CAS-的-ABA-问题"><a href="#1-CAS-的-ABA-问题" class="headerlink" title="1. CAS 的 ABA 问题"></a>1. CAS 的 ABA 问题</h3><ul><li><strong>定义</strong>：线程 1 读取值为 A，准备更新为 B；线程 2 先将 A 改为 C，再改回 A；线程 1 执行 CAS 时，发现值仍为 A，误以为未被修改，成功更新，导致潜在逻辑错误。</li><li><strong>解决方案</strong>：给变量加版本号 &#x2F; 时间戳（如 Java 官方的 <code>AtomicStampedReference</code> 类），CAS 同时对比 “值 + 版本号”。</li></ul><h3 id="2-自旋消耗-CPU"><a href="#2-自旋消耗-CPU" class="headerlink" title="2. 自旋消耗 CPU"></a>2. 自旋消耗 CPU</h3><ul><li><strong>问题</strong>：高并发下，大量线程竞争同一个变量，会导致失败线程不断自旋，占用 CPU 资源（可能导致 CPU 使用率飙升）。</li><li><strong>优化方向</strong>：限制自旋次数（如重试 3 次后改用锁）、使用自适应自旋（根据历史重试情况动态调整次数）。</li></ul><h3 id="3-只能原子更新单个变量"><a href="#3-只能原子更新单个变量" class="headerlink" title="3. 只能原子更新单个变量"></a>3. 只能原子更新单个变量</h3><ul><li><strong>问题</strong>：CAS 仅能原子更新一个变量，无法直接原子更新多个变量。</li><li><strong>解决方案</strong>：将多个变量封装为对象（如用 <code>AtomicReference</code> 包装自定义对象），通过更新对象的原子性间接实现多变量原子更新。</li></ul><h2 id="八、学习建议：是否需要掌握？（分场景）"><a href="#八、学习建议：是否需要掌握？（分场景）" class="headerlink" title="八、学习建议：是否需要掌握？（分场景）"></a>八、学习建议：是否需要掌握？（分场景）</h2><h3 id="1-初学者-初级开发"><a href="#1-初学者-初级开发" class="headerlink" title="1. 初学者 &#x2F; 初级开发"></a>1. 初学者 &#x2F; 初级开发</h3><ul><li><strong>目标</strong>：无需死记代码实现，重点理解核心思想：<ul><li>知道 <code>MyAtomicInteger</code> 是解决 “多线程自增线程安全” 的；</li><li>记住关键技术：CAS、volatile、Unsafe（知道它们各自的作用）；</li><li>会使用官方 <code>AtomicInteger</code>（调用 <code>incrementAndGet()</code> 等方法）即可。</li></ul></li></ul><h3 id="2-中级开发-准备面试"><a href="#2-中级开发-准备面试" class="headerlink" title="2. 中级开发 &#x2F; 准备面试"></a>2. 中级开发 &#x2F; 准备面试</h3><ul><li><strong>目标</strong>：能讲清完整原理，最好能手写简化版：<ul><li>能解释 “为什么加 volatile”“valueOffset 的作用”“自旋的目的”；</li><li>能讲清 CAS 机制的原子性保障；</li><li>这是 Java 并发的高频面试题，掌握后能体现底层思维。</li></ul></li></ul><h3 id="3-高级开发-底层框架开发"><a href="#3-高级开发-底层框架开发" class="headerlink" title="3. 高级开发 &#x2F; 底层框架开发"></a>3. 高级开发 &#x2F; 底层框架开发</h3><ul><li><strong>目标</strong>：掌握细节与扩展：<ul><li>理解 Unsafe 的其他用法（如内存分配、线程挂起 &#x2F; 唤醒）；</li><li>能解决 CAS 的 ABA 问题、自旋优化等进阶场景；</li><li>可基于 Unsafe 扩展自定义并发工具（如分布式锁、原子类）。</li></ul></li></ul><h2 id="九、核心总结"><a href="#九、核心总结" class="headerlink" title="九、核心总结"></a>九、核心总结</h2><ol><li>自定义 <code>MyAtomicInteger</code> 是 CAS 机制的经典实践，完美复刻了官方 <code>AtomicInteger</code> 的核心原理；</li><li>核心设计：<code>Unsafe</code> 实现底层原子操作 + <code>volatile</code> 保证可见性 + 自旋锁 + CAS 对比交换；</li><li>优势：无锁、高效、线程安全，避免了锁竞争的上下文切换开销；</li><li>学习重点：理解 “原理” 比死记代码更重要，掌握 CAS、volatile、Unsafe 的核心作用，能应对日常并发场景和面试。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unsafe 类核心功能笔记</title>
      <link href="/posts/39243.html"/>
      <url>/posts/39243.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Unsafe-类概述"><a href="#一、Unsafe-类概述" class="headerlink" title="一、Unsafe 类概述"></a>一、Unsafe 类概述</h2><ul><li><strong>定位</strong>：Java 底层 “后门级” 工具类，绕开 JVM 安全限制，直接操作内存、线程等底层资源。</li><li><strong>风险</strong>：操作不当会导致 JVM 崩溃、内存泄漏，官方仅允许 JDK 内部类库使用，普通开发需谨慎。</li><li><strong>获取方式</strong>：通过反射破解访问限制（因 <code>Unsafe.getUnsafe()</code> 有安全校验，普通类调用会抛 <code>SecurityException</code>）。</li></ul><h2 id="二、6-大核心功能与示例"><a href="#二、6-大核心功能与示例" class="headerlink" title="二、6 大核心功能与示例"></a>二、6 大核心功能与示例</h2><h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h3><ul><li><strong>能力</strong>：像 C 指针一样直接分配、释放、操作内存，支持堆外内存（不受 JVM 垃圾回收管理）。</li><li><strong>核心方法</strong>：<code>allocateMemory</code>（分配内存）、<code>freeMemory</code>（释放内存）、<code>copyMemory</code>（内存拷贝）、<code>putInt</code>&#x2F;<code>getInt</code>（读写内存值）。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"><span class="type">long</span> <span class="variable">addr</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">1024</span>); <span class="comment">// 分配 1024 字节内存</span></span><br><span class="line">unsafe.putInt(addr, <span class="number">666</span>); <span class="comment">// 写 int 值到内存地址</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> unsafe.getInt(addr); <span class="comment">// 从内存地址读 int 值</span></span><br><span class="line">unsafe.freeMemory(addr); <span class="comment">// 释放内存，避免泄漏</span></span><br></pre></td></tr></table></figure><h3 id="2-非常规对象实例化"><a href="#2-非常规对象实例化" class="headerlink" title="2. 非常规对象实例化"></a>2. 非常规对象实例化</h3><ul><li><strong>能力</strong>：直接创建对象实例，且不执行构造方法和初始化逻辑（可绕过私有构造、<code>final</code> 限制）。</li><li><strong>核心方法</strong>：<code>allocateInstance</code>。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">()</span> &#123; <span class="comment">// 私有构造，普通方式无法创建</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) unsafe.allocateInstance(User.class); <span class="comment">// 不执行构造方法</span></span><br></pre></td></tr></table></figure><h3 id="3-操作对象的属性"><a href="#3-操作对象的属性" class="headerlink" title="3. 操作对象的属性"></a>3. 操作对象的属性</h3><ul><li><strong>能力</strong>：直接修改对象的私有属性（包括 <code>final</code> 字段），打破 Java 封装性。</li><li><strong>核心方法</strong>：<code>objectFieldOffset</code>（获取字段内存偏移量）、<code>putObject</code>&#x2F;<code>getObject</code>（读写字段值）。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;初始值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">unsafe.putObject(p, offset, <span class="string">&quot;修改后的值&quot;</span>); <span class="comment">// 直接修改私有字段</span></span><br></pre></td></tr></table></figure><h3 id="4-操作数据元素"><a href="#4-操作数据元素" class="headerlink" title="4. 操作数据元素"></a>4. 操作数据元素</h3><ul><li><strong>能力</strong>：直接操作数组元素的内存地址，实现 “超大数组” 或优化数组访问性能。</li><li><strong>核心方法</strong>：<code>arrayBaseOffset</code>（数组第一个元素偏移量）、<code>arrayIndexScale</code>（数组元素内存增量）。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"><span class="type">long</span> <span class="variable">baseOffset</span> <span class="operator">=</span> unsafe.arrayBaseOffset(<span class="type">int</span>[].class); <span class="comment">// 数组首元素偏移量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">indexScale</span> <span class="operator">=</span> unsafe.arrayIndexScale(<span class="type">int</span>[].class); <span class="comment">// 元素内存增量（int 为 4 字节）</span></span><br><span class="line">unsafe.putInt(arr, baseOffset + indexScale * <span class="number">1</span>, <span class="number">999</span>); <span class="comment">// 给 arr[1] 赋值 999</span></span><br></pre></td></tr></table></figure><h3 id="5-多线程支持"><a href="#5-多线程支持" class="headerlink" title="5. 多线程支持"></a>5. 多线程支持</h3><ul><li><strong>能力</strong>：是 Java 并发包（<code>java.util.concurrent</code>）的底层支撑，提供 CAS 操作、线程挂起 &#x2F; 唤醒等能力。<ul><li><strong>CAS 操作</strong>：<code>compareAndSwapInt</code>&#x2F;<code>compareAndSwapObject</code>（原子比较并交换，<code>AtomicInteger</code> 底层实现）。<br>  示例（模拟 <code>AtomicInteger</code> 自增）：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAtomicInteger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        unsafe = getUnsafe();</span><br><span class="line">        offset = unsafe.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> current;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = unsafe.getIntVolatile(<span class="built_in">this</span>, offset);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!unsafe.compareAndSwapInt(<span class="built_in">this</span>, offset, current, current + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> current + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程挂起 &#x2F; 唤醒</strong>：<code>park</code>（挂起线程）、<code>unpark</code>（唤醒线程）（<code>LockSupport</code> 底层实现）。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    unsafe.park(); <span class="comment">// 挂起线程</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程被唤醒&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br><span class="line">unsafe.unpark(t); <span class="comment">// 唤醒线程</span></span><br></pre></td></tr></table></figure><h3 id="6-内存屏障"><a href="#6-内存屏障" class="headerlink" title="6. 内存屏障"></a>6. 内存屏障</h3><ul><li><strong>能力</strong>：阻止指令重排序，保证多线程下的内存可见性（类似 <code>volatile</code> 关键字底层实现）。</li><li><strong>核心方法</strong>：<code>loadFence</code>（读屏障）、<code>storeFence</code>（写屏障）、<code>fullFence</code>（全屏障）。</li><li><strong>示例</strong>（保证读可见性）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123; <span class="keyword">private</span> <span class="type">int</span> value; &#125;</span><br><span class="line"><span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 1 写数据</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    data.value = <span class="number">123</span>;</span><br><span class="line">    unsafe.storeFence(); <span class="comment">// 写屏障：保证写操作对其他线程可见</span></span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2 读数据</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    unsafe.loadFence(); <span class="comment">// 读屏障：保证从主内存读最新值</span></span><br><span class="line">    System.out.println(data.value); <span class="comment">// 输出 123</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="三、使用建议"><a href="#三、使用建议" class="headerlink" title="三、使用建议"></a>三、使用建议</h2><ul><li><strong>适用场景</strong>：仅用于 JDK 内部类库、高性能框架（如 Netty、Hadoop）的底层开发。</li><li><strong>替代方案</strong>：普通开发优先使用 Java 标准库的安全封装（如 <code>AtomicInteger</code>、<code>LockSupport</code>、<code>volatile</code>）。</li><li><strong>兼容性</strong>：<code>sun.misc.Unsafe</code> 是非标准 API，JDK 9+ 可能迁移到 <code>jdk.internal.misc.Unsafe</code>，需注意版本差异。</li></ul><p><strong>附：Unsafe 实例获取工具方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日期处理 @JsonFormat</title>
      <link href="/posts/37268.html"/>
      <url>/posts/37268.html</url>
      
        <content type="html"><![CDATA[<h1 id="JsonFormat-注解：日期格式化核心用法笔记"><a href="#JsonFormat-注解：日期格式化核心用法笔记" class="headerlink" title="@JsonFormat 注解：日期格式化核心用法笔记"></a>@JsonFormat 注解：日期格式化核心用法笔记</h1><p><code>@JsonFormat</code> 是 Jackson 框架提供的注解，用于统一控制 <strong>日期类型（如 Date）的序列化与反序列化格式</strong>，解决前后端日期数据交互的格式不一致问题。</p><h2 id="一、核心作用"><a href="#一、核心作用" class="headerlink" title="一、核心作用"></a>一、核心作用</h2><ul><li><strong>序列化</strong>：将后端的 <code>Date</code> 对象，转换为指定格式的字符串（如 <code>2025-10-29 16:00:00</code>）返回给前端，替代默认的 ISO 格式（如 <code>2025-10-29T16:00:00.000+00:00</code>）。</li><li><strong>反序列化</strong>：将前端提交的指定格式日期字符串（如 <code>2025-10-29 16:00:00</code>），转换为后端的 <code>Date</code> 对象，确保格式匹配可正常解析。</li></ul><h2 id="二、关键属性与配置示例"><a href="#二、关键属性与配置示例" class="headerlink" title="二、关键属性与配置示例"></a>二、关键属性与配置示例</h2><h3 id="1-常用属性"><a href="#1-常用属性" class="headerlink" title="1. 常用属性"></a>1. 常用属性</h3><table><thead><tr><th>属性名</th><th>作用说明</th></tr></thead><tbody><tr><td><code>pattern</code></td><td>必选，指定日期格式字符串，如 <code>yyyy-MM-dd</code>（日期）、<code>yyyy-MM-dd HH:mm:ss</code>（日期 + 时间）。</td></tr><tr><td><code>timezone</code></td><td>必选，指定时区，避免时区偏移导致日期偏差，国内统一使用 <code>GMT+8</code>（东八区）。</td></tr></tbody></table><h3 id="2-实际使用示例"><a href="#2-实际使用示例" class="headerlink" title="2. 实际使用示例"></a>2. 实际使用示例</h3><p>在实体类的 <code>Date</code> 类型字段上直接标注，实现全局统一格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 日期字段标注 @JsonFormat，统一序列化/反序列化格式</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birth; <span class="comment">// 出生日期</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他字段、getter/setter 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ol><li><strong>依赖前提</strong>：<code>@JsonFormat</code> 依赖 Jackson 相关包，Spring Boot 项目引入 <code>spring-boot-starter-web</code> 时会自动包含（无需额外导包）。</li><li><strong>格式一致性</strong>：前端提交的日期字符串格式，必须与 <code>pattern</code> 定义的格式完全匹配（如 <code>2025-10-29 16:00:00</code> 不能写成 <code>2025/10/29 16:00:00</code>），否则会反序列化失败。</li><li><strong>全局配置补充</strong>：若需对所有日期字段统一格式（无需逐个标注），可在 <code>application.yml</code> 中配置全局规则，优先级低于字段上的 <code>@JsonFormat</code> 注解：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span>  <span class="comment"># 全局日期格式</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span>                  <span class="comment"># 全局时区</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 数据转换 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口文档 Knife4j ( Swagger )</title>
      <link href="/posts/20702.html"/>
      <url>/posts/20702.html</url>
      
        <content type="html"><![CDATA[<p>Knife4j 底层基于 <strong>Swagger</strong> 实现，是对 Swagger 的增强封装，主要用于生成符合中国开发者习惯的接口文档。其核心依赖和实现逻辑如下：</p><p>Knife4j 使用，参考：<a href="https://doc.xiaominfo.com/docs/quick-start">https://doc.xiaominfo.com/docs/quick-start</a></p><p>访问 <a href="http://ip:port/doc.html">http://ip:port/doc.html</a> 即可查看 <strong>Knife4j</strong> 接口文档<br>访问 <a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a> 即可查看 <strong>Swagger</strong> 接口文档</p><hr><p>swagger标准常用注解；</p><table><thead><tr><th>注解</th><th>标注位置</th><th>作用</th></tr></thead><tbody><tr><td>@Tag</td><td>controller 类</td><td>描述 controller 作用</td></tr><tr><td>@Parameter</td><td>参数</td><td>标识参数作用</td></tr><tr><td>@Parameters</td><td>参数</td><td>参数多重说明</td></tr><tr><td>@Schema</td><td>model 层的 JavaBean</td><td>描述模型作用及每个属性</td></tr><tr><td>@Operation</td><td>方法</td><td>描述方法作用</td></tr><tr><td>@ApiResponse</td><td>方法</td><td>描述响应状态码等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 接口文档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口文档 与 全局异常处理冲突问题</title>
      <link href="/posts/27336.html"/>
      <url>/posts/27336.html</url>
      
        <content type="html"><![CDATA[<p> <strong>Knife4j（基于 Swagger）与<code>@RestControllerAdvice</code>（全局异常处理器）在版本兼容性或扫描逻辑上存在冲突</strong>，具体原因和解决方法如下：</p><h3 id="一、冲突原因"><a href="#一、冲突原因" class="headerlink" title="一、冲突原因"></a>一、冲突原因</h3><p>Knife4j 在生成接口文档时，会通过反射扫描项目中的<code>@ControllerAdvice</code>（或<code>@RestControllerAdvice</code>）类。如果你的项目中 Spring Boot 版本（尤其是 3.x 及以上）与 Knife4j 版本不兼容，就会触发<code>ControllerAdviceBean</code>构造方法不匹配、扫描逻辑冲突等问题，导致接口文档无法正常加载。</p><h3 id="二、解决方案（无需删除全局异常处理）"><a href="#二、解决方案（无需删除全局异常处理）" class="headerlink" title="二、解决方案（无需删除全局异常处理）"></a>二、解决方案（无需删除全局异常处理）</h3><p>推荐通过 <strong>“隐藏异常处理器类”</strong> 来规避扫描冲突，既保留全局异常处理功能，又能正常显示接口文档：</p><ol><li><strong>添加依赖</strong>：确保引入 Swagger 的<code>@Hidden</code>注解依赖（如果是 Knife4j+Spring Boot 3.x，通常已包含）：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.swagger.core.v3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在全局异常处理器类上添加<code>@Hidden</code>注解</strong>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.Hidden;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Hidden</span> <span class="comment">// 告诉Knife4j不要扫描这个类，避免冲突</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 原有异常处理方法保持不变...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、原理说明"><a href="#三、原理说明" class="headerlink" title="三、原理说明"></a>三、原理说明</h3><p><code>@Hidden</code>注解是 Swagger&#x2F;Knife4j 的原生注解，作用是<strong>让文档生成工具跳过对该类的扫描</strong>。这样既不会影响全局异常处理的正常运行（异常仍会被 Spring 捕获并处理），又能避免 Knife4j 因扫描冲突导致接口文档无法显示的问题。</p><p>通过这种方式，你可以同时保留<strong>全局异常处理的规范性</strong>和<strong>Knife4j 接口文档的可用性</strong>，无需删除或注释异常处理器代码。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 接口文档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类 “O”（对象）定义与核心职责总结</title>
      <link href="/posts/2385.html"/>
      <url>/posts/2385.html</url>
      
        <content type="html"><![CDATA[<p>各类 “O” 的设计核心是遵循<strong>单一职责原则</strong>，让不同对象专注于某一特定功能，避免职责混乱，提升代码可维护性。</p><h2 id="1-POJO（Plain-Ordinary-Java-Object）：普通-Java-类"><a href="#1-POJO（Plain-Ordinary-Java-Object）：普通-Java-类" class="headerlink" title="1. POJO（Plain Ordinary Java Object）：普通 Java 类"></a>1. POJO（Plain Ordinary Java Object）：普通 Java 类</h2><ul><li><strong>定义</strong>：最基础的 Java 类，无特定框架依赖，仅包含字段、getter&#x2F;setter、无参构造等基础结构。</li><li><strong>核心职责</strong>：纯粹的 “数据载体”，不包含业务逻辑、数据访问逻辑或传输相关处理。</li><li><strong>使用场景</strong>：作为所有 “O” 的基础形态，其他专用对象（如 VO、DTO）本质上都是 POJO 的细分。</li></ul><h2 id="2-DAO（Data-Access-Object）：数据访问对象"><a href="#2-DAO（Data-Access-Object）：数据访问对象" class="headerlink" title="2. DAO（Data Access Object）：数据访问对象"></a>2. DAO（Data Access Object）：数据访问对象</h2><ul><li><strong>定义</strong>：专门负责与数据库（或其他数据源）交互的对象。</li><li><strong>核心职责</strong>：封装数据访问逻辑，如执行 SQL 语句、调用 ORM 接口（MyBatis、JPA），提供 “增删改查” 操作方法。</li><li><strong>使用场景</strong>：隔离业务层与数据层，业务层通过调用 DAO 方法操作数据，无需关注具体数据库交互细节。</li></ul><h2 id="3-DTO（Data-Transfer-Object）：数据传输对象"><a href="#3-DTO（Data-Transfer-Object）：数据传输对象" class="headerlink" title="3. DTO（Data Transfer Object）：数据传输对象"></a>3. DTO（Data Transfer Object）：数据传输对象</h2><ul><li><strong>定义</strong>：专门用于跨层、跨服务传输数据的对象。</li><li><strong>核心职责</strong>：按需封装传输所需的数据，避免传输冗余字段，优化数据传输效率（如服务间调用、分布式系统通信）。</li><li><strong>使用场景</strong>：例如微服务 A 调用微服务 B 时，微服务 B 返回的 “用户基本信息 + 订单数量” 组合数据，用 DTO 封装后传输。</li></ul><h2 id="4-TO（Transfer-Object）：传输对象"><a href="#4-TO（Transfer-Object）：传输对象" class="headerlink" title="4. TO（Transfer Object）：传输对象"></a>4. TO（Transfer Object）：传输对象</h2><ul><li><strong>定义</strong>：与 DTO 功能高度类似，均为 “数据传输” 而生，部分场景下二者可视为同义。</li><li><strong>核心职责</strong>：专注于数据在不同模块 &#x2F; 系统间的传递，仅包含传输所需的字段和基础 getter&#x2F;setter。</li><li><strong>使用场景</strong>：较 DTO 更通用，无明确 “跨服务” 或 “跨层” 限制，只要是数据传输场景均可使用。</li></ul><h2 id="5-BO（Business-Object）：业务对象"><a href="#5-BO（Business-Object）：业务对象" class="headerlink" title="5. BO（Business Object）：业务对象"></a>5. BO（Business Object）：业务对象</h2><ul><li><strong>定义</strong>：专门封装业务数据和业务逻辑的对象。</li><li><strong>核心职责</strong>：承载业务相关数据（如 “订单业务” 中的订单状态、优惠规则数据），并包含对应的业务处理方法（如计算订单金额、判断订单是否可取消）。</li><li><strong>使用场景</strong>：业务层（Service）的核心对象，是业务逻辑的具体载体，例如 “OrderBO” 封装订单相关业务。</li></ul><h2 id="6-VO（View-Value-Object）：视图对象-值对象"><a href="#6-VO（View-Value-Object）：视图对象-值对象" class="headerlink" title="6. VO（View&#x2F;Value Object）：视图对象 &#x2F; 值对象"></a>6. VO（View&#x2F;Value Object）：视图对象 &#x2F; 值对象</h2><ul><li><strong>定义</strong>：分为 “视图对象” 和 “值对象” 两类，日常开发中 “视图对象” 更常用。</li><li><strong>核心职责</strong>：<ul><li>作为 “视图对象” 时：专门封装前端页面（或接口响应）所需的数据，按前端展示需求筛选字段（如隐藏敏感字段 “密码”）。</li><li>作为 “值对象” 时：封装不可变的数据（如 “金额”“地址”），无唯一标识（ID），仅通过属性值判断相等性。</li></ul></li><li><strong>使用场景</strong>：例如接口返回给前端的 “用户列表 VO”，仅包含 “用户名、手机号、头像” 等前端需展示的字段。</li></ul><h3 id="关键区分表"><a href="#关键区分表" class="headerlink" title="关键区分表"></a>关键区分表</h3><table><thead><tr><th>类型</th><th>核心职责</th><th>核心特点</th><th>典型使用层 &#x2F; 场景</th></tr></thead><tbody><tr><td>POJO</td><td>基础数据载体</td><td>无特定职责，最通用</td><td>所有层（作为基础）</td></tr><tr><td>DAO</td><td>数据访问（操作数据库）</td><td>封装 SQL&#x2F;ORM 操作</td><td>数据访问层（DAO 层）</td></tr><tr><td>DTO</td><td>跨层 &#x2F; 跨服务数据传输</td><td>按需筛选字段，优化传输</td><td>服务间调用、层间传递</td></tr><tr><td>TO</td><td>数据传输</td><td>与 DTO 类似，更通用</td><td>模块 &#x2F; 系统间数据传递</td></tr><tr><td>BO</td><td>封装业务数据与逻辑</td><td>包含业务方法，承载业务规则</td><td>业务逻辑层（Service 层）</td></tr><tr><td>VO</td><td>前端视图数据 &#x2F; 不可变值</td><td>按前端需求封装，可隐藏敏感字段</td><td>接口响应、前端页面展示</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 各类对象（O）的含义 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据校验 - JSR 303 校验注解</title>
      <link href="/posts/19838.html"/>
      <url>/posts/19838.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>校验注解</th><th>作用</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>验证Boolean类型字段是否为false</td></tr><tr><td>@AssertTrue</td><td>验证Boolean类型字段是否为true</td></tr><tr><td>@DecimalMax</td><td>验证字符串表示的数字是否小于等于指定的最大值</td></tr><tr><td>@DecimalMin</td><td>验证字符串表示的数字是否大于等于指定的最小值</td></tr><tr><td>@Digits(integer, fraction)</td><td>验证数值是否符合指定的格式，integer指定整数精度，fraction指定小数精度</td></tr><tr><td>@Email</td><td>验证字符串是否为邮箱地址格式</td></tr><tr><td>@Future</td><td>验证日期是否在当前时间之后</td></tr><tr><td>@Past</td><td>验证日期是否在当前时间之前</td></tr><tr><td>@Min(value)</td><td>验证数字是否大于等于指定的最小值</td></tr><tr><td>@Max(value)</td><td>验证数字是否小于等于指定的最大值</td></tr><tr><td>@Null</td><td>验证对象是否为null</td></tr><tr><td>@NotNull</td><td>验证对象是否不为null, 与@Null相反（a!&#x3D;null）</td></tr><tr><td>@NotEmpty</td><td>验证字符串是否非空（a!&#x3D;null &amp;&amp; a!&#x3D;“”）</td></tr><tr><td>@NotBlank</td><td>验证字符串是否非空白字符（a!&#x3D;null &amp;&amp; a.trim().length &gt; 0）</td></tr><tr><td>@Size(max&#x3D;, min&#x3D;)</td><td>验证字符串、集合、Map、数组的大小是否在指定范围内</td></tr><tr><td>@Pattern(regex&#x3D;, flag&#x3D;)</td><td>验证字符串是否符合指定的正则表达式</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 数据校验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JSR 303 数据校验框架及实践</title>
      <link href="/posts/56572.html"/>
      <url>/posts/56572.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、JSR-303-定义"><a href="#一、JSR-303-定义" class="headerlink" title="一、JSR 303 定义"></a><strong>一、JSR 303 定义</strong></h4><p>Java 为 Bean 数据合法性校验提供的标准框架，包含于 JavaEE 6.0 标准中。</p><ul><li>核心机制：通过在 Bean 属性上标注 <code>@NotNull</code>、<code>@Max</code> 等标准注解定义校验规则，通过标准接口完成校验。</li></ul><h4 id="二、数据校验使用流程"><a href="#二、数据校验使用流程" class="headerlink" title="二、数据校验使用流程"></a><strong>二、数据校验使用流程</strong></h4><ol><li><p><strong>引入依赖</strong>：</p><p> <code>spring-boot-starter-validation</code>（整合 JSR 303 实现，如 Hibernate Validator）。</p></li><li><p><strong>定义数据封装 Bean（VO）</strong>：</p><p> 通常为接收前端参数的实体类（如 <code>EmployeeAddVo</code>）。</p></li><li><p><strong>标注校验注解</strong>：</p><p> 在 Bean 字段上添加标准注解（如 <code>@NotBlank</code>、<code>@Email</code>）或自定义注解，指定错误提示消息。</p></li><li><p><strong>开启校验</strong>：</p><p> 在 Controller 方法参数上使用 <code>@Valid</code> 或 <code>@Validated</code> 触发校验。</p></li><li><p><strong>处理校验结果</strong>：</p><ul><li>方式 1：通过 <code>BindingResult</code> 手动获取校验错误（需紧跟被校验参数）。</li><li>方式 2：结合全局异常处理，统一捕获校验失败异常（推荐）。</li></ul></li><li><p><strong>自定义校验规则</strong>：</p><p> 通过 “自定义注解 + 校验器” 实现复杂校验（如性别只能为 “男” 或 “女”）。</p></li><li><p><strong>错误消息国际化</strong>：</p><p> 校验注解的 <code>message</code> 属性使用占位符（如 <code>&#123;gender.message&#125;</code>），结合 i18n 配置文件实现多语言提示。</p></li><li><p><strong>全局异常处理</strong>：</p><p> 捕获 <code>MethodArgumentNotValidException</code> 异常，统一封装并返回校验错误信息。</p></li></ol><h4 id="三、自定义校验实现（以性别校验为例）"><a href="#三、自定义校验实现（以性别校验为例）" class="headerlink" title="三、自定义校验实现（以性别校验为例）"></a><strong>三、自定义校验实现（以性别校验为例）</strong></h4><h5 id="1-定义自定义注解-Gender"><a href="#1-定义自定义注解-Gender" class="headerlink" title="1. 定义自定义注解 @Gender"></a>1. <strong>定义自定义注解 <code>@Gender</code></strong></h5><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.practice.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.practice.vaildator.GenderValidator;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;GenderValidator.class&#125;)</span> <span class="comment">// 关联具体校验器</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span> <span class="comment">// 作用于字段</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Gender &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;jakarta.validation.constraints.NotNull.message&#125;&quot;</span>; <span class="comment">// 错误提示（支持国际化）</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 分组校验（默认无分组）</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 附加信息（如严重级别）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-实现校验器-GenderValidator"><a href="#2-实现校验器-GenderValidator" class="headerlink" title="2. 实现校验器 GenderValidator"></a>2. <strong>实现校验器 <code>GenderValidator</code></strong></h5><p>需实现 <code>ConstraintValidator&lt;注解类型, 校验字段类型&gt;</code> 接口：</p><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.practice.vaildator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.practice.annotation.Gender;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.ConstraintValidatorContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenderValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;Gender, String&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验逻辑：判断值是否为&quot;男&quot;或&quot;女&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 前端传入的待校验值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 校验上下文（可修改提示信息等）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 校验通过返回true，否则false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;男&quot;</span>.equals(value) || <span class="string">&quot;女&quot;</span>.equals(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-在-VO-中使用自定义注解"><a href="#3-在-VO-中使用自定义注解" class="headerlink" title="3. 在 VO 中使用自定义注解"></a>3. <strong>在 VO 中使用自定义注解</strong></h5><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.practice.vo.req;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.practice.annotation.Gender;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.*;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeAddVo</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;姓名不能为空&quot;)</span> <span class="comment">// 非空校验（字符串不能为null或空串）</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span> <span class="comment">// 非null校验</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;年龄不能大于150岁&quot;)</span> <span class="comment">// 最大值限制</span></span><br><span class="line">    <span class="meta">@Min(value = 0, message = &quot;年龄不能小于0岁&quot;)</span> <span class="comment">// 最小值限制</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span> <span class="comment">// 邮箱格式校验</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Gender(message = &quot;&#123;gender.message&#125;&quot;)</span> <span class="comment">// 使用自定义注解，message关联国际化配置</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-Controller-中开启校验"><a href="#4-Controller-中开启校验" class="headerlink" title="4. Controller 中开启校验"></a>4. <strong>Controller 中开启校验</strong></h5><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="comment">// @Valid 触发对 EmployeeAddVo 的校验，校验失败会抛出异常</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> EmployeeAddVo vo)</span> &#123;</span><br><span class="line">    <span class="comment">// VO 转 DO（属性拷贝）</span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    BeanUtils.copyProperties(vo, employee);</span><br><span class="line">    </span><br><span class="line">    employeeService.addEmp(employee);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-全局异常处理校验错误"><a href="#5-全局异常处理校验错误" class="headerlink" title="5. 全局异常处理校验错误"></a>5. <strong>全局异常处理校验错误</strong></h5><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">    <span class="type">BindingResult</span> <span class="variable">result</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">    List&lt;FieldError&gt; fieldErrors = result.getFieldErrors();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 封装字段与错误信息的映射</span></span><br><span class="line">    Map&lt;String, String&gt; errorsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (FieldError error : fieldErrors) &#123;</span><br><span class="line">        errorsMap.put(error.getField(), error.getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> R.error(<span class="number">500</span>, <span class="string">&quot;参数不正确&quot;</span>, errorsMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心说明"><a href="#核心说明" class="headerlink" title="核心说明"></a><strong>核心说明</strong></h4><ul><li>标准注解（如 <code>@NotBlank</code>、<code>@Email</code>）适用于通用校验，自定义注解适用于业务特定规则。</li><li>全局异常处理替代手动处理 <code>BindingResult</code>，简化代码并统一响应格式。</li><li>国际化通过 <code>message</code> 占位符 + i18n 文件实现，支持多语言场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 数据校验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UDP 和 TCP 通信中发送与接收的核心代码片段</title>
      <link href="/posts/24347.html"/>
      <url>/posts/24347.html</url>
      
        <content type="html"><![CDATA[<p>可以用类似下面这种方式包装类</p><p>TCP服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);  </span><br><span class="line"><span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();  </span><br><span class="line">  </span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(accept.getInputStream())); <span class="comment">//获取客户端消息  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(accept.getOutputStream())); <span class="comment">//相应消息  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(accept.getOutputStream(),<span class="literal">true</span>); <span class="comment">//自动刷新缓冲区</span></span><br></pre></td></tr></table></figure><p>TCP客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLoopbackAddress(),<span class="number">9000</span>); <span class="comment">//确认发送地址  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream())); <span class="comment">//发送数据  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)); <span class="comment">//输入数据  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">brResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream())); <span class="comment">//读入返回数据</span></span><br></pre></td></tr></table></figure><h3 id="一、TCP-核心代码（面向连接、字节流）"><a href="#一、TCP-核心代码（面向连接、字节流）" class="headerlink" title="一、TCP 核心代码（面向连接、字节流）"></a>一、TCP 核心代码（面向连接、字节流）</h3><h4 id="1-服务端（接收与响应）"><a href="#1-服务端（接收与响应）" class="headerlink" title="1. 服务端（接收与响应）"></a>1. 服务端（接收与响应）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 监听端口（建立连接的入口）</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 阻塞等待客户端连接（三次握手）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取输入流（接收数据，需缓冲区）</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> clientSocket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] recvBuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 接收缓冲区（核心）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(recvBuf); <span class="comment">// 阻塞读数据，返回实际长度</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">recvData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(recvBuf, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到客户端：&quot;</span> + recvData);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 获取输出流（发送响应）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> clientSocket.getOutputStream();</span><br><span class="line">        out.write(<span class="string">&quot;服务端已收到&quot;</span>.getBytes()); <span class="comment">// 直接发送字节流</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 关闭资源</span></span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        clientSocket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-客户端（发送与接收）"><a href="#2-客户端（发送与接收）" class="headerlink" title="2. 客户端（发送与接收）"></a>2. 客户端（发送与接收）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 连接服务端（三次握手）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取输出流（发送数据）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        out.write(<span class="string">&quot;客户端发送数据&quot;</span>.getBytes()); <span class="comment">// 发送字节流</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取输入流（接收响应，需缓冲区）</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] recvBuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 接收缓冲区（核心）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(recvBuf);</span><br><span class="line">        <span class="type">String</span> <span class="variable">recvData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(recvBuf, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务端：&quot;</span> + recvData);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 关闭资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、UDP-核心代码（无连接、数据报）"><a href="#二、UDP-核心代码（无连接、数据报）" class="headerlink" title="二、UDP 核心代码（无连接、数据报）"></a>二、UDP 核心代码（无连接、数据报）</h3><h4 id="1-接收端（服务端角色）"><a href="#1-接收端（服务端角色）" class="headerlink" title="1. 接收端（服务端角色）"></a>1. 接收端（服务端角色）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket并绑定端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建接收缓冲区和数据报（核心）</span></span><br><span class="line">        <span class="type">byte</span>[] recvBuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 接收缓冲区</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">recvPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(recvBuf, recvBuf.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 阻塞接收数据（无连接，直接等数据报）</span></span><br><span class="line">        socket.receive(recvPacket); <span class="comment">// 数据存入recvPacket</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 解析数据（从缓冲区取实际长度）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> recvPacket.getLength(); <span class="comment">// 实际数据长度</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">recvData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(recvBuf, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到：&quot;</span> + recvData);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 关闭Socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-发送端（客户端角色）"><a href="#2-发送端（客户端角色）" class="headerlink" title="2. 发送端（客户端角色）"></a>2. 发送端（客户端角色）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket（无需连接）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 准备发送数据（打包成数据报）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sendData</span> <span class="operator">=</span> <span class="string">&quot;UDP发送的数据报&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] sendBuf = sendData.getBytes(); <span class="comment">// 发送数据转字节</span></span><br><span class="line">        <span class="comment">// 目标地址和端口（必须指定，无连接特性）</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">targetIp</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetPort</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="comment">// 封装数据报（含缓冲区、长度、目标地址）</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">sendPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(</span><br><span class="line">            sendBuf, sendBuf.length, targetIp, targetPort</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 发送数据报</span></span><br><span class="line">        socket.send(sendPacket);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 关闭Socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、核心代码对比关键点"><a href="#三、核心代码对比关键点" class="headerlink" title="三、核心代码对比关键点"></a>三、核心代码对比关键点</h3><table><thead><tr><th>场景</th><th>核心代码差异</th></tr></thead><tbody><tr><td><strong>TCP 连接</strong></td><td>服务端用<code>ServerSocket.accept()</code>阻塞等连接，客户端用<code>new Socket(ip, port)</code>主动连接</td></tr><tr><td><strong>TCP 收发</strong></td><td>依赖<code>Socket</code>的<code>InputStream</code>&#x2F;<code>OutputStream</code>，通过<code>read(缓冲区)</code>&#x2F;<code>write(字节)</code>操作</td></tr><tr><td><strong>UDP 收发</strong></td><td>无连接，收发均用<code>DatagramPacket</code>，接收必须绑定<code>byte[]</code>缓冲区，发送必须指定目标 IP + 端口</td></tr><tr><td><strong>缓冲区作用</strong></td><td>TCP：存字节流片段，需用<code>read()</code>返回值判断实际长度；UDP：存完整数据报，用<code>getLength()</code>取有效长度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UDP 发送端与接收端</title>
      <link href="/posts/39525.html"/>
      <url>/posts/39525.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、核心概念：端口分工与通信流程"><a href="#一、核心概念：端口分工与通信流程" class="headerlink" title="一、核心概念：端口分工与通信流程"></a>一、核心概念：端口分工与通信流程</h2><p>UDP 通信中，发送端和接收端通过<strong>约定的端口</strong>完成数据对接，两者角色不同，端口作用也不同：</p><ol><li><strong>接收端</strong>：需绑定<strong>固定端口</strong>（如 9000），作为 “监听端口”，专门等待接收数据（类似 “固定门牌号”）。</li><li><strong>发送端</strong>：需指定<strong>目标端口</strong>（必须与接收端的固定端口一致，如 9000），作为 “发送目标”（类似 “收件人门牌号”）；发送端自身端口可随机分配（临时端口）或固定。</li><li><strong>通信流程</strong>：接收端先启动并监听端口 → 发送端向目标端口发送数据 → 接收端从监听端口接收数据。</li></ol><h2 id="二、完整代码示例"><a href="#二、完整代码示例" class="headerlink" title="二、完整代码示例"></a>二、完整代码示例</h2><h3 id="1-接收端（Receiver）"><a href="#1-接收端（Receiver）" class="headerlink" title="1. 接收端（Receiver）"></a>1. 接收端（Receiver）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1029;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建DatagramSocket，绑定固定端口9000（监听此端口的数据）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收端已启动，监听9000端口...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建字节数组和数据报，用于接收数据（缓冲区）</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 缓冲区大小（可调整）</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buff, buff.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 阻塞等待接收数据（直到收到数据才继续执行）</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 解析接收的数据：获取发送端IP、端口和数据内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">senderIp</span> <span class="operator">=</span> packet.getAddress().getHostAddress(); <span class="comment">// 发送端IP</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">senderPort</span> <span class="operator">=</span> packet.getPort(); <span class="comment">// 发送端端口（可能是临时端口）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength()); <span class="comment">// 数据内容（0到有效长度，避免空字符）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 打印接收结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自 &quot;</span> + senderIp + <span class="string">&quot;（端口：&quot;</span> + senderPort + <span class="string">&quot;）的消息：&quot;</span> + data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭套接字，释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-发送端（Sender）"><a href="#2-发送端（Sender）" class="headerlink" title="2. 发送端（Sender）"></a>2. 发送端（Sender）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1029;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建DatagramSocket（不指定端口，系统自动分配临时端口）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 准备要发送的数据（字符串转字节数组，网络传输需用字节）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;解放日本&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] buff = str.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建数据报，封装数据、目标IP和目标端口（9000，与接收端一致）</span></span><br><span class="line">        <span class="comment">// 目标IP：127.0.0.1（本机）；若发给其他设备，替换为对方的IP（如192.168.1.105）</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(</span><br><span class="line">            buff, </span><br><span class="line">            buff.length, </span><br><span class="line">            InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="comment">// 目标IP地址</span></span><br><span class="line">            <span class="number">9000</span> <span class="comment">// 目标端口（必须与接收端监听的端口一致）</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发送数据</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据发送成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭套接字</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、关键说明"><a href="#三、关键说明" class="headerlink" title="三、关键说明"></a>三、关键说明</h2><ol><li><strong>运行顺序</strong>：必须<strong>先启动接收端</strong>（确保 9000 端口被监听），再启动发送端，否则发送的数据会因 “无人接收” 而丢失。</li><li><strong>端口含义</strong>：<ul><li>接收端的<code>9000</code>：固定监听端口，是通信的 “约定端口”，发送端必须匹配。</li><li>发送端的端口（如 57007）：系统随机分配的临时端口（若代码中<code>new DatagramSocket()</code>未指定端口），接收端可通过<code>packet.getPort()</code>获取，用于回复消息。</li></ul></li><li><strong>跨设备通信</strong>：若发送给其他设备，只需将发送端的<code>InetAddress.getByName(&quot;127.0.0.1&quot;)</code>改为对方的 IP（如局域网 IP<code>192.168.1.105</code>或公网 IP），确保双方网络互通且端口未被防火墙拦截。</li></ol><h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><ul><li>接收端收不到数据？→ 检查是否先启动接收端、目标端口是否为 9000、IP 是否正确、防火墙是否拦截。</li><li>发送端端口不固定？→ 若需固定发送端端口，可在创建<code>DatagramSocket</code>时指定（如<code>new DatagramSocket(8000)</code>），此时接收端会打印 8000。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InetAddress 类</title>
      <link href="/posts/65120.html"/>
      <url>/posts/65120.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、核心作用"><a href="#一、核心作用" class="headerlink" title="一、核心作用"></a>一、核心作用</h2><p><code>InetAddress</code> 是 Java 中用于表示 <strong>IP 地址</strong> 的类（位于 <code>java.net</code> 包下），封装了 IP 地址的相关信息（如主机名、IP 地址字符串等），提供了操作 IP 地址的常用方法，是网络编程中处理 IP 地址的基础工具。</p><h2 id="二、主要特点"><a href="#二、主要特点" class="headerlink" title="二、主要特点"></a>二、主要特点</h2><ol><li><strong>无构造方法</strong>：不能直接通过 <code>new</code> 创建对象，需通过类提供的静态方法获取实例。</li><li><strong>封装 IP 信息</strong>：包含主机名（如 <code>www.baidu.com</code>）和 IP 地址（如 <code>180.101.50.242</code>），支持 IPv4 和 IPv6 地址。</li></ol><h2 id="三、常用静态方法（获取实例）"><a href="#三、常用静态方法（获取实例）" class="headerlink" title="三、常用静态方法（获取实例）"></a>三、常用静态方法（获取实例）</h2><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td><code>InetAddress.getByName(String host)</code></td><td>根据主机名（如域名）或 IP 地址字符串，获取对应的 <code>InetAddress</code> 实例。<br><br>例：<code>InetAddress.getByName(&quot;www.baidu.com&quot;)</code> 或 <code>getByName(&quot;127.0.0.1&quot;)</code>。</td></tr><tr><td><code>InetAddress.getLocalHost()</code></td><td>获取本机的 <code>InetAddress</code> 实例（包含本机主机名和 IP 地址）。</td></tr><tr><td><code>InetAddress.getAllByName(String host)</code></td><td>获取指定主机名对应的所有 IP 地址（一个域名可能对应多个 IP），返回 <code>InetAddress[]</code> 数组。</td></tr></tbody></table><h2 id="四、常用实例方法（获取信息）"><a href="#四、常用实例方法（获取信息）" class="headerlink" title="四、常用实例方法（获取信息）"></a>四、常用实例方法（获取信息）</h2><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td><code>String getHostAddress()</code></td><td>返回 IP 地址的字符串形式（如 <code>127.0.0.1</code>）。</td></tr><tr><td><code>String getHostName()</code></td><td>返回主机名（若无法解析，返回 IP 地址字符串）。</td></tr><tr><td><code>boolean isLoopbackAddress()</code></td><td>判断当前 IP 地址是否为 <strong>本机回路地址</strong>（如 <code>127.0.0.1</code> 或 IPv6 的 <code>::1</code>）。</td></tr><tr><td><code>boolean isReachable(int timeout)</code></td><td>测试当前 IP 地址对应的主机是否可达（超时时间单位：毫秒），返回 <code>true</code> 表示可达。</td></tr></tbody></table><h2 id="五、示例代码"><a href="#五、示例代码" class="headerlink" title="五、示例代码"></a>五、示例代码</h2><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">// 1. 通过域名获取IP信息</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">baidu</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;百度主机名：&quot;</span> + baidu.getHostName());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度IP地址：&quot;</span> + baidu.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取本机IP信息</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">local</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(<span class="string">&quot;本机主机名：&quot;</span> + local.getHostName());</span><br><span class="line">        System.out.println(<span class="string">&quot;本机IP地址：&quot;</span> + local.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断是否为回路地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否为回路地址：&quot;</span> + local.isLoopbackAddress()); <span class="comment">// 若本机IP是127.0.0.1则返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、核心总结"><a href="#六、核心总结" class="headerlink" title="六、核心总结"></a>六、核心总结</h2><p><code>InetAddress</code> 是 Java 网络编程中处理 IP 地址的核心类，通过它可以轻松获取主机的 IP 地址、主机名等信息，是 <code>Socket</code>、<code>DatagramSocket</code> 等套接字类实现网络通信的基础（例如创建 <code>Socket</code> 时需传入目标主机的 <code>InetAddress</code> 和端口号）。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>套接字（Socket）</title>
      <link href="/posts/1758.html"/>
      <url>/posts/1758.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、套接字的本质"><a href="#一、套接字的本质" class="headerlink" title="一、套接字的本质"></a>一、套接字的本质</h2><p>套接字是网络驱动程序提供给应用程序的<strong>接口和通信机制</strong>，是应用程序与网络协议栈之间的桥梁，用于实现不同主机上应用程序的网络通信。</p><h2 id="二、Java-中的网络通信类（均位于java-net包下）"><a href="#二、Java-中的网络通信类（均位于java-net包下）" class="headerlink" title="二、Java 中的网络通信类（均位于java.net包下）"></a>二、Java 中的网络通信类（均位于<code>java.net</code>包下）</h2><p>Java 通过封装套接字相关类，简化了 TCP 和 UDP 协议的网络编程实现，核心类如下：</p><h3 id="1-UDP-协议相关类"><a href="#1-UDP-协议相关类" class="headerlink" title="1. UDP 协议相关类"></a>1. UDP 协议相关类</h3><p>UDP 通信基于数据报，<strong>不分客户端和服务端</strong>，核心类为：</p><ul><li>**<code>DatagramSocket</code>**：用于发送和接收 UDP 数据报的套接字，是 UDP 通信的端点。</li><li>**<code>DatagramPacket</code>**：用于封装 UDP 传输的数据（包含数据内容、源 &#x2F; 目标地址和端口等信息），是 UDP 通信的数据载体。</li></ul><h3 id="2-TCP-协议相关类"><a href="#2-TCP-协议相关类" class="headerlink" title="2. TCP 协议相关类"></a>2. TCP 协议相关类</h3><p>TCP 通信基于连接，<strong>严格区分客户端和服务端</strong>，核心类为：</p><ul><li>**<code>ServerSocket</code>**：仅用于服务端，负责监听指定端口，接收客户端的连接请求并建立连接。</li><li>**<code>Socket</code>**：主要用于客户端，也用于服务端接收到连接后生成的通信端点，通过它与对方进行数据传输（客户端通过<code>Socket</code>发起连接，服务端通过<code>ServerSocket.accept()</code>获取客户端对应的<code>Socket</code>）。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>协议</th><th>核心类</th><th>通信特点</th></tr></thead><tbody><tr><td>UDP</td><td><code>DatagramSocket</code>、<code>DatagramPacket</code></td><td>无连接，不分客户端 &#x2F; 服务端</td></tr><tr><td>TCP</td><td><code>ServerSocket</code>（服务端）、<code>Socket</code>（客户端及连接后端点）</td><td>面向连接，严格区分客户端 &#x2F; 服务端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP 与 UDP 协议核心知识点整理</title>
      <link href="/posts/63189.html"/>
      <url>/posts/63189.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、TCP（传输控制协议）"><a href="#一、TCP（传输控制协议）" class="headerlink" title="一、TCP（传输控制协议）"></a>一、TCP（传输控制协议）</h2><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>可靠性</strong>：提供面向连接的、可靠的字节流传输，通过确认机制、重传机制、流量控制等确保数据完整送达。</li><li><strong>适用场景</strong>：对数据完整性要求高，可接受一定延迟的场景，例如：<ul><li>安装包下载（需保证文件完整，不允许丢失或损坏）</li><li>网页浏览、邮件发送、文件传输（FTP）等</li></ul></li></ul><h2 id="二、UDP（用户数据报协议）"><a href="#二、UDP（用户数据报协议）" class="headerlink" title="二、UDP（用户数据报协议）"></a>二、UDP（用户数据报协议）</h2><h3 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>高效性</strong>：无连接、不可靠传输，数据包可能丢失，但传输速度快（无需建立连接、确认等额外开销）。</li><li><strong>数据报格式（简单简洁）</strong>：</li></ul><table><thead><tr><th>字段</th><th>长度（位）</th><th>说明</th></tr></thead><tbody><tr><td>源端口</td><td>16</td><td>发送端应用程序端口号</td></tr><tr><td>目标端口</td><td>16</td><td>接收端应用程序端口号</td></tr><tr><td>长度</td><td>16</td><td>整个 UDP 数据报的字节数（包括首部和数据）</td></tr><tr><td>校验和</td><td>16</td><td>用于校验数据在传输中是否损坏（可选）</td></tr><tr><td>数据</td><td>可变</td><td>实际传输的应用数据</td></tr></tbody></table><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>对实时性要求高，可容忍少量数据丢失的场景，例如：</li><li>视频 &#x2F; 语音通话、直播（卡顿可接受，延迟需极低）</li><li>实时游戏、DNS 查询等</li></ul><h3 id="核心区别速记"><a href="#核心区别速记" class="headerlink" title="核心区别速记"></a>核心区别速记</h3><table><thead><tr><th>维度</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接性</td><td>面向连接（需三次握手建立连接）</td><td>无连接（直接发送）</td></tr><tr><td>可靠性</td><td>可靠（无丢失、按序到达）</td><td>不可靠（可能丢失、乱序）</td></tr><tr><td>速度</td><td>较慢（开销大）</td><td>较快（开销小）</td></tr><tr><td>格式复杂度</td><td>复杂（含序号、确认号等）</td><td>简单（仅 4 个首部字段）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI 与 TCP-IP 分层模型笔记</title>
      <link href="/posts/22318.html"/>
      <url>/posts/22318.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、OSI-参考模型（七层模型）"><a href="#一、OSI-参考模型（七层模型）" class="headerlink" title="一、OSI 参考模型（七层模型）"></a>一、OSI 参考模型（七层模型）</h2><p><strong>注意</strong>：OSI（开放系统互连）是由 ISO（国际标准化组织）制定的参考模型，但两者概念不同，需区分。</p><p>七层结构及核心特征：</p><table><thead><tr><th>层级</th><th>核心功能 &#x2F; 数据单位</th><th>典型设备 &#x2F; 组件</th></tr></thead><tbody><tr><td>7. 应用层</td><td>为用户应用提供服务</td><td>各类应用程序（如浏览器、邮件客户端）</td></tr><tr><td>6. 表示层</td><td>数据格式转换、加密解密</td><td>-</td></tr><tr><td>5. 会话层</td><td>建立、管理和终止会话</td><td>-</td></tr><tr><td>4. 传输层</td><td>端到端的数据传输控制</td><td>网关</td></tr><tr><td>3. 网络层</td><td>分组路由与转发</td><td>路由器（数据单位：包）</td></tr><tr><td>2. 数据链路层</td><td>物理地址识别、帧传输</td><td>交换机、网卡、网桥（数据单位：帧）</td></tr><tr><td>1. 物理层</td><td>比特流传输、物理介质连接</td><td>光纤、网线（数据单位：比特）</td></tr></tbody></table><h2 id="二、TCP-IP-分层模型（因特网参考模型）"><a href="#二、TCP-IP-分层模型（因特网参考模型）" class="headerlink" title="二、TCP&#x2F;IP 分层模型（因特网参考模型）"></a>二、TCP&#x2F;IP 分层模型（因特网参考模型）</h2><p>TCP&#x2F;IP 模型是互联网实际应用的分层体系，又称 “因特网分层模型”，共分为 4 层：</p><table><thead><tr><th>层级（按序号）</th><th>名称</th><th>核心功能</th></tr></thead><tbody><tr><td>4</td><td>应用层</td><td>处理特定应用程序细节，直接为应用提供服务（对应 OSI 的应用层、表示层、会话层功能）</td></tr><tr><td>3</td><td>传输层</td><td>实现两个计算机的端到端通信<br><br>・仅在端系统（主机）中实现<br><br>・通过端口号标识主机中的进程（通讯端点是程序而非主机）</td></tr><tr><td>2</td><td>网络层</td><td>处理分组在网络中的活动，负责分组选路与跨网络传输</td></tr><tr><td>1</td><td>链路层</td><td>负责与物理网络的连接，由设备驱动程序实现（对应 OSI 的数据链路层和物理层功能）</td></tr></tbody></table><h3 id="关键区别总结"><a href="#关键区别总结" class="headerlink" title="关键区别总结"></a>关键区别总结</h3><ul><li>OSI 是理论参考模型（七层），注重完整性和通用性；</li><li>TCP&#x2F;IP 是实际应用模型（四层），更简洁，贴合互联网实际运作；</li><li>两者核心功能对应：TCP&#x2F;IP 的链路层涵盖 OSI 物理层 + 数据链路层，应用层涵盖 OSI 上三层。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程基础速查表</title>
      <link href="/posts/52330.html"/>
      <url>/posts/52330.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、网络协议分类"><a href="#一、网络协议分类" class="headerlink" title="一、网络协议分类"></a>一、网络协议分类</h2><h3 id="（一）TCP-IP-协议簇常用协议"><a href="#（一）TCP-IP-协议簇常用协议" class="headerlink" title="（一）TCP&#x2F;IP 协议簇常用协议"></a>（一）TCP&#x2F;IP 协议簇常用协议</h3><p>TCP&#x2F;IP 是互联网核心协议体系，包含以下关键协议：</p><ul><li>Telnet：远程终端协议，用于远程登录管理设备。</li><li>FTP：文件传输协议，采用 C&#x2F;S 模式，实现客户端与服务器间文件传输。</li><li>SMTP：简单邮件传输协议，负责电子邮件的发送。</li><li>NFS：网络文件系统，支持不同主机间共享文件资源。</li><li>UDP：用户数据报协议，无连接、不可靠，适用于实时性要求高的场景（如视频通话）。</li></ul><h3 id="（二）其他常用网络协议"><a href="#（二）其他常用网络协议" class="headerlink" title="（二）其他常用网络协议"></a>（二）其他常用网络协议</h3><ul><li>HTTP 1.1：超文本传输协议，用于浏览器与 Web 服务器间传输网页数据。</li><li>ARP：地址解析协议，将 IP 地址转换为物理 MAC 地址。</li><li>SNMP：简单网络管理协议，用于监控和管理网络设备。</li><li>CMIP：公共管理信息协议，功能更复杂的网络设备统一管理协议。</li><li>DHCP：动态主机配置协议，自动分配 IP 地址、子网掩码等网络参数。</li><li>POP3：邮局协议版本 3，用于接收电子邮件。</li><li>PPP：点对点协议，适用于拨号上网等点对点连接场景。</li><li>IPv6：互联网协议版本 6，解决 IPv4 地址枯竭问题。</li><li>IPX&#x2F;SPX：曾用于 Novell 网络的通信协议。</li></ul><h2 id="二、IP-地址体系"><a href="#二、IP-地址体系" class="headerlink" title="二、IP 地址体系"></a>二、IP 地址体系</h2><h3 id="（一）IPv4-与-IPv6-核心差异"><a href="#（一）IPv4-与-IPv6-核心差异" class="headerlink" title="（一）IPv4 与 IPv6 核心差异"></a>（一）IPv4 与 IPv6 核心差异</h3><table><thead><tr><th>对比维度</th><th>IPv4</th><th>IPv6</th></tr></thead><tbody><tr><td>地址长度</td><td>32 位（二进制）</td><td>128 位（二进制）</td></tr><tr><td>地址数量</td><td>约 43 亿（2³²）</td><td>约 3.4×10³⁸（2¹²⁸）</td></tr><tr><td>新增优势</td><td>-</td><td>地址数量大幅增加（新增数量为 2¹²⁸-2³²）</td></tr><tr><td>特殊地址</td><td>127.0.0.1（本机回路地址，用于本地测试）</td><td>-</td></tr></tbody></table><h3 id="（二）IPv4-地址分类规则（按首段二进制前缀判断）"><a href="#（二）IPv4-地址分类规则（按首段二进制前缀判断）" class="headerlink" title="（二）IPv4 地址分类规则（按首段二进制前缀判断）"></a>（二）IPv4 地址分类规则（按首段二进制前缀判断）</h3><table><thead><tr><th>地址类别</th><th>首段二进制前缀</th><th>地址范围</th><th>用途</th></tr></thead><tbody><tr><td>A 类</td><td>0</td><td>1.0.0.0 ~ 127.255.255.255</td><td>大型网络</td></tr><tr><td>B 类</td><td>10</td><td>128.0.0.0 ~ 191.255.255.255</td><td>中型网络</td></tr><tr><td>C 类</td><td>110</td><td>192.0.0.0 ~ 223.255.255.255</td><td>小型网络</td></tr><tr><td>D 类</td><td>1110</td><td>224.0.0.0 ~ 239.255.255.255</td><td>多点播送</td></tr><tr><td>E 类</td><td>11110</td><td>240.0.0.0 ~ 247.255.255.255</td><td>留作未来使用</td></tr></tbody></table><h2 id="三、端口号规则"><a href="#三、端口号规则" class="headerlink" title="三、端口号规则"></a>三、端口号规则</h2><h3 id="（一）端口号范围与分类"><a href="#（一）端口号范围与分类" class="headerlink" title="（一）端口号范围与分类"></a>（一）端口号范围与分类</h3><p>端口号总范围：0 ~ 65535，按用途分为三类：</p><ul><li>有名端口（0 ~ 1023）：用于知名网络服务（如 HTTP 用 80 端口、HTTPS 用 443 端口），无需额外登记。</li><li>登记端口（1024 ~ 49151）：用于特定应用，使用前需在 IANA（互联网号码分配局）登记。</li><li>动态 &#x2F; 私有端口（49152 ~ 65535）：无使用限制，可随意分配给临时应用。</li></ul><h3 id="（二）端口号查看命令"><a href="#（二）端口号查看命令" class="headerlink" title="（二）端口号查看命令"></a>（二）端口号查看命令</h3><p>Windows 系统中，通过命令行执行 <strong>netstat -noa</strong> 查看端口占用情况，参数含义：</p><ul><li>-n：以数字形式显示 IP 地址和端口号。</li><li>-o：显示占用端口的进程 ID。</li><li>-a：显示所有网络连接和监听端口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 异常处理笔记</title>
      <link href="/posts/54364.html"/>
      <url>/posts/54364.html</url>
      
        <content type="html"><![CDATA[<p>核心原则：<strong>异常处理有明确的优先级，推荐使用全局异常处理器统一管理</strong>，避免代码冗余。</p><h2 id="一、异常处理的三种核心方式"><a href="#一、异常处理的三种核心方式" class="headerlink" title="一、异常处理的三种核心方式"></a>一、异常处理的三种核心方式</h2><p>按使用范围和优先级，分为以下三类，优先级从高到低排列。</p><h3 id="1-控制器（Controller）本类处理"><a href="#1-控制器（Controller）本类处理" class="headerlink" title="1. 控制器（Controller）本类处理"></a>1. 控制器（Controller）本类处理</h3><p>在发生异常的 Controller 内部，通过<code>@ExceptionHandler</code>注解定义方法，专门处理当前类的异常。</p><ul><li><strong>核心特点</strong>：仅作用于当前 Controller，优先级最高。</li><li><strong>适用场景</strong>：当前 Controller 有特殊的异常处理逻辑，与其他 Controller 不同时使用。</li><li><strong>代码示例</strong>（来自 HelloController）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理当前类的算术异常（如10/0）</span></span><br><span class="line"><span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">handleArithmeticException</span><span class="params">(ArithmeticException e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> R.error(<span class="number">100</span>,<span class="string">&quot;执行异常&quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-全局异常处理"><a href="#2-全局异常处理" class="headerlink" title="2. 全局异常处理"></a>2. 全局异常处理</h3><p>通过<code>@RestControllerAdvice</code>（或<code>@ControllerAdvice + @ResponseBody</code>）定义全局组件，处理整个应用中所有未被本类处理的异常。</p><ul><li><strong>核心特点</strong>：作用于整个应用，优先级低于 “本类处理”，高于 “SpringMVC 兜底处理”。</li><li><strong>适用场景</strong>：处理应用中通用的异常（如空指针、数据库异常），是企业开发的最佳实践。</li><li><strong>代码示例</strong>（来自 GlobalExceptionHandler）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局组件注解，等同于 @ControllerAdvice + @ResponseBody</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 处理所有Exception类型异常（最宽泛的异常）</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="number">500</span>,<span class="string">&quot;执行异常&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SpringMVC-兜底处理"><a href="#3-SpringMVC-兜底处理" class="headerlink" title="3. SpringMVC 兜底处理"></a>3. SpringMVC 兜底处理</h3><p>当异常未被 “本类处理” 和 “全局处理” 捕获时，由 SpringMVC 框架默认处理。</p><ul><li><strong>核心特点</strong>：框架自带，无自定义能力，返回默认的错误页面或错误信息。</li><li><strong>适用场景</strong>：仅作为最后的兜底，不推荐依赖，应通过全局处理器覆盖。</li></ul><h2 id="二、异常处理的关键优先级规则"><a href="#二、异常处理的关键优先级规则" class="headerlink" title="二、异常处理的关键优先级规则"></a>二、异常处理的关键优先级规则</h2><ol><li><strong>范围优先级</strong>：<strong>本类处理 &gt; 全局处理 &gt; SpringMVC 兜底处理</strong>。<ul><li>示例：HelloController 的算术异常，优先被本类的<code>handleArithmeticException</code>处理，不会走到全局处理器。</li></ul></li><li><strong>精度优先级</strong>：<strong>精确异常类型 &gt; 宽泛异常类型</strong>。<ul><li>示例：ArithmeticException（算术异常）是 Exception（通用异常）的子类，发生算术异常时，会优先匹配<code>@ExceptionHandler(ArithmeticException.class)</code>，而非<code>@ExceptionHandler(Exception.class)</code>。</li></ul></li></ol><h2 id="三、企业开发最佳实践"><a href="#三、企业开发最佳实践" class="headerlink" title="三、企业开发最佳实践"></a>三、企业开发最佳实践</h2><ol><li><strong>优先使用全局异常处理器</strong>：将所有通用异常（如参数错误、数据库异常、IO 异常）统一在全局处理器中处理，减少代码冗余。</li><li><strong>特殊情况用本类处理</strong>：仅当某个 Controller 有特殊异常逻辑时，在该类内部补充定义，覆盖全局处理。</li><li><strong>避免编程式异常处理</strong>：如<code>try-catch</code>代码块，大量使用会导致业务代码臃肿、可读性差，应通过注解式处理替代（参考 HelloController 中被注释的 try-catch 代码）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 异常处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC_拦截器机制笔记</title>
      <link href="/posts/46144.html"/>
      <url>/posts/46144.html</url>
      
        <content type="html"><![CDATA[<p>SpringMVC_拦截器可在请求到达目标方法前后执行额外操作，是实现权限验证、日志记录等通用功能的核心机制，以下从核心概念、使用步骤、执行规则三方面整理：</p><h3 id="一、核心概念与作用"><a href="#一、核心概念与作用" class="headerlink" title="一、核心概念与作用"></a>一、核心概念与作用</h3><h4 id="1-拦截器定义"><a href="#1-拦截器定义" class="headerlink" title="1. 拦截器定义"></a>1. 拦截器定义</h4><p>拦截器是实现 <code>HandlerInterceptor</code> 接口的组件，能在 <strong>请求处理的关键节点</strong> 插入自定义逻辑，不破坏原有业务代码，实现 “横切关注点” 的复用。</p><h4 id="2-典型应用场景"><a href="#2-典型应用场景" class="headerlink" title="2. 典型应用场景"></a>2. 典型应用场景</h4><ul><li>权限验证：判断用户是否登录、是否有权限访问接口（如未登录则拦截请求）。</li><li>日志记录：记录请求的 URL、参数、处理时长等信息（用于调试或审计）。</li><li>数据共享：在请求处理前向 <code>request</code> 域中存入公共数据（如登录用户信息，供页面使用）。</li><li>资源统一处理：如统一编码设置、跨域配置补充等。</li></ul><h3 id="二、拦截器使用步骤"><a href="#二、拦截器使用步骤" class="headerlink" title="二、拦截器使用步骤"></a>二、拦截器使用步骤</h3><p>需两步完成拦截器的创建与配置，确保拦截器生效。</p><h4 id="步骤-1：创建拦截器（实现-HandlerInterceptor-接口）"><a href="#步骤-1：创建拦截器（实现-HandlerInterceptor-接口）" class="headerlink" title="步骤 1：创建拦截器（实现 HandlerInterceptor 接口）"></a>步骤 1：创建拦截器（实现 HandlerInterceptor 接口）</h4><p><code>HandlerInterceptor</code> 接口提供 3 个核心方法，分别对应请求处理的不同阶段，可按需重写（无需全部实现）。</p><table><thead><tr><th>方法名</th><th>执行时机</th><th>返回值含义</th><th>核心作用</th></tr></thead><tbody><tr><td><code>preHandle</code></td><td>请求到达目标方法 <strong>之前</strong></td><td><code>true</code> 放行，<code>false</code> 拦截</td><td>权限验证、参数预处理</td></tr><tr><td><code>postHandle</code></td><td>目标方法执行 <strong>之后</strong>，页面渲染前</td><td>无返回值</td><td>修改响应数据、补充域属性</td></tr><tr><td><code>afterCompletion</code></td><td>页面渲染 <strong>之后</strong>（请求完成后）</td><td>无返回值</td><td>资源清理（如关闭流、释放连接）</td></tr></tbody></table><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义日志拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 请求处理前执行（权限验证常用）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle：记录请求URL=&quot;</span> + request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 放行请求，进入目标方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标方法执行后，页面渲染前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle：目标方法执行完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个请求完成后（页面渲染后）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion：请求处理完毕，清理资源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤-2：配置拦截器（实现-WebMvcConfigurer）"><a href="#步骤-2：配置拦截器（实现-WebMvcConfigurer）" class="headerlink" title="步骤 2：配置拦截器（实现 WebMvcConfigurer）"></a>步骤 2：配置拦截器（实现 WebMvcConfigurer）</h4><p>创建配置类，通过 <code>addInterceptors</code> 方法指定 “拦截器” 与 “拦截路径”，决定拦截器作用于哪些请求。</p><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 注入自定义拦截器（需先将拦截器注册为Bean，如加@Component）</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogInterceptor logInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(logInterceptor) <span class="comment">// 注册拦截器</span></span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 拦截的路径（/** 表示所有请求）</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/api/login&quot;</span>); <span class="comment">// 排除的路径（登录接口不拦截）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置说明："><a href="#配置说明：" class="headerlink" title="配置说明："></a>配置说明：</h4><ul><li><code>addPathPatterns</code>：指定拦截的 URL 规则，支持通配符（如 <code>/api/**</code> 表示 <code>/api</code> 下所有请求）。</li><li><code>excludePathPatterns</code>：指定不拦截的 URL（如登录、注册接口，静态资源等），优先级高于拦截规则。</li></ul><h3 id="三、拦截器执行规则（核心）"><a href="#三、拦截器执行规则（核心）" class="headerlink" title="三、拦截器执行规则（核心）"></a>三、拦截器执行规则（核心）</h3><p>拦截器的执行顺序（单个 &#x2F; 多个）、异常影响是关键，需重点理解。</p><h4 id="1-单个拦截器的执行流程"><a href="#1-单个拦截器的执行流程" class="headerlink" title="1. 单个拦截器的执行流程"></a>1. 单个拦截器的执行流程</h4><p>请求从发起至结束，拦截器与目标方法的执行顺序固定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求发起 → preHandle（放行） → 目标方法执行 → postHandle → 页面渲染 → afterCompletion → 请求结束</span><br></pre></td></tr></table></figure><h4 id="2-多个拦截器的执行顺序"><a href="#2-多个拦截器的执行顺序" class="headerlink" title="2. 多个拦截器的执行顺序"></a>2. 多个拦截器的执行顺序</h4><p>当配置多个拦截器时，执行顺序遵循 “<strong>preHandle 正序，postHandle&#x2F;afterCompletion 倒序</strong>”，顺序由配置时 <code>addInterceptor</code> 的先后决定。</p><p><strong>示例</strong>：配置拦截器 A、B（A 先注册，B 后注册），执行流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求发起 → A.preHandle（放行） → B.preHandle（放行） → 目标方法 → B.postHandle → A.postHandle → 页面渲染 → B.afterCompletion → A.afterCompletion → 请求结束</span><br></pre></td></tr></table></figure><h4 id="3-异常与执行的关系"><a href="#3-异常与执行的关系" class="headerlink" title="3. 异常与执行的关系"></a>3. 异常与执行的关系</h4><ul><li><p><strong>规则 1</strong>：仅 <code>preHandle</code> 执行成功（返回 <code>true</code>）的拦截器，才会执行对应的 <code>afterCompletion</code>。</p><p>  例：A.preHandle（true）→ B.preHandle（false）→ 仅执行 A.afterCompletion，B 的 postHandle 和 afterCompletion 都不执行。</p></li><li><p><strong>规则 2</strong>：<code>postHandle</code> 执行失败（抛异常），不影响 <code>afterCompletion</code> 执行。</p><p>  例：B.postHandle 抛异常 → 跳过 A.postHandle，但仍会执行 B.afterCompletion → A.afterCompletion。</p></li><li><p><strong>规则 3</strong>：<code>postHandle</code>&#x2F;<code>afterCompletion</code> 从异常发生处开始，倒序链路终止于异常处。</p><p>  例：B.postHandle 抛异常 → 仅执行 B.afterCompletion，不再执行 A.postHandle 和 A.afterCompletion。</p></li></ul><p>![][D:\Obsidian\note\SSM\img\2025-10-27_00-51-16-0.png]</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 拦截器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拦截器 vs 过滤器</title>
      <link href="/posts/31142.html"/>
      <url>/posts/31142.html</url>
      
        <content type="html"><![CDATA[<h1 id="拦截器（Interceptor）vs-过滤器（Filter）对比笔记"><a href="#拦截器（Interceptor）vs-过滤器（Filter）对比笔记" class="headerlink" title="拦截器（Interceptor）vs 过滤器（Filter）对比笔记"></a>拦截器（Interceptor）vs 过滤器（Filter）对比笔记</h1><p>拦截器和过滤器均用于请求处理的 “增强”，但二者在技术归属、作用范围、执行时机等核心维度差异显著，以下从多维度对比梳理：</p><h3 id="一、核心差异对比表"><a href="#一、核心差异对比表" class="headerlink" title="一、核心差异对比表"></a>一、核心差异对比表</h3><table><thead><tr><th>对比维度</th><th>拦截器（Interceptor）</th><th>过滤器（Filter）</th></tr></thead><tbody><tr><td><strong>技术归属</strong></td><td>SpringMVC 框架组件</td><td>Java Servlet 规范组件</td></tr><tr><td><strong>作用范围</strong></td><td>仅作用于 SpringMVC 管理的请求（如 <code>@Controller</code> 接口）</td><td>作用于所有 Servlet 容器接收的请求（包括静态资源、JSP 等）</td></tr><tr><td><strong>执行时机</strong></td><td>在 <strong>DispatcherServlet 之后</strong>、目标方法前后执行</td><td>在 <strong>DispatcherServlet 之前</strong> 执行（请求进入 Servlet 容器的第一道拦截）</td></tr><tr><td><strong>拦截内容</strong></td><td>可拦截请求、目标方法、响应数据（能获取 <code>HandlerMethod</code>、<code>ModelAndView</code> 等 Spring 对象）</td><td>仅能拦截请求和响应的 “字节流”（无法直接获取 Spring 相关对象）</td></tr><tr><td><strong>配置方式</strong></td><td>需实现 <code>WebMvcConfigurer</code> 接口，通过 <code>InterceptorRegistry</code> 配置</td><td>1. 实现 <code>Filter</code> 接口；2. 用 <code>@WebFilter</code> 注解或在配置类中注册 <code>FilterRegistrationBean</code></td></tr><tr><td><strong>依赖环境</strong></td><td>依赖 Spring 容器（需 Spring 环境支持）</td><td>不依赖 Spring，仅需 Servlet 容器（如 Tomcat）</td></tr><tr><td><strong>执行顺序控制</strong></td><td>多个拦截器按 <code>addInterceptor</code> 注册顺序，<code>preHandle</code> 正序、<code>postHandle</code> 倒序</td><td>多个过滤器按 <code>FilterRegistrationBean</code> 的 <code>setOrder</code> 方法指定的数字排序（数字越小越先执行）</td></tr></tbody></table><h3 id="二、核心功能与适用场景"><a href="#二、核心功能与适用场景" class="headerlink" title="二、核心功能与适用场景"></a>二、核心功能与适用场景</h3><h4 id="1-拦截器（Interceptor）：Spring-生态内的-“精准增强”"><a href="#1-拦截器（Interceptor）：Spring-生态内的-“精准增强”" class="headerlink" title="1. 拦截器（Interceptor）：Spring 生态内的 “精准增强”"></a>1. 拦截器（Interceptor）：Spring 生态内的 “精准增强”</h4><p>适用于需要结合 Spring 组件的场景，能深度介入 SpringMVC 的请求处理流程。</p><ul><li><strong>典型场景</strong>：<ul><li>权限验证：获取 <code>HandlerMethod</code> 中的注解（如 <code>@RequiresLogin</code>），判断用户是否登录。</li><li>日志记录：记录目标方法的参数、返回值（需通过 <code>HandlerMethod</code> 反射获取）。</li><li>数据共享：在 <code>postHandle</code> 中修改 <code>ModelAndView</code>，补充页面渲染所需的公共数据。</li></ul></li></ul><h4 id="2-过滤器（Filter）：Servlet-容器级的-“全局拦截”"><a href="#2-过滤器（Filter）：Servlet-容器级的-“全局拦截”" class="headerlink" title="2. 过滤器（Filter）：Servlet 容器级的 “全局拦截”"></a>2. 过滤器（Filter）：Servlet 容器级的 “全局拦截”</h4><p>适用于需要对所有请求（包括非 Spring 管理的资源）进行统一处理的场景。</p><ul><li><strong>典型场景</strong>：<ul><li>编码统一：设置请求 &#x2F; 响应的字符编码（如 <code>UTF-8</code>），避免乱码。</li><li>跨域处理：在响应头中添加 <code>Access-Control-Allow-Origin</code> 等跨域字段（Servlet 层面的跨域配置）。</li><li>全局日志：记录所有请求的 URL、IP、请求方式（包括静态资源请求，如 CSS、JS）。</li><li>敏感字符过滤：对请求参数中的敏感词（如 “脏话”）进行替换或拦截。</li></ul></li></ul><h3 id="三、执行顺序链路（请求处理全流程）"><a href="#三、执行顺序链路（请求处理全流程）" class="headerlink" title="三、执行顺序链路（请求处理全流程）"></a>三、执行顺序链路（请求处理全流程）</h3><p>当一个请求同时经过过滤器和拦截器时，完整执行顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端发起请求 → 2. 过滤器1执行 → 3. 过滤器2执行 → ... → 4. DispatcherServlet 接收请求 → </span><br><span class="line">2. 拦截器1.preHandle → 6. 拦截器2.preHandle → ... → 7. 目标方法（@Controller 接口）执行 → </span><br><span class="line">3. 拦截器2.postHandle → 9. 拦截器1.postHandle → 10. 页面渲染 → </span><br><span class="line">4. 拦截器2.afterCompletion → 12. 拦截器1.afterCompletion → 13. 过滤器2执行（后置） → 14. 过滤器1执行（后置） → 15. 响应返回客户端</span><br></pre></td></tr></table></figure><h3 id="四、关键使用建议"><a href="#四、关键使用建议" class="headerlink" title="四、关键使用建议"></a>四、关键使用建议</h3><ol><li><strong>优先选过滤器的场景</strong>：需处理非 Spring 管理的资源（如静态资源）、需在 Servlet 最早期拦截请求（如编码设置）。</li><li><strong>优先选拦截器的场景</strong>：需结合 Spring 组件（如 <code>@Controller</code>、<code>ModelAndView</code>）、需精细控制目标方法前后的逻辑（如权限注解判断）。</li><li><strong>协同使用场景</strong>：过滤器做 “全局基础处理”（如编码、跨域），拦截器做 “Spring 内精准增强”（如接口权限、方法日志），二者配合实现完整的请求增强链路。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 拦截器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端数据交互规范</title>
      <link href="/posts/60679.html"/>
      <url>/posts/60679.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-统一响应格式（R-类）"><a href="#1-统一响应格式（R-类）" class="headerlink" title="1. 统一响应格式（R 类）"></a>1. 统一响应格式（R 类）</h3><h4 id="（1）核心字段"><a href="#（1）核心字段" class="headerlink" title="（1）核心字段"></a>（1）核心字段</h4><ul><li><code>code</code>：业务状态码，200 表示成功，其他数值表示失败（需前后端约定具体含义，如 404 表示资源不存在）。</li><li><code>msg</code>：响应消息，用于前端展示（如 “删除成功”“ID 不存在”）。</li><li><code>data</code>：业务数据，存储返回的具体信息（如查询到的员工对象、员工列表）。</li></ul><h4 id="（2）常用方法"><a href="#（2）常用方法" class="headerlink" title="（2）常用方法"></a>（2）常用方法</h4><ul><li><code>R.ok(data)</code>：返回成功响应，携带业务数据（如查询列表时返回<code>List&lt;Employee&gt;</code>）。</li><li><code>R.ok()</code>：返回成功响应，无业务数据（如删除、新增操作）。</li></ul><h3 id="2-数据交互流程"><a href="#2-数据交互流程" class="headerlink" title="2. 数据交互流程"></a>2. 数据交互流程</h3><ol><li>前端发送请求：根据接口类型选择传递路径参数或请求体（如查询用 GET + 路径参数，新增用 POST+JSON 请求体）。</li><li>后端处理：控制器接收请求，调用服务层处理业务，通过<code>R</code>类封装响应结果。</li><li>前端接收处理：判断<code>code</code>值，成功则解析<code>data</code>展示数据，失败则显示<code>msg</code>提示信息。</li></ol><h3 id="3-数据格式要求"><a href="#3-数据格式要求" class="headerlink" title="3. 数据格式要求"></a>3. 数据格式要求</h3><ul><li>前端传递：新增 &#x2F; 更新资源时，请求体需与后端实体类（如 Employee）字段名一致，格式为 JSON。</li><li>后端返回：响应数据统一为 JSON 格式，通过<code>R</code>类保证结构一致。</li></ul><p>R类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.practice.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; R&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        R&lt;T&gt; r = <span class="keyword">new</span> <span class="title class_">R</span>&lt;&gt;();</span><br><span class="line">        r.setCode(<span class="number">200</span>);</span><br><span class="line">        r.setMsg(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        r.setData(data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.setCode(<span class="number">200</span>);</span><br><span class="line">        r.setMsg(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        r.setData(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">error</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.setCode(<span class="number">500</span>);</span><br><span class="line">        r.setMsg(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        r.setData(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">error</span><span class="params">(Integer code, String msg)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.setCode(code);</span><br><span class="line">        r.setMsg(msg);</span><br><span class="line">        r.setData(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; R&lt;T&gt; <span class="title function_">error</span><span class="params">(Integer code, String msg, T data)</span> &#123;</span><br><span class="line">        R&lt;T&gt; r = <span class="keyword">new</span> <span class="title class_">R</span>&lt;&gt;();</span><br><span class="line">        r.setCode(code);</span><br><span class="line">        r.setMsg(msg);</span><br><span class="line">        r.setData(data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> RESTful </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题（CORS）</title>
      <link href="/posts/63438.html"/>
      <url>/posts/63438.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-同源策略与跨域定义"><a href="#1-同源策略与跨域定义" class="headerlink" title="1. 同源策略与跨域定义"></a>1. 同源策略与跨域定义</h3><h4 id="（1）同源策略"><a href="#（1）同源策略" class="headerlink" title="（1）同源策略"></a>（1）同源策略</h4><p>浏览器的安全策略，要求 AJAX 请求的<strong>协议、域名、端口</strong>三者完全一致（即 “同源”），否则拦截请求。</p><h4 id="（2）跨域场景"><a href="#（2）跨域场景" class="headerlink" title="（2）跨域场景"></a>（2）跨域场景</h4><p>当请求的协议、域名、端口任一与当前页面不一致时，即为跨域。例如：</p><ul><li>页面地址：<code>http://localhost</code>（端口默认 80）</li><li>请求地址：<code>http://localhost:8080</code>（端口不同）</li><li>页面地址：<code>http://127.0.0.1</code></li><li>请求地址：<code>http://localhost</code>（域名不同，即使指向同一 IP）</li></ul><h3 id="2-跨域请求的特殊行为"><a href="#2-跨域请求的特殊行为" class="headerlink" title="2. 跨域请求的特殊行为"></a>2. 跨域请求的特殊行为</h3><p>复杂跨域请求（如 POST、PUT）会先发一次<code>OPTIONS</code>预请求，询问服务器是否允许当前域名访问；服务器允许后，才会发送真正的业务请求。</p><h3 id="3-后端解决方案"><a href="#3-后端解决方案" class="headerlink" title="3. 后端解决方案"></a>3. 后端解决方案</h3><h4 id="（1）使用-CrossOrigin-注解"><a href="#（1）使用-CrossOrigin-注解" class="headerlink" title="（1）使用 @CrossOrigin 注解"></a>（1）使用 @CrossOrigin 注解</h4><ul><li>位置：添加在控制器类上（如<code>EmployeeRestController</code>），作用于该类所有接口。</li><li>原理：服务器响应时自动添加<code>Access-Control-Allow-Origin</code>响应头，默认允许所有域名（<code>*</code>）访问。</li><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span> <span class="comment">// 允许所有域跨域访问</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeRestController</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="（2）自定义配置（进阶）"><a href="#（2）自定义配置（进阶）" class="headerlink" title="（2）自定义配置（进阶）"></a>（2）自定义配置（进阶）</h4><p>若需指定允许的域名、方法，可通过配置类实现，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 对指定路径生效</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:8081&quot;</span>) <span class="comment">// 允许的前端域名</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>) <span class="comment">// 允许的HTTP方法</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>); <span class="comment">// 是否允许携带Cookie</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> RESTful </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后端接口设计（RESTful 风格）</title>
      <link href="/posts/39410.html"/>
      <url>/posts/39410.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-核心设计原则"><a href="#1-核心设计原则" class="headerlink" title="1. 核心设计原则"></a>1. 核心设计原则</h3><p>基于 HTTP 方法语义定义接口功能，URL 仅表示资源，不包含操作动词（如 “add”“delete”）。</p><h3 id="2-关键注解与使用"><a href="#2-关键注解与使用" class="headerlink" title="2. 关键注解与使用"></a>2. 关键注解与使用</h3><table><thead><tr><th>注解</th><th>作用</th><th>应用场景</th></tr></thead><tbody><tr><td>@RequestMapping</td><td>类 &#x2F; 方法级路径映射，可指定 HTTP 方法</td><td>类上定义基础路径（如<code>/api/v1</code>）</td></tr><tr><td>@GetMapping</td><td>处理 GET 请求，简化 @RequestMapping (method&#x3D;GET)</td><td>查询单个资源、查询资源列表</td></tr><tr><td>@DeleteMapping</td><td>处理 DELETE 请求</td><td>删除指定资源</td></tr><tr><td>@PostMapping</td><td>处理 POST 请求</td><td>新增资源</td></tr><tr><td>@PutMapping</td><td>处理 PUT 请求</td><td>更新资源</td></tr></tbody></table><h3 id="3-参数传递方式"><a href="#3-参数传递方式" class="headerlink" title="3. 参数传递方式"></a>3. 参数传递方式</h3><ul><li>路径参数：用<code>@PathVariable(&quot;参数名&quot;)</code>获取 URL 中的参数，如<code>/employee/&#123;id&#125;</code>中的<code>id</code>，适用于查询、删除单个资源。</li><li>请求体参数：用<code>@RequestBody</code>接收 JSON 格式的请求体数据，适用于新增、更新资源时传递完整对象（如 Employee）。</li></ul><h3 id="4-接口示例"><a href="#4-接口示例" class="headerlink" title="4. 接口示例"></a>4. 接口示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询单个员工（GET请求+路径参数）</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/employee/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Employee&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增员工（POST请求+请求体）</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> Employee employee)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> RESTful </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节流、字符流和缓冲流</title>
      <link href="/posts/17676.html"/>
      <url>/posts/17676.html</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，字节流、字符流和缓冲流的核心区别主要体现在<strong>操作数据的单位</strong>、<strong>适用场景</strong>以及<strong>性能特性</strong>上。以下是具体分析：</p><h3 id="1-字节流（Byte-Stream）"><a href="#1-字节流（Byte-Stream）" class="headerlink" title="1. 字节流（Byte Stream）"></a>1. 字节流（Byte Stream）</h3><ul><li><strong>操作单位</strong>：以<strong>字节（8 位二进制）</strong> 为单位处理数据，直接操作原始字节数据。</li><li><strong>核心类</strong>：<ul><li>输入流：<code>InputStream</code>（抽象基类），常用实现类如 <code>FileInputStream</code>（文件输入）、<code>ByteArrayInputStream</code>（字节数组输入）。</li><li>输出流：<code>OutputStream</code>（抽象基类），常用实现类如 <code>FileOutputStream</code>（文件输出）、<code>ByteArrayOutputStream</code>（字节数组输出）。</li></ul></li><li><strong>适用场景</strong>：处理<strong>二进制数据</strong>（非文本数据），如图片、音频、视频、压缩包等。</li><li><strong>特点</strong>：<ul><li>直接与底层数据交互，无编码 &#x2F; 解码过程，数据原样传输。</li><li>读写文本时可能出现乱码（因为不同编码的字符占用字节数不同，如 UTF-8 中一个汉字占 3 字节，GBK 中占 2 字节）。</li></ul></li></ul><h3 id="2-字符流（Character-Stream）"><a href="#2-字符流（Character-Stream）" class="headerlink" title="2. 字符流（Character Stream）"></a>2. 字符流（Character Stream）</h3><ul><li><strong>操作单位</strong>：以<strong>字符（16 位 Unicode）</strong> 为单位处理数据，本质是对字节流的封装，会自动进行<strong>编码（写入时）</strong> 和<strong>解码（读取时）</strong>。</li><li><strong>核心类</strong>：<ul><li>输入流：<code>Reader</code>（抽象基类），常用实现类如 <code>FileReader</code>（文件字符输入）、<code>InputStreamReader</code>（字节流转字符流，可指定编码）。</li><li>输出流：<code>Writer</code>（抽象基类），常用实现类如 <code>FileWriter</code>（文件字符输出）、<code>OutputStreamWriter</code>（字节流转字符流，可指定编码）。</li></ul></li><li><strong>适用场景</strong>：处理<strong>文本数据</strong>（如.txt、.java 文件等），能避免乱码（需保证读写编码一致）。</li><li><strong>特点</strong>：<ul><li>依赖字符编码（默认使用系统编码，可通过 <code>InputStreamReader/OutputStreamWriter</code> 手动指定，如 UTF-8）。</li><li>不适合处理二进制数据（会破坏原始字节结构）。</li></ul></li></ul><h3 id="3-缓冲流（Buffered-Stream）"><a href="#3-缓冲流（Buffered-Stream）" class="headerlink" title="3. 缓冲流（Buffered Stream）"></a>3. 缓冲流（Buffered Stream）</h3><ul><li><strong>本质</strong>：是<strong>装饰器模式</strong>的应用，为字节流或字符流提供<strong>缓冲区（内存块）</strong>，减少直接 IO 操作次数，提升性能。</li><li><strong>核心类</strong>：<ul><li>字节缓冲流：<code>BufferedInputStream</code>（包装字节输入流）、<code>BufferedOutputStream</code>（包装字节输出流）。</li><li>字符缓冲流：<code>BufferedReader</code>（包装字符输入流，提供 <code>readLine()</code> 等便捷方法）、<code>BufferedWriter</code>（包装字符输出流，提供 <code>newLine()</code> 等方法）。</li></ul></li><li><strong>工作原理</strong>：<ul><li>写入时：数据先存入缓冲区，缓冲区满后一次性写入磁盘（减少磁盘 IO 次数）。</li><li>读取时：一次性从磁盘读取一批数据到缓冲区，后续读取直接从缓冲区获取（减少磁盘 IO 次数）。</li></ul></li><li><strong>适用场景</strong>：需要频繁读写数据时（几乎所有 IO 场景都推荐使用），能显著提升性能。</li><li><strong>特点</strong>：<ul><li>本身不直接处理数据，需依赖底层的字节流或字符流（如 <code>new BufferedReader(new FileReader(&quot;file.txt&quot;))</code>）。</li><li>字符缓冲流额外提供了便捷方法（如 <code>readLine()</code> 读取一行文本）。</li></ul></li></ul><h3 id="三者关系与对比总结"><a href="#三者关系与对比总结" class="headerlink" title="三者关系与对比总结"></a>三者关系与对比总结</h3><table><thead><tr><th>类型</th><th>操作单位</th><th>核心作用</th><th>典型使用场景</th><th>性能</th></tr></thead><tbody><tr><td>字节流</td><td>字节</td><td>处理二进制数据</td><td>图片、音频、视频等</td><td>直接 IO，性能一般</td></tr><tr><td>字符流</td><td>字符</td><td>处理文本数据（自动编码）</td><td>文本文件读写</td><td>直接 IO，性能一般</td></tr><tr><td>缓冲流</td><td>无（包装流）</td><td>为字节 &#x2F; 字符流提供缓冲区</td><td>增强字节 &#x2F; 字符流性能</td><td>减少 IO 次数，性能高</td></tr></tbody></table><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>处理文本：优先用 <strong>字符缓冲流</strong>（<code>BufferedReader/BufferedWriter</code>），并指定编码（避免依赖系统默认编码）。</li><li>处理二进制：优先用 <strong>字节缓冲流</strong>（<code>BufferedInputStream/BufferedOutputStream</code>）。</li><li>避免直接使用基础字节流 &#x2F; 字符流（性能差），尽量通过缓冲流包装后使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池  ThreadPoolExecutor 核心笔记：7 参数构造方法与拒绝策略</title>
      <link href="/posts/2331.html"/>
      <url>/posts/2331.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、核心构造方法（7-参数）"><a href="#一、核心构造方法（7-参数）" class="headerlink" title="一、核心构造方法（7 参数）"></a>一、核心构造方法（7 参数）</h2><p>ThreadPoolExecutor 是 Java 线程池的核心实现类，其 7 参数构造方法定义了线程池的核心行为，具体参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,                // <span class="number">1.</span> 核心线程数</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,             // <span class="number">2.</span> 最大线程数</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,              // <span class="number">3.</span> 线程空闲存活时间</span></span><br><span class="line"><span class="params">    TimeUnit unit,                   // <span class="number">4.</span> 时间计量单位</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue, // <span class="number">5.</span> 任务队列</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,     // <span class="number">6.</span> 线程工厂</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler // <span class="number">7.</span> 拒绝策略处理器</span></span><br><span class="line"><span class="params">)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="二、7-个参数详细解析"><a href="#二、7-个参数详细解析" class="headerlink" title="二、7 个参数详细解析"></a>二、7 个参数详细解析</h2><h3 id="1-核心线程数（corePoolSize）"><a href="#1-核心线程数（corePoolSize）" class="headerlink" title="1. 核心线程数（corePoolSize）"></a>1. 核心线程数（corePoolSize）</h3><ul><li>线程池的基础线程数量，线程池初始化时不会立即创建核心线程，而是在有任务提交时逐步创建。</li><li>任务提交时的线程创建规则：<ul><li>若当前线程总数 &lt; corePoolSize：新建核心线程执行任务；</li><li>若当前线程总数 ≥ corePoolSize：新任务不会创建核心线程，会进入任务队列或创建非核心线程（需满足最大线程数限制）。</li></ul></li><li>核心线程的存活特性：默认情况下，核心线程会一直存活在线程池，即使处于空闲状态；若设置 <code>allowCoreThreadTimeOut = true</code>，核心线程空闲时间超过指定阈值后会被销毁。</li></ul><h3 id="2-最大线程数（maximumPoolSize）"><a href="#2-最大线程数（maximumPoolSize）" class="headerlink" title="2. 最大线程数（maximumPoolSize）"></a>2. 最大线程数（maximumPoolSize）</h3><ul><li>线程池能容纳的最大线程总数，计算公式为：<code>最大线程数 = 核心线程数 + 非核心线程数</code>。</li><li>当任务队列满且核心线程全部繁忙时，线程池会创建非核心线程处理任务，但总线程数不能超过此值。</li></ul><h3 id="3-线程空闲存活时间（keepAliveTime）"><a href="#3-线程空闲存活时间（keepAliveTime）" class="headerlink" title="3. 线程空闲存活时间（keepAliveTime）"></a>3. 线程空闲存活时间（keepAliveTime）</h3><ul><li>用于控制空闲线程的销毁时机，默认仅作用于非核心线程：<ul><li>非核心线程空闲时长超过该值，会被线程池销毁以节省资源；</li><li>若设置 <code>allowCoreThreadTimeOut = true</code>，该参数同样作用于核心线程，空闲核心线程超过时长也会被销毁。</li></ul></li></ul><h3 id="4-时间计量单位（TimeUnit）"><a href="#4-时间计量单位（TimeUnit）" class="headerlink" title="4. 时间计量单位（TimeUnit）"></a>4. 时间计量单位（TimeUnit）</h3><ul><li>枚举类型，用于指定 <code>keepAliveTime</code> 的时间单位，常用取值如下：<ul><li><code>TimeUnit.NANOSECONDS</code>：纳秒（1 纳秒 &#x3D; 1 微秒 &#x2F; 1000）</li><li><code>TimeUnit.MICROSECONDS</code>：微秒（1 微秒 &#x3D; 1 毫秒 &#x2F; 1000）</li><li><code>TimeUnit.MILLISECONDS</code>：毫秒（1 毫秒 &#x3D; 1 秒 &#x2F; 1000）</li><li><code>TimeUnit.SECONDS</code>：秒</li><li><code>TimeUnit.MINUTES</code>：分</li><li><code>TimeUnit.HOURS</code>：时</li><li><code>TimeUnit.DAYS</code>：天</li></ul></li></ul><h3 id="5-任务队列（BlockingQueue）"><a href="#5-任务队列（BlockingQueue）" class="headerlink" title="5. 任务队列（BlockingQueue&lt;Runnable&gt;）"></a>5. 任务队列（BlockingQueue&lt;Runnable&gt;）</h3><ul><li>用于存储等待执行的任务，是一个单端阻塞队列（BlockingQueue 为接口，需使用具体实现类），常用实现类如下：<ul><li><code>ArrayBlockingQueue</code>：基于数组的有界阻塞队列，需指定固定容量，特点是线程安全、性能稳定，适合任务量可预估的场景。</li><li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列，默认容量为 Integer.MAX_VALUE（可视为无界队列），也可指定容量，适合任务量波动较大的场景，但需注意无界队列可能导致内存溢出。</li><li><code>SynchronousQueue</code>：同步队列，无实际存储空间，提交的任务必须立即被线程执行，若无空闲线程则创建新线程（需配合最大线程数限制），适合任务执行时间短、并发量高的场景。</li><li><code>PriorityBlockingQueue</code>：优先级阻塞队列，无界队列，任务按优先级排序执行，适合对任务执行顺序有优先级要求的场景。</li><li><code>DelayQueue</code>：延迟队列，无界队列，任务需实现 Delayed 接口，仅在延迟时间到期后才会被执行，适合定时任务场景（如定时重试、定时通知）。</li></ul></li></ul><h3 id="6-线程工厂（ThreadFactory）"><a href="#6-线程工厂（ThreadFactory）" class="headerlink" title="6. 线程工厂（ThreadFactory）"></a>6. 线程工厂（ThreadFactory）</h3><ul><li>用于定义线程的创建规则，可自定义线程名称、设置线程是否为守护线程（后台线程）、设置线程优先级等。</li><li>日常开发中若无需特殊配置，可使用默认实现，无需额外自定义。</li></ul><h3 id="7-拒绝策略处理器（RejectedExecutionHandler）"><a href="#7-拒绝策略处理器（RejectedExecutionHandler）" class="headerlink" title="7. 拒绝策略处理器（RejectedExecutionHandler）"></a>7. 拒绝策略处理器（RejectedExecutionHandler）</h3><ul><li>当线程池达到最大线程数且任务队列已满时，新提交的任务会触发拒绝策略，用于定义任务的处理方式。</li></ul><h2 id="三、JDK-内置四种拒绝策略"><a href="#三、JDK-内置四种拒绝策略" class="headerlink" title="三、JDK 内置四种拒绝策略"></a>三、JDK 内置四种拒绝策略</h2><h3 id="1-AbortPolicy（终止策略）"><a href="#1-AbortPolicy（终止策略）" class="headerlink" title="1. AbortPolicy（终止策略）"></a>1. AbortPolicy（终止策略）</h3><ul><li>线程池默认拒绝策略。</li><li>核心行为：直接拒绝新任务，抛出 <code>RejectedExecutionException</code>（运行时异常）。</li><li>注意事项：若使用 <code>execute()</code> 方法提交任务且未通过 <code>try-catch</code> 捕获异常，会导致提交任务的线程终止（若为主线程则程序直接退出）。</li><li>适用场景：对任务可靠性要求高、不允许任务丢失，且需及时感知任务提交失败的核心业务场景（如数据入库、订单处理）。</li><li>使用示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">2</span>, <span class="number">4</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 默认策略，可省略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-CallerRunsPolicy（调用者运行策略）"><a href="#2-CallerRunsPolicy（调用者运行策略）" class="headerlink" title="2. CallerRunsPolicy（调用者运行策略）"></a>2. CallerRunsPolicy（调用者运行策略）</h3><ul><li>核心行为：新任务被拒绝后，由提交任务的线程（调用者线程）亲自执行该任务，不丢弃任务。</li><li>特点：<ul><li>保证任务一定执行，除非线程池被关闭；</li><li>可能阻塞调用者线程：若调用者为核心业务线程（如接口请求线程），执行任务会占用其资源，导致入口阻塞（如接口响应变慢）。</li></ul></li><li>适用场景：任务总量不大、对响应速度要求不高，且不允许任务丢失的非核心场景（如日志打印、数据备份）。</li></ul><h3 id="3-DiscardOldestPolicy（丢弃最旧任务策略）"><a href="#3-DiscardOldestPolicy（丢弃最旧任务策略）" class="headerlink" title="3. DiscardOldestPolicy（丢弃最旧任务策略）"></a>3. DiscardOldestPolicy（丢弃最旧任务策略）</h3><ul><li>核心行为：先丢弃任务队列头部（最早提交但未执行）的任务，然后尝试将新任务提交到线程池执行。</li><li>特点：会丢失队列中的旧任务，且无异常提示，可能导致关键任务丢失且难以排查。</li><li>适用场景：任务具有时效性，新任务优先级高于旧任务，且允许丢弃旧任务的场景（如实时数据统计、临时缓存更新）。</li><li>注意事项：建议搭配日志记录机制，跟踪任务丢弃情况，避免核心旧任务丢失。</li></ul><h3 id="4-DiscardPolicy（丢弃策略）"><a href="#4-DiscardPolicy（丢弃策略）" class="headerlink" title="4. DiscardPolicy（丢弃策略）"></a>4. DiscardPolicy（丢弃策略）</h3><ul><li>核心行为：直接丢弃新提交的任务，不执行任何操作，也不抛出异常（空实现）。</li><li>特点：任务无声丢失，排查困难，仅适用于任务无关紧要的场景。</li><li>适用场景：任务丢失对业务无影响的场景（如非关键监控数据上报、临时日志采集）。</li><li>禁忌场景：核心业务任务、数据一致性要求高的任务（绝对禁止使用）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeSet 核心知识点总结</title>
      <link href="/posts/61077.html"/>
      <url>/posts/61077.html</url>
      
        <content type="html"><![CDATA[<h2 id="底层结构与核心特性"><a href="#底层结构与核心特性" class="headerlink" title="底层结构与核心特性"></a>底层结构与核心特性</h2><ul><li><strong>底层</strong>：基于红黑树（依赖 TreeMap 实现）</li><li><strong>特性</strong>：元素唯一、有序序（非插入顺序）、无索引、线程不安全</li><li><strong>排序</strong>：支持自然排序（元素实现 <code>Comparable</code>）或自定义排序（构造 <code>Comparator</code>）</li><li><strong>性能</strong>：插入 &#x2F; 查询 &#x2F; 删除均为 O (log n)</li></ul><h2 id="关键方法（表格形式）"><a href="#关键方法（表格形式）" class="headerlink" title="关键方法（表格形式）"></a>关键方法（表格形式）</h2><table><thead><tr><th>方法分类</th><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td><strong>基础操作</strong></td><td><code>boolean add(E e)</code></td><td>添加元素，重复则返回 false</td></tr><tr><td></td><td><code>boolean remove(Object o)</code></td><td>删除指定元素，成功返回 true</td></tr><tr><td></td><td><code>boolean contains(Object o)</code></td><td>判断元素是否存在</td></tr><tr><td></td><td><code>int size()</code></td><td>返回元素个数</td></tr><tr><td></td><td><code>boolean isEmpty()</code></td><td>判断集合是否为空</td></tr><tr><td></td><td><code>void clear()</code></td><td>清空所有元素</td></tr><tr><td><strong>导航操作</strong></td><td><code>E first()</code></td><td>返回最小元素（第一个元素）</td></tr><tr><td></td><td><code>E last()</code></td><td>返回最大元素（最后一个元素）</td></tr><tr><td></td><td><code>E ceiling(E e)</code></td><td>返回大于等于 e 的最小元素（不存在返回 null）</td></tr><tr><td></td><td><code>E floor(E e)</code></td><td>返回小于等于 e 的最大元素（不存在返回 null）</td></tr><tr><td></td><td><code>E higher(E e)</code></td><td>返回严格大于 e 的最小元素</td></tr><tr><td></td><td><code>E lower(E e)</code></td><td>返回严格小于 e 的最大元素</td></tr><tr><td><strong>范围操作</strong></td><td><code>SortedSet&lt;E&gt; subSet(E from, E to)</code></td><td>返回 [from, to) 区间的子集合</td></tr><tr><td></td><td><code>SortedSet&lt;E&gt; headSet(E to)</code></td><td>返回小于 to 的所有元素组成的子集合</td></tr><tr><td></td><td><code>SortedSet&lt;E&gt; tailSet(E from)</code></td><td>返回大于等于 from 的所有元素组成的子集合</td></tr></tbody></table><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>元素默认不可为 null（未处理 null 的排序规则会抛 <code>NullPointerException</code>）</li><li>重复判断依赖排序方法（<code>compareTo</code> 或 <code>compare</code> 返回 0 即视为重复）</li><li>适合场景：需有序去重、范围查询的场景（如排行榜、数据排序）</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 类 &amp; 接口 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组扩容</title>
      <link href="/posts/29766.html"/>
      <url>/posts/29766.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-直接用循环复制"><a href="#1-直接用循环复制" class="headerlink" title="1. 直接用循环复制"></a>1. <strong>直接用循环复制</strong></h2><h2 id="2-使用Arrays-copy"><a href="#2-使用Arrays-copy" class="headerlink" title="2. 使用Arrays.copy()"></a>2. <strong>使用Arrays.copy()</strong></h2><h2 id="3-System-arraycopy-方法进行复制"><a href="#3-System-arraycopy-方法进行复制" class="headerlink" title="3. System.arraycopy() 方法进行复制"></a>3. <strong>System.arraycopy() 方法进行复制</strong></h2><p>在自定义动态数组的扩容过程中，常用的元素复制方法有三种：循环复制、<code>Arrays.copyOf()</code> 和 <code>System.arraycopy()</code>。以下是它们的详细解释和区别：</p><p>&#x3D;&#x3D;<code>elements是数组</code>&#x3D;&#x3D;</p><h3 id="1-直接用循环复制-1"><a href="#1-直接用循环复制-1" class="headerlink" title="1. 直接用循环复制"></a>1. 直接用循环复制</h3><p><strong>原理</strong>：通过 <code>for</code> 循环遍历原数组，将每个元素逐个复制到新数组中。</p><p><strong>实现示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> elements.length * <span class="number">2</span>; <span class="comment">// 假设扩容为原来的2倍</span></span><br><span class="line">    Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 循环复制元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        newElements[i] = elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    elements = newElements; <span class="comment">// 替换为新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>实现简单直观，适合初学者理解</li><li>性能较差（纯 Java 代码循环，效率低于底层优化的方法）</li><li>灵活性高，可在复制过程中添加额外逻辑（如过滤、转换元素）</li></ul><h3 id="2-使用-Arrays-copyOf-方法"><a href="#2-使用-Arrays-copyOf-方法" class="headerlink" title="2. 使用 Arrays.copyOf() 方法"></a>2. 使用 <code>Arrays.copyOf()</code> 方法</h3><p><strong>原理</strong>：Java 提供的工具类方法，内部通过 <code>System.arraycopy()</code> 实现，简化了复制逻辑。</p><p><strong>实现示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> elements.length * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 直接生成新数组并复制元素（自动处理长度）</span></span><br><span class="line">    elements = Arrays.copyOf(elements, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>代码简洁，一行即可完成数组复制和扩容</li><li>内部依赖 <code>System.arraycopy()</code>，性能较好</li><li>会自动处理原数组与新数组的长度差异（若新数组更长，多余位置填默认值 <code>null</code>）</li><li>属于 <code>java.util.Arrays</code> 工具类，需导入包</li></ul><h3 id="3-使用-System-arraycopy-方法"><a href="#3-使用-System-arraycopy-方法" class="headerlink" title="3. 使用 System.arraycopy() 方法"></a>3. 使用 <code>System.arraycopy()</code> 方法</h3><p><strong>原理</strong>：Java 底层 native 方法（本地方法，由 C&#x2F;C++ 实现），直接操作内存块，效率极高。</p><p><strong>实现示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> elements.length * <span class="number">2</span>;</span><br><span class="line">    Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 本地方法复制：原数组、原数组起始位置、新数组、新数组起始位置、复制长度</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, size);</span><br><span class="line">    elements = newElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>性能最优（底层直接操作内存，无 Java 层循环开销）</li><li>需手动创建新数组，参数较多（原数组、源起始索引、目标数组、目标起始索引、复制长度）</li><li>适合对性能要求高的场景，是 ArrayList 等 Java 集合的底层实现方式</li></ul><h3 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h3><table><thead><tr><th>方法</th><th>性能</th><th>代码简洁度</th><th>灵活性</th><th>适用场景</th></tr></thead><tbody><tr><td>循环复制</td><td>低</td><td>低</td><td>高</td><td>简单场景、需自定义复制逻辑</td></tr><tr><td><code>Arrays.copyOf()</code></td><td>高</td><td>高</td><td>中</td><td>日常开发，追求代码简洁</td></tr><tr><td><code>System.arraycopy()</code></td><td>最高</td><td>中</td><td>中</td><td>底层实现、高性能要求场景</td></tr></tbody></table><p>实际开发中，推荐优先使用 <code>Arrays.copyOf()</code>（简洁）或 <code>System.arraycopy()</code>（高性能），循环复制仅在需要特殊处理时使用。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Callable + ExecutorService 创建线程的笔记</title>
      <link href="/posts/33750.html"/>
      <url>/posts/33750.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、核心组合的作用"><a href="#一、核心组合的作用" class="headerlink" title="一、核心组合的作用"></a>一、核心组合的作用</h4><p><code>Callable</code> 是带返回值的任务接口，<code>ExecutorService</code> 是线程池管理接口，两者结合可实现 <strong>多线程并发执行带返回值的任务</strong>，兼具线程复用（线程池优势）和结果获取（Callable 优势）的特性。</p><h4 id="二、关键组件"><a href="#二、关键组件" class="headerlink" title="二、关键组件"></a>二、关键组件</h4><ol><li><p>**<code>Callable&lt;V&gt;</code>**：</p><ul><li>泛型接口，<code>V</code> 为返回值类型。</li><li>需重写 <code>call()</code> 方法（任务执行体），支持返回结果和声明异常。</li></ul></li><li><p>**<code>ExecutorService</code>**：</p><ul><li>线程池接口，负责管理线程生命周期和任务调度。</li><li>通过 <code>submit(Callable&lt;V&gt;)</code> 方法提交任务，返回 <code>Future&lt;V&gt;</code> 对象。</li></ul></li><li><p>**<code>Future&lt;V&gt;</code>**：</p><ul><li>用于跟踪任务状态，获取 <code>call()</code> 方法的返回值（<code>get()</code> 方法），支持取消任务（<code>cancel()</code>）。</li></ul></li></ol><h4 id="三、使用步骤（代码示例）"><a href="#三、使用步骤（代码示例）" class="headerlink" title="三、使用步骤（代码示例）"></a>三、使用步骤（代码示例）</h4><h5 id="示例-1：单任务提交与结果获取"><a href="#示例-1：单任务提交与结果获取" class="headerlink" title="示例 1：单任务提交与结果获取"></a>示例 1：单任务提交与结果获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableExecutorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建线程池（此处用固定大小线程池，核心线程数2）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建Callable任务（计算1~100的和）</span></span><br><span class="line">        Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务执行线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum; <span class="comment">// 返回计算结果</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 提交任务到线程池，获取Future对象（绑定任务结果）</span></span><br><span class="line">        Future&lt;Integer&gt; future = threadPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 阻塞获取结果（等待任务完成）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;1~100的和：&quot;</span> + result); <span class="comment">// 输出：5050</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭线程池（必须手动关闭，否则程序不退出）</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例-2：多任务并发提交与批量获取结果"><a href="#示例-2：多任务并发提交与批量获取结果" class="headerlink" title="示例 2：多任务并发提交与批量获取结果"></a>示例 2：多任务并发提交与批量获取结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiCallableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建线程池（核心线程数3）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建多个Callable任务（计算不同范围的和）</span></span><br><span class="line">        List&lt;Callable&lt;Integer&gt;&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        tasks.add(() -&gt; calculateSum(<span class="number">1</span>, <span class="number">100</span>));  <span class="comment">// 任务1：1~100</span></span><br><span class="line">        tasks.add(() -&gt; calculateSum(<span class="number">101</span>, <span class="number">200</span>)); <span class="comment">// 任务2：101~200</span></span><br><span class="line">        tasks.add(() -&gt; calculateSum(<span class="number">201</span>, <span class="number">300</span>)); <span class="comment">// 任务3：201~300</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 批量提交任务，获取所有Future</span></span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; futures = threadPool.invokeAll(tasks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 遍历Future，获取每个任务的结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; future : futures) &#123;</span><br><span class="line">            total += future.get(); <span class="comment">// 累加每个任务的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总和：&quot;</span> + total); <span class="comment">// 输出：(5050 + 15050 + 25050) = 45150</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工具方法：计算start到end的和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSum</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 计算：&quot;</span> + start + <span class="string">&quot;~&quot;</span> + end + <span class="string">&quot; 的和为：&quot;</span> + sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、核心特点"><a href="#四、核心特点" class="headerlink" title="四、核心特点"></a>四、核心特点</h4><ol><li><strong>带返回值的并发任务</strong>：相比 <code>Runnable</code>，<code>Callable</code> 可通过 <code>Future.get()</code> 获取任务结果，满足需要异步计算并返回结果的场景（如多任务并行计算后汇总）。</li><li><strong>线程复用</strong>：通过 <code>ExecutorService</code> 线程池管理线程，避免频繁创建 &#x2F; 销毁线程的性能开销。</li><li><strong>异常处理</strong>：<code>call()</code> 方法声明的异常会被 <code>Future</code> 捕获，调用 <code>get()</code> 时需处理 <code>ExecutionException</code>（包装任务异常）。</li><li><strong>阻塞获取结果</strong>：<code>future.get()</code> 会阻塞当前线程，直到任务完成；也可通过 <code>future.isDone()</code> 先判断任务是否完成，避免不必要的阻塞。</li></ol><h4 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h4><ol><li><strong>线程池关闭</strong>：任务执行完毕后必须调用 <code>shutdown()</code> 关闭线程池，否则核心线程会一直存活，导致程序无法退出。</li><li><strong>批量任务处理</strong>：使用 <code>invokeAll(tasks)</code> 可批量提交任务，返回所有 <code>Future</code> 的列表，适合需要等待所有任务完成后汇总结果的场景。</li><li><strong>任务取消</strong>：若需取消未执行的任务，可调用 <code>future.cancel(true)</code>（<code>true</code> 表示中断正在执行的任务）。</li></ol><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p><code>Callable + ExecutorService</code> 是多线程并发处理带返回值任务的最佳实践：</p><ul><li><code>Callable</code> 定义有返回值的任务逻辑；</li><li><code>ExecutorService</code> 提供线程池管理，高效执行任务；</li><li><code>Future</code> 跟踪任务状态并获取结果。</li></ul><p>适用于并行计算、异步查询、多任务结果汇总等场景，兼顾性能与灵活性。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Callable + FutureTask 创建线程（带返回值）笔记</title>
      <link href="/posts/20193.html"/>
      <url>/posts/20193.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、核心作用"><a href="#一、核心作用" class="headerlink" title="一、核心作用"></a>一、核心作用</h4><p><code>Callable</code> 是带返回值的线程任务接口，配合 <code>FutureTask</code> 可实现 “有返回值的多线程操作”，弥补了 <code>Runnable</code> 无返回值的不足。</p><h4 id="二、关键组件"><a href="#二、关键组件" class="headerlink" title="二、关键组件"></a>二、关键组件</h4><ol><li><p><strong><code>Callable&lt;V&gt;</code> 接口</strong></p><ul><li>泛型接口，<code>V</code> 表示返回值类型。</li><li>需重写 <code>call()</code> 方法（线程执行体），有返回值且可声明抛出异常。</li></ul></li><li><p><strong><code>FutureTask&lt;V&gt;</code> 类</strong></p><ul><li>包装 <code>Callable</code> 任务，实现 <code>Runnable</code> 接口（可被线程执行）。</li><li>提供 <code>get()</code> 方法，用于获取 <code>call()</code> 的返回值（阻塞等待任务完成）。</li></ul></li></ol><h4 id="三、使用步骤（代码示例）"><a href="#三、使用步骤（代码示例）" class="headerlink" title="三、使用步骤（代码示例）"></a>三、使用步骤（代码示例）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 Callable 任务（带返回值的逻辑）</span></span><br><span class="line">        Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 用 FutureTask 包装任务（承载结果的容器）</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 启动线程执行任务（FutureTask 实现了 Runnable）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 阻塞获取任务结果（等待任务完成后返回）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(result); <span class="comment">// 输出：和是：4950</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====运行完毕=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义带返回值的线程任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// 可抛异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i; <span class="comment">// 计算 0~99 的和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;和是：&quot;</span> + sum; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、核心特点"><a href="#四、核心特点" class="headerlink" title="四、核心特点"></a>四、核心特点</h4><ol><li><strong>有返回值</strong>：通过 <code>call()</code> 方法返回结果，<code>FutureTask.get()</code> 获取。</li><li><strong>可抛异常</strong>：<code>call()</code> 可声明异常，<code>get()</code> 会抛出 <code>ExecutionException</code> 包装异常。</li><li><strong>阻塞获取</strong>：<code>get()</code> 会阻塞当前线程，直到任务执行完毕。</li></ol><h4 id="五、适用场景"><a href="#五、适用场景" class="headerlink" title="五、适用场景"></a>五、适用场景</h4><p>需要线程执行后返回结果的场景（如计算任务、数据查询、异步处理等）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Callable + FutureTask</code> 是实现 “带返回值线程” 的标准方式，通过 <code>FutureTask</code> 桥接 <code>Callable</code> 与线程，既保留了多线程的并发能力，又能方便地获取任务结果。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列（以 ArrayBlockingQueue 为例）笔记</title>
      <link href="/posts/49155.html"/>
      <url>/posts/49155.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、什么是阻塞队列？"><a href="#一、什么是阻塞队列？" class="headerlink" title="一、什么是阻塞队列？"></a>一、什么是阻塞队列？</h4><p>阻塞队列（BlockingQueue）是 Java 并发包中一种特殊的队列，它在普通队列的基础上增加了 <strong>阻塞功能</strong>：</p><ul><li>当队列满时，生产者线程会阻塞等待（无法插入元素）；</li><li>当队列空时，取元素的线程会阻塞等待（无法获取元素）。</li></ul><p>这种特性使其非常适合 <strong>生产者 - 消费者模型</strong>，无需手动处理线程同步，简化了多线程协作。</p><h4 id="二、核心特性（以代码中的-ArrayBlockingQueue-为例）"><a href="#二、核心特性（以代码中的-ArrayBlockingQueue-为例）" class="headerlink" title="二、核心特性（以代码中的 ArrayBlockingQueue 为例）"></a>二、核心特性（以代码中的 ArrayBlockingQueue 为例）</h4><ol><li><p><strong>有界队列</strong>：</p><p> <code>ArrayBlockingQueue</code> 是 <strong>有界队列</strong>（初始化时必须指定容量，如代码中 <code>new ArrayBlockingQueue&lt;&gt;(10)</code> 表示容量为 10），一旦队列满，生产者线程会被阻塞。</p></li><li><p><strong>阻塞插入与取出</strong>：</p><ul><li><strong>插入元素</strong>：<code>put()</code> 方法在队列满时会阻塞线程，直到队列有空闲位置；</li><li><strong>取出元素</strong>：<code>take()</code> 方法在队列空时会阻塞线程，直到队列中有元素。</li></ul><p> （代码中：生产者用 <code>put()</code> 放数据，消费者用 <code>take()</code> 取数据，自动实现了 “生产 - 消费” 的同步）</p></li></ol><h4 id="三、代码中的生产者-消费者模型"><a href="#三、代码中的生产者-消费者模型" class="headerlink" title="三、代码中的生产者 - 消费者模型"></a>三、代码中的生产者 - 消费者模型</h4><ol><li><p><strong>生产者（Producter）</strong>：</p><p> 循环生成随机整数，通过 <code>q.put(...)</code> 放入队列。若队列已满（达到 10 个元素），<code>put()</code> 会阻塞生产者线程，直到消费者取走元素后才继续放入。</p></li><li><p><strong>消费者（Consumer）</strong>：</p><p> 每 200ms 循环从队列中用 <code>q.take(...)</code> 取元素并打印。若队列空，<code>take()</code> 会阻塞消费者线程，直到生产者放入新元素后才继续取出。</p></li><li><p><strong>自动协调</strong>：</p><p> 无需额外加锁（如 <code>synchronized</code> 或 <code>Lock</code>），阻塞队列内部已实现线程安全，自动协调生产者和消费者的速度（生产快了就等消费，消费快了就等生产）。</p></li></ol><h4 id="四、常见阻塞队列及特点"><a href="#四、常见阻塞队列及特点" class="headerlink" title="四、常见阻塞队列及特点"></a>四、常见阻塞队列及特点</h4><table><thead><tr><th>阻塞队列类型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><code>ArrayBlockingQueue</code></td><td>基于数组实现，有界，初始化需指定容量</td><td>固定大小的生产者 - 消费者模型</td></tr><tr><td><code>LinkedBlockingQueue</code></td><td>基于链表实现，默认无界（可指定容量）</td><td>任务队列（如线程池任务队列）</td></tr><tr><td><code>SynchronousQueue</code></td><td>无容量，放入元素后必须等待被取走</td><td>线程间直接传递数据</td></tr><tr><td><code>PriorityBlockingQueue</code></td><td>支持优先级排序，无界</td><td>按优先级处理任务</td></tr></tbody></table><h4 id="五、核心方法"><a href="#五、核心方法" class="headerlink" title="五、核心方法"></a>五、核心方法</h4><p>阻塞队列的方法分为三类（以插入和取出为例）：</p><table><thead><tr><th>操作类型</th><th>满队列时的行为</th><th>空队列时的行为</th><th>示例方法</th></tr></thead><tbody><tr><td>阻塞式</td><td>阻塞等待</td><td>阻塞等待</td><td><code>put(e)</code>、<code>take()</code></td></tr><tr><td>非阻塞式</td><td>返回 false 或抛出异常</td><td>返回 null 或抛出异常</td><td><code>add(e)</code>、<code>remove()</code></td></tr><tr><td>超时式</td><td>超时后返回 false</td><td>超时后返回 null</td><td><code>offer(e, timeout)</code>、<code>poll(timeout)</code></td></tr></tbody></table><p>代码中使用的 <code>put()</code> 和 <code>take()</code> 是 <strong>阻塞式方法</strong>，最适合需要等待的场景。</p><h4 id="六、优点"><a href="#六、优点" class="headerlink" title="六、优点"></a>六、优点</h4><ol><li><strong>线程安全</strong>：内部实现了同步机制（如 <code>ReentrantLock</code>），无需手动处理锁；</li><li><strong>简化协作</strong>：自动处理生产者 - 消费者的速度匹配（满则等、空则等）；</li><li><strong>高效</strong>：比手动用锁实现的队列更简洁，性能更稳定。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>阻塞队列是多线程协作的重要工具，尤其适合生产者 - 消费者模型。<code>ArrayBlockingQueue</code> 作为有界队列，通过 <code>put()</code> 和 <code>take()</code> 的阻塞特性，轻松实现了生产与消费的同步，避免了线程安全问题和复杂的锁管理。</p><hr><p>代码：</p><p>以下是阻塞队列（<code>ArrayBlockingQueue</code> 及其他常用实现）的代码示例，结合不同场景展示其用法：</p><h3 id="示例-1：基础生产者-消费者模型（ArrayBlockingQueue）"><a href="#示例-1：基础生产者-消费者模型（ArrayBlockingQueue）" class="headerlink" title="示例 1：基础生产者 - 消费者模型（ArrayBlockingQueue）"></a>示例 1：基础生产者 - 消费者模型（ArrayBlockingQueue）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建容量为3的有界阻塞队列</span></span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动1个生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(queue), <span class="string">&quot;生产者&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 启动1个消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(queue), <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者：向队列中放入数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(ArrayBlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>); <span class="comment">// 生成随机数</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(num); <span class="comment">// 队列满时阻塞</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 放入：&quot;</span> + num + <span class="string">&quot;，当前队列大小：&quot;</span> + queue.size());</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者：从队列中取数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(ArrayBlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue.take(); <span class="comment">// 队列空时阻塞</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 取出：&quot;</span> + num + <span class="string">&quot;，当前队列大小：&quot;</span> + queue.size());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟消费耗时（比生产慢）</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong>：</p><ul><li>生产者每 500ms 放一个数据，消费者每 1000ms 取一个数据；</li><li>当队列满（3 个元素）时，生产者会阻塞等待，直到消费者取走数据后再继续放入；</li><li>输出类似：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">生产者 放入：45，当前队列大小：1</span><br><span class="line">消费者 取出：45，当前队列大小：0</span><br><span class="line">生产者 放入：72，当前队列大小：1</span><br><span class="line">生产者 放入：33，当前队列大小：2</span><br><span class="line">消费者 取出：72，当前队列大小：1</span><br><span class="line">生产者 放入：18，当前队列大小：2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="示例-2：非阻塞与超时方法（ArrayBlockingQueue）"><a href="#示例-2：非阻塞与超时方法（ArrayBlockingQueue）" class="headerlink" title="示例 2：非阻塞与超时方法（ArrayBlockingQueue）"></a>示例 2：非阻塞与超时方法（ArrayBlockingQueue）</h3><p>展示阻塞队列的三类方法（阻塞、非阻塞、超时）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueMethods</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 阻塞式方法：put（满则等）、take（空则等）</span></span><br><span class="line">        queue.put(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        queue.put(<span class="string">&quot;B&quot;</span>); <span class="comment">// 队列已满，再put会阻塞（此处若再加put会卡住）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阻塞式放入后：&quot;</span> + queue); <span class="comment">// [A, B]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> queue.take();</span><br><span class="line">        System.out.println(<span class="string">&quot;阻塞式取出：&quot;</span> + s1 + <span class="string">&quot;，剩余：&quot;</span> + queue); <span class="comment">// [B]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 非阻塞式方法：add（满则抛异常）、remove（空则抛异常）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">addOk</span> <span class="operator">=</span> queue.add(<span class="string">&quot;C&quot;</span>); <span class="comment">// 队列有空间，添加成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;add成功：&quot;</span> + addOk + <span class="string">&quot;，队列：&quot;</span> + queue); <span class="comment">// [B, C]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(<span class="string">&quot;D&quot;</span>); <span class="comment">// 队列已满，add会抛IllegalStateException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add失败：队列已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 超时式方法：offer（满则等超时）、poll（空则等超时）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">offerOk</span> <span class="operator">=</span> queue.offer(<span class="string">&quot;D&quot;</span>, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 等待1秒，若仍满则返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;offer超时后是否成功：&quot;</span> + offerOk); <span class="comment">// false（1秒内队列未空）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> queue.poll(<span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 等待1秒，取出B</span></span><br><span class="line">        System.out.println(<span class="string">&quot;poll超时取出：&quot;</span> + s2 + <span class="string">&quot;，剩余：&quot;</span> + queue); <span class="comment">// [C]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例-3：无界队列（LinkedBlockingQueue）"><a href="#示例-3：无界队列（LinkedBlockingQueue）" class="headerlink" title="示例 3：无界队列（LinkedBlockingQueue）"></a>示例 3：无界队列（LinkedBlockingQueue）</h3><p><code>LinkedBlockingQueue</code> 默认无界（容量为 <code>Integer.MAX_VALUE</code>），适合任务数不确定的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 无界队列（默认容量极大，可视为无限）</span></span><br><span class="line">        LinkedBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速放入1000个元素（不会阻塞，因为无界）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            queue.put(<span class="string">&quot;任务&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;放入1000个任务后，队列大小：&quot;</span> + queue.size()); <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出第一个任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;取出：&quot;</span> + queue.take()); <span class="comment">// 任务0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例-4：同步队列（SynchronousQueue）"><a href="#示例-4：同步队列（SynchronousQueue）" class="headerlink" title="示例 4：同步队列（SynchronousQueue）"></a>示例 4：同步队列（SynchronousQueue）</h3><p><code>SynchronousQueue</code> 容量为 0，放入元素后必须等待被取走才能继续：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SynchronousQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程：放入元素后会阻塞，直到被取走</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者：准备放入数据&quot;</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;同步数据&quot;</span>); <span class="comment">// 必须等待消费者取走，否则一直阻塞</span></span><br><span class="line">                System.out.println(<span class="string">&quot;生产者：数据被取走，继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程：1秒后取数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 延迟1秒</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> queue.take(); <span class="comment">// 取走数据，释放生产者</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消费者：取出数据：&quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong>：</p><p>生产者放入数据后阻塞 1 秒，直到消费者取走数据才继续执行。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>阻塞队列通过内置的阻塞机制，简化了多线程协作：</p><ul><li><code>ArrayBlockingQueue</code> 适合固定容量场景，生产者 - 消费者速度匹配；</li><li><code>LinkedBlockingQueue</code> 适合任务数不确定的场景；</li><li><code>SynchronousQueue</code> 适合线程间直接传递数据（无缓冲）；</li><li>核心方法分为阻塞式（<code>put/take</code>）、非阻塞式（<code>add/remove</code>）、超时式（<code>offer/poll</code>），根据场景选择即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AtomicInteger 笔记</title>
      <link href="/posts/64144.html"/>
      <url>/posts/64144.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、什么是-AtomicInteger？"><a href="#一、什么是-AtomicInteger？" class="headerlink" title="一、什么是 AtomicInteger？"></a>一、什么是 AtomicInteger？</h4><p><code>AtomicInteger</code> 是 Java 并发包（<code>java.util.concurrent.atomic</code>）中的原子类，用于在 <strong>多线程环境下安全地进行整数的原子操作</strong>（如自增、自减、赋值等），避免了使用 <code>synchronized</code> 锁的性能开销。</p><h4 id="二、核心作用"><a href="#二、核心作用" class="headerlink" title="二、核心作用"></a>二、核心作用</h4><p>解决多线程对整数变量进行 <strong>复合操作（如 <code>i++</code>、<code>i = i + 2</code>）时的线程安全问题</strong>。</p><ul><li>普通 <code>int</code> 的 <code>i++</code> 是 “读 - 改 - 写” 三步操作，非原子性，多线程并发时会导致结果错误；</li><li><code>AtomicInteger</code> 通过 <strong>CAS 机制</strong> 保证这些操作的原子性（一步完成，不可打断）。</li></ul><h4 id="三、底层实现：CAS-机制"><a href="#三、底层实现：CAS-机制" class="headerlink" title="三、底层实现：CAS 机制"></a>三、底层实现：CAS 机制</h4><p>CAS（Compare-And-Swap，比较并交换）是一种无锁同步技术，核心逻辑：</p><ol><li>读取变量当前值（<code>expectedValue</code>）；</li><li>计算目标值（<code>newValue</code>）；</li><li>若当前值仍为 <code>expectedValue</code>（未被其他线程修改），则更新为 <code>newValue</code>；否则重试（自旋），直到成功。</li></ol><p><code>AtomicInteger</code> 内部通过 <code>volatile int value</code> 存储值（保证可见性），配合 CAS 完成原子操作。</p><h4 id="四、常用方法"><a href="#四、常用方法" class="headerlink" title="四、常用方法"></a>四、常用方法</h4><table><thead><tr><th>方法名</th><th>功能描述</th><th>示例（初始值为 5）</th></tr></thead><tbody><tr><td><code>get()</code></td><td>获取当前值</td><td><code>get()</code> → 5</td></tr><tr><td><code>set(int newValue)</code></td><td>设置为新值（直接覆盖）</td><td><code>set(10)</code> → 后续 <code>get()</code> 为 10</td></tr><tr><td><code>getAndIncrement()</code></td><td>先返回当前值，再自增 1</td><td><code>getAndIncrement()</code> → 返回 5，值变为 6</td></tr><tr><td><code>incrementAndGet()</code></td><td>先自增 1，再返回新值</td><td><code>incrementAndGet()</code> → 返回 6，值变为 6</td></tr><tr><td><code>getAndDecrement()</code></td><td>先返回当前值，再自减 1</td><td><code>getAndDecrement()</code> → 返回 5，值变为 4</td></tr><tr><td><code>decrementAndGet()</code></td><td>先自减 1，再返回新值</td><td><code>decrementAndGet()</code> → 返回 4，值变为 4</td></tr><tr><td><code>getAndAdd(int delta)</code></td><td>先返回当前值，再加 delta</td><td><code>getAndAdd(3)</code> → 返回 5，值变为 8</td></tr><tr><td><code>addAndGet(int delta)</code></td><td>先加 delta，再返回新值</td><td><code>addAndGet(3)</code> → 返回 8，值变为 8</td></tr><tr><td><code>compareAndSet(int expect, int update)</code></td><td>若当前值等于 expect，则更新为 update，返回是否成功</td><td><code>compareAndSet(5, 10)</code> → 返回 true，值变为 10</td></tr></tbody></table><h4 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h4><ol><li><strong>多线程计数</strong>：如统计请求量、下载进度等（替代 <code>synchronized</code> 修饰的计数逻辑）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 30个线程各自增10000次，结果一定是300000</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">            sum.incrementAndGet(); <span class="comment">// 原子自增</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>线程安全的状态标记</strong>：如用 <code>compareAndSet</code> 实现无锁的状态更新。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 0：初始，1：运行，2：结束</span></span><br><span class="line"><span class="comment">// 只有当状态为0时，才更新为1（避免重复启动）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="六、优缺点"><a href="#六、优缺点" class="headerlink" title="六、优缺点"></a>六、优缺点</h4><ul><li><p><strong>优点</strong>：</p><p>  性能优于 <code>synchronized</code>（无锁机制，减少线程阻塞 &#x2F; 唤醒开销），适合高并发场景。</p></li><li><p><strong>缺点</strong>：</p><ol><li>仅支持整数类型（其他原子类如 <code>AtomicLong</code>、<code>AtomicBoolean</code> 可覆盖其他基本类型）；</li><li>复合操作（如 <code>i = i * 2 + 1</code>）无法直接保证原子性，需配合 <code>compareAndSet</code> 循环实现；</li><li>高并发下 CAS 自旋可能导致 CPU 消耗较高。</li></ol></li></ul><h4 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h4><ul><li><code>AtomicInteger</code> 是多线程环境下安全操作整数的首选工具，基于 CAS 实现原子性。</li><li>核心优势：高效解决简单整数操作的线程安全问题，性能优于传统锁。</li><li>适用场景：计数、状态标记等简单原子操作，复杂逻辑需结合其他同步工具。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile 关键字笔记</title>
      <link href="/posts/2131.html"/>
      <url>/posts/2131.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、什么是-volatile？"><a href="#一、什么是-volatile？" class="headerlink" title="一、什么是 volatile？"></a>一、什么是 volatile？</h4><p><code>volatile</code> 是 Java 中的一个关键字，用于修饰变量，保证变量的 <strong>可见性</strong> 和 <strong>禁止指令重排序</strong>，但不保证原子性。</p><h4 id="二、核心特性"><a href="#二、核心特性" class="headerlink" title="二、核心特性"></a>二、核心特性</h4><ol><li><p><strong>可见性</strong></p><p> 当一个变量被 <code>volatile</code> 修饰时，线程对该变量的修改会 <strong>立即被其他线程看到</strong>。</p><ul><li>原理：线程修改 <code>volatile</code> 变量后，会强制将修改后的值刷新到主内存；其他线程读取时，会直接从主内存加载最新值（而非线程本地缓存）。</li><li>示例：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">// 修改后立即刷新到主内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123; </span><br><span class="line">            <span class="comment">// 每次循环都会从主内存读取flag最新值</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag已变为true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程 A 调用 <code>setFlag()</code> 后，线程 B 的 <code>checkFlag()</code> 会立即感知到 <code>flag</code> 的变化并退出循环。</p><ol start="2"><li><p><strong>禁止指令重排序</strong></p><p> 编译器或 CPU 为优化性能，可能会对代码指令重排序（不影响单线程结果，但可能破坏多线程逻辑）。<code>volatile</code> 会禁止这种重排序，保证代码执行顺序与编写顺序一致。</p><ul><li>典型场景：单例模式的双重检查锁（避免未初始化完成的对象被引用）：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 必须加volatile</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 禁止重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不加 <code>volatile</code>，<code>instance = new Singleton()</code> 可能被拆分为「分配内存→引用指向内存→初始化对象」，重排序后可能导致其他线程拿到未初始化的对象。</p><h4 id="三、不保证原子性"><a href="#三、不保证原子性" class="headerlink" title="三、不保证原子性"></a>三、不保证原子性</h4><p><code>volatile</code> 不能保证复合操作的原子性（如 <code>i++</code>，本质是「读 - 改 - 写」三步）。</p><ul><li>反例：多线程自增 <code>volatile</code> 变量，结果可能小于预期：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileAtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 非原子操作，volatile无法保证线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">VolatileAtomicDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileAtomicDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    demo.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(demo.count); <span class="comment">// 结果可能小于10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>解决：需配合 `synchronized` 或 `AtomicInteger` 保证原子性。</code></pre><h4 id="四、适用场景"><a href="#四、适用场景" class="headerlink" title="四、适用场景"></a>四、适用场景</h4><ol><li><strong>状态标记</strong>：如示例中的 <code>flag</code>，用于线程间简单的状态传递（启动 &#x2F; 停止信号）。</li><li><strong>双重检查锁单例</strong>：禁止指令重排序，保证单例对象正确初始化。</li><li><strong>简单变量的读写</strong>：仅涉及单个变量的读和写（无复合操作）。</li></ol><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><ul><li><code>volatile</code> 是轻量级同步机制，性能优于 <code>synchronized</code>，但功能有限。</li><li>核心作用：<strong>保证可见性、禁止指令重排序</strong>，不保证原子性。</li><li>适合简单的线程间状态同步，复杂场景需结合锁或原子类使用。</li></ul><hr><p>我们用生活化的例子，把 <code>volatile</code> 讲得明明白白：</p><h3 id="一、先搞懂：没有-volatile-会出啥问题？"><a href="#一、先搞懂：没有-volatile-会出啥问题？" class="headerlink" title="一、先搞懂：没有 volatile 会出啥问题？"></a>一、先搞懂：没有 volatile 会出啥问题？</h3><p>电脑里的线程读取变量时，为了速度快，会把主内存的变量 “拷贝” 一份到自己的 “本地缓存”（比如 CPU 缓存）。</p><p>就像你抄作业时，把课本（主内存）的内容抄到笔记本（本地缓存）上，之后直接看笔记本，不回头看课本了。</p><p>这会导致两个问题：</p><ol><li><strong>看不见别人的修改</strong>：如果别人改了课本内容，你没翻课本，永远不知道最新内容；</li><li><strong>自己的操作顺序乱了</strong>：老师布置 “先写数学再写语文”，你为了省时间先写了语文（对应 CPU 指令重排序），单看你自己没问题，但如果和同学协作（多线程）就会出乱子。</li></ol><h3 id="二、volatile-到底是干啥的？"><a href="#二、volatile-到底是干啥的？" class="headerlink" title="二、volatile 到底是干啥的？"></a>二、volatile 到底是干啥的？</h3><p><code>volatile</code> 就像给变量加了两个 “强制规则”，解决上面的问题：</p><h4 id="1-规则-1：保证-“可见性”——-改了必须让所有人知道"><a href="#1-规则-1：保证-“可见性”——-改了必须让所有人知道" class="headerlink" title="1. 规则 1：保证 “可见性”—— 改了必须让所有人知道"></a>1. 规则 1：保证 “可见性”—— 改了必须让所有人知道</h4><p>被 <code>volatile</code> 修饰的变量，线程修改它时，<strong>必须立刻把新值写回课本（主内存）</strong>；其他线程读这个变量时，<strong>必须直接从课本（主内存）读，不能看自己的笔记本（本地缓存）</strong>。</p><p>举个例子：</p><ul><li>线程 A 改了 <code>volatile</code> 变量 <code>flag = true</code>，马上写回主内存；</li><li>线程 B 之前缓存的 <code>flag</code> 是 <code>false</code>，但因为加了 <code>volatile</code>，它会重新去主内存读，立刻知道 <code>flag</code> 变了。</li></ul><p>没有 <code>volatile</code> 的话，线程 A 改完可能先存在自己的缓存里，线程 B 永远看不到，就会一直卡着。</p><h4 id="2-规则-2：禁止-“指令重排序”——-必须按规矩来"><a href="#2-规则-2：禁止-“指令重排序”——-必须按规矩来" class="headerlink" title="2. 规则 2：禁止 “指令重排序”—— 必须按规矩来"></a>2. 规则 2：禁止 “指令重排序”—— 必须按规矩来</h4><p>被 <code>volatile</code> 修饰的变量，涉及它的操作<strong>不能乱序执行</strong>。</p><p>比如单例模式里的 <code>instance = new Singleton()</code>，本质是 3 步：① 分配内存 ② 初始化对象 ③ 把变量指向内存。</p><p>没有 <code>volatile</code> 时，CPU 可能优化成 ①→③→②，导致其他线程拿到 “还没初始化好的对象”；加了 <code>volatile</code> 后，就必须按 ①→②→③ 执行，避免出错。</p><h3 id="三、volatile-的-“短板”：不保证原子性"><a href="#三、volatile-的-“短板”：不保证原子性" class="headerlink" title="三、volatile 的 “短板”：不保证原子性"></a>三、volatile 的 “短板”：不保证原子性</h3><p><code>volatile</code> 只能管 “读” 和 “写单个变量” 的正确性，但管不了 “多步操作”。</p><p>比如 <code>count++</code>，看似简单，实际是 3 步：① 读 <code>count</code> 的值 ② 加 1 ③ 写回新值。这 3 步中间可能被其他线程打断，导致结果出错。</p><p>举个例子：两个线程同时执行 <code>count++</code>（初始值 0）：</p><ol><li>线程 A 读 <code>count=0</code>，还没来得及加 1，线程 B 也读 <code>count=0</code>；</li><li>线程 A 加 1 写回 <code>1</code>，线程 B 加 1 也写回 <code>1</code>；</li><li>最终 <code>count=1</code>，而不是预期的 <code>2</code>。</li></ol><p>解决办法：这种复合操作，得用 <code>synchronized</code> 锁或者 <code>AtomicInteger</code> 这类原子类。</p><h3 id="四、什么时候用-volatile？"><a href="#四、什么时候用-volatile？" class="headerlink" title="四、什么时候用 volatile？"></a>四、什么时候用 volatile？</h3><ol><li><strong>状态标记</strong>：比如用 <code>volatile boolean isStop</code> 控制线程启动 &#x2F; 停止，简单的线程间信号传递；</li><li><strong>单例模式双重检查锁</strong>：必须加 <code>volatile</code> 禁止重排序，避免拿到未初始化的对象；</li><li><strong>简单变量读写</strong>：只涉及单个变量的读和写，没有多步复合操作。</li></ol><h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h3><p><code>volatile</code> 是个 “轻量级同步工具”，专门解决 “线程看不到变量最新值” 和 “操作顺序乱了” 的问题，但管不了多步操作的原子性，复杂场景得搭配锁或原子类使用。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>锁重入（简单理解）</title>
      <link href="/posts/60800.html"/>
      <url>/posts/60800.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是锁重入？"><a href="#什么是锁重入？" class="headerlink" title="什么是锁重入？"></a><strong>什么是锁重入？</strong></h3><p>一个线程拿到锁之后，不用释放，还能再拿同一把锁。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h3><p>你进家门（拿到家门锁），进了客厅后，想进卧室（卧室也用同一把钥匙），不用先把家门钥匙还回去，直接用手里的钥匙开门就行。</p><h3 id="Java-里的情况"><a href="#Java-里的情况" class="headerlink" title="Java 里的情况"></a><strong>Java 里的情况</strong></h3><ol><li><p><strong>synchronized 关键字</strong></p><p> 比如一个同步方法 A 里调用了另一个同步方法 B，且两者用的是同一把锁（比如都是同一个对象的锁），线程进了 A 之后，能直接进 B，不用等自己释放 A 的锁。</p></li><li><p><strong>ReentrantLock 锁</strong></p><p> 手动加锁时，线程第一次<code>lock()</code>拿到锁后，还能再<code>lock()</code>一次（重入），但要记得解锁同样多次（<code>unlock()</code>），最后一次解锁后，其他线程才能抢。</p></li></ol><h3 id="为什么需要它？"><a href="#为什么需要它？" class="headerlink" title="为什么需要它？"></a><strong>为什么需要它？</strong></h3><p>避免死锁。如果不支持重入，线程进了 A 之后想进 B，就得先放 A 的锁，可自己还拿着 A 的锁呢，就会卡住（死锁）。</p><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a><strong>关键点</strong></h3><ul><li>必须是「同一把锁」才能重入，不同的锁不行。</li><li>ReentrantLock 要记得加几次锁就解几次，不然锁会一直被占着。</li></ul><p>以下是几个直观的锁重入代码示例，分别展示 <code>synchronized</code> 和 <code>ReentrantLock</code> 的重入特性：</p><h3 id="示例-1：synchronized-方法的重入（同一对象锁）"><a href="#示例-1：synchronized-方法的重入（同一对象锁）" class="headerlink" title="示例 1：synchronized 方法的重入（同一对象锁）"></a>示例 1：synchronized 方法的重入（同一对象锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncReentrantDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程调用test1()，会触发嵌套的同步方法调用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            test1(); <span class="comment">// 调用同步方法test1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步方法1（锁是当前Task对象）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入test1&quot;</span>);</span><br><span class="line">            test2(); <span class="comment">// 调用同步方法test2（同一把锁）</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开test1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步方法2（锁也是当前Task对象）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入test2&quot;</span>);</span><br><span class="line">            test3(); <span class="comment">// 继续调用同步方法test3（同一把锁）</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开test2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步方法3（同一把锁）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入test3&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开test3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>（同一线程连续进入 3 个同步方法，体现重入）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 进入test1</span><br><span class="line">Thread-0 进入test2</span><br><span class="line">Thread-0 进入test3</span><br><span class="line">Thread-0 离开test3</span><br><span class="line">Thread-0 离开test2</span><br><span class="line">Thread-0 离开test1</span><br></pre></td></tr></table></figure><h3 id="示例-2：synchronized-代码块的重入（同一锁对象）"><a href="#示例-2：synchronized-代码块的重入（同一锁对象）" class="headerlink" title="示例 2：synchronized 代码块的重入（同一锁对象）"></a>示例 2：synchronized 代码块的重入（同一锁对象）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncBlockReentrantDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 第一次获取lock锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;外层代码块：拿到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 再次获取同一把lock锁（重入）</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;内层代码块：再次拿到锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;外层代码块：释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>（同一线程在嵌套代码块中重复获取锁）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">外层代码块：拿到锁</span><br><span class="line">内层代码块：再次拿到锁</span><br><span class="line">外层代码块：释放锁</span><br></pre></td></tr></table></figure><h3 id="示例-3：ReentrantLock-的重入（显式锁）"><a href="#示例-3：ReentrantLock-的重入（显式锁）" class="headerlink" title="示例 3：ReentrantLock 的重入（显式锁）"></a>示例 3：ReentrantLock 的重入（显式锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 第一次加锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第一次加锁，计数器：&quot;</span> + lock.getHoldCount());</span><br><span class="line">                method1(); <span class="comment">// 调用方法再次加锁</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// 最后一次解锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;最终解锁后，计数器：&quot;</span> + lock.getHoldCount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 第二次加锁（重入）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二次加锁，计数器：&quot;</span> + lock.getHoldCount());</span><br><span class="line">            method2(); <span class="comment">// 继续加锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 第二次解锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第二次解锁后，计数器：&quot;</span> + lock.getHoldCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 第三次加锁（重入）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第三次加锁，计数器：&quot;</span> + lock.getHoldCount());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 第三次解锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第三次解锁后，计数器：&quot;</span> + lock.getHoldCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>（通过 <code>getHoldCount()</code> 查看锁计数器变化，体现重入次数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次加锁，计数器：1</span><br><span class="line">第二次加锁，计数器：2</span><br><span class="line">第三次加锁，计数器：3</span><br><span class="line">第三次解锁后，计数器：2</span><br><span class="line">第二次解锁后，计数器：1</span><br><span class="line">最终解锁后，计数器：0</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>锁重入的核心是「同一线程重复获取同一把锁」，无需释放后再获取。</li><li><code>synchronized</code> 自动维护重入计数器，<code>ReentrantLock</code> 需手动保证 <code>lock()</code> 和 <code>unlock()</code> 次数一致（否则锁无法释放）。</li><li>嵌套调用同步方法 &#x2F; 代码块时，重入特性避免了线程自己等自己的死锁问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantReadWriteLock 笔记及读写者问题实现</title>
      <link href="/posts/10736.html"/>
      <url>/posts/10736.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、ReentrantReadWriteLock-核心概念"><a href="#一、ReentrantReadWriteLock-核心概念" class="headerlink" title="一、ReentrantReadWriteLock 核心概念"></a>一、ReentrantReadWriteLock 核心概念</h4><p><code>ReentrantReadWriteLock</code> 是 Java 并发包中用于解决读写者问题的同步工具，基于「读写分离锁」设计，包含两把锁：</p><ul><li><strong>读锁（SharedLock）</strong>：允许多个线程同时获取，适合读操作（共享资源）。</li><li><strong>写锁（ExclusiveLock）</strong>：仅允许一个线程获取，适合写操作（独占资源）。</li></ul><p>其核心特性是<strong>读写互斥、写写互斥、读读共享</strong>，完美满足读写者问题的 3 个基本要求。</p><h4 id="二、锁的获取条件"><a href="#二、锁的获取条件" class="headerlink" title="二、锁的获取条件"></a>二、锁的获取条件</h4><ol><li><p><strong>获取读锁的前提</strong>：</p><ul><li>没有线程持有写锁；</li><li>若有写请求，仅当当前线程是持有写锁的线程时（可重入）才能获取读锁。</li></ul></li><li><p><strong>获取写锁的前提</strong>：</p><ul><li>没有线程持有读锁；</li><li>没有线程持有写锁；</li><li>当前线程可重入（已持有写锁时可再次获取）。</li></ul></li></ol><h4 id="三、公平性策略"><a href="#三、公平性策略" class="headerlink" title="三、公平性策略"></a>三、公平性策略</h4><p><code>ReentrantReadWriteLock</code> 支持两种模式（通过构造函数指定）：</p><ul><li><strong>非公平模式（默认）</strong>：读操作可能优先于写操作（读者可能持续抢占，导致写者饥饿）。</li><li><strong>公平模式</strong>：按线程请求顺序获取锁（实现「弱写者优先 &#x2F; 公平竞争」，避免饥饿）。</li></ul><h4 id="四、核心方法"><a href="#四、核心方法" class="headerlink" title="四、核心方法"></a>四、核心方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>readLock()</code></td><td>获取读锁（<code>Lock</code> 接口实例）</td></tr><tr><td><code>writeLock()</code></td><td>获取写锁（<code>Lock</code> 接口实例）</td></tr><tr><td><code>getReadLockCount()</code></td><td>当前持有读锁的线程数（重入会累加）</td></tr><tr><td><code>isWriteLocked()</code></td><td>判断写锁是否被持有</td></tr></tbody></table><h4 id="五、公平竞争模式下的读写者问题实现"><a href="#五、公平竞争模式下的读写者问题实现" class="headerlink" title="五、公平竞争模式下的读写者问题实现"></a>五、公平竞争模式下的读写者问题实现</h4><p>以下代码通过 <code>ReentrantReadWriteLock</code> 的公平模式，实现「弱写者优先（公平竞争）」的读写者问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 ReentrantReadWriteLock 实现公平竞争的读写者问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 共享资源（模拟需要读写的数据）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 公平模式的读写锁（true 表示公平）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 读锁（共享）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line">    <span class="comment">// 写锁（独占）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作：获取读锁，读取数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始读数据，当前数据：&quot;</span> + data);</span><br><span class="line">            <span class="comment">// 模拟读操作耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读完数据&quot;</span>);</span><br><span class="line">            readLock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作：获取写锁，修改数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        writeLock.lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始写数据，新数据：&quot;</span> + newData);</span><br><span class="line">            <span class="comment">// 模拟写操作耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写完数据&quot;</span>);</span><br><span class="line">            writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReadWriteDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadWriteDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 3 个读者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 持续读</span></span><br><span class="line">                    demo.read();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 读间隔</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Reader-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 2 个写者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 持续写</span></span><br><span class="line">                    demo.write(value + num * <span class="number">100</span>); <span class="comment">// 写不同的数据区分</span></span><br><span class="line">                    value++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 写间隔</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Writer-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、代码说明"><a href="#六、代码说明" class="headerlink" title="六、代码说明"></a>六、代码说明</h4><ol><li><strong>共享资源</strong>：<code>data</code> 变量模拟需要并发读写的数据。</li><li><strong>锁初始化</strong>：<code>ReentrantReadWriteLock(true)</code> 表示公平模式，线程按请求顺序获取锁。</li><li><strong>读操作</strong>：通过 <code>readLock</code> 保证多个读者可同时读取，读取时阻塞写者。</li><li><strong>写操作</strong>：通过 <code>writeLock</code> 保证独占写入，写入时阻塞所有读者和其他写者。</li><li><strong>公平性体现</strong>：写者不会被读者持续抢占（非公平模式可能出现），符合「公平竞争」要求。</li></ol><h4 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a>七、注意事项</h4><ul><li><strong>重入性</strong>：读锁和写锁都支持重入（同一线程可多次获取），但读锁不能升级为写锁（避免死锁）。</li><li><strong>性能</strong>：读操作频繁时，读写锁效率远高于 <code>ReentrantLock</code>（减少锁竞争）；写操作频繁时，优势不明显。</li><li><strong>饥饿问题</strong>：非公平模式可能导致写者饥饿，公平模式通过排队解决，但性能略低。</li></ul><p>通过 <code>ReentrantReadWriteLock</code>，可简洁高效地解决读写者问题的各种场景（读者优先、公平竞争）。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IOC 容器启动核心十二步笔记（附 Spring 源码辅助）</title>
      <link href="/posts/7015.html"/>
      <url>/posts/7015.html</url>
      
        <content type="html"><![CDATA[<p>IOC 容器是 Spring 框架的核心，其启动过程本质是<strong>资源加载、Bean 定义解析、容器初始化、Bean 实例化与依赖注入</strong>的完整流程。以 Spring 的<code>AbstractApplicationContext</code>为核心实现类，梳理启动核心十二步，结合关键源码深入理解。</p><h2 id="一、容器启动十二步核心流程"><a href="#一、容器启动十二步核心流程" class="headerlink" title="一、容器启动十二步核心流程"></a>一、容器启动十二步核心流程</h2><h3 id="第一步：初始化-ApplicationContext-容器实例"><a href="#第一步：初始化-ApplicationContext-容器实例" class="headerlink" title="第一步：初始化 ApplicationContext 容器实例"></a>第一步：初始化 ApplicationContext 容器实例</h3><ul><li><strong>核心作用</strong>：创建 IOC 容器的基础实例，指定配置源（如 XML 文件、注解配置类），初始化容器的基本属性（如资源加载器、环境变量）。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以ClassPathXmlApplicationContext为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    setConfigLocations(configLocations); <span class="comment">// 设置配置文件路径</span></span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh(); <span class="comment">// 核心启动方法，后续步骤均在其中执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：容器实例创建后，通过<code>refresh()</code>方法触发后续所有启动流程，这是 Spring IOC 启动的入口。</li></ul><h3 id="第二步：准备刷新容器（prepareRefresh）"><a href="#第二步：准备刷新容器（prepareRefresh）" class="headerlink" title="第二步：准备刷新容器（prepareRefresh）"></a>第二步：准备刷新容器（prepareRefresh）</h3><ul><li><strong>核心作用</strong>：初始化容器的刷新状态，验证环境变量，初始化属性源（PropertySource）。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 设置容器启动时间和刷新状态</span></span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化环境（验证必要的环境变量）</span></span><br><span class="line">    initPropertySources();</span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 初始化早期事件监听器集合</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：此步骤为容器刷新做前置准备，确保环境配置合法，避免后续流程因环境问题失败。</li></ul><h3 id="第三步：获取-BeanFactory（obtainFreshBeanFactory）"><a href="#第三步：获取-BeanFactory（obtainFreshBeanFactory）" class="headerlink" title="第三步：获取 BeanFactory（obtainFreshBeanFactory）"></a>第三步：获取 BeanFactory（obtainFreshBeanFactory）</h3><ul><li><strong>核心作用</strong>：创建或刷新 BeanFactory（Spring 的 Bean 工厂，负责 Bean 的创建与管理），加载配置资源并解析为 BeanDefinition。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    refreshBeanFactory(); <span class="comment">// 刷新BeanFactory，核心是创建DefaultListableBeanFactory</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractRefreshableApplicationContext的refreshBeanFactory实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory(); <span class="comment">// 创建核心BeanFactory实例</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory); <span class="comment">// 定制BeanFactory（如是否允许循环引用）</span></span><br><span class="line">        loadBeanDefinitions(beanFactory); <span class="comment">// 加载并解析BeanDefinition（关键步骤）</span></span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：<code>DefaultListableBeanFactory</code>是 Spring 默认的 BeanFactory 实现，后续所有 Bean 操作均基于此实例。</li></ul><h3 id="第四步：准备-BeanFactory（prepareBeanFactory）"><a href="#第四步：准备-BeanFactory（prepareBeanFactory）" class="headerlink" title="第四步：准备 BeanFactory（prepareBeanFactory）"></a>第四步：准备 BeanFactory（prepareBeanFactory）</h3><ul><li><strong>核心作用</strong>：对 BeanFactory 进行功能增强，注册容器必要的系统 Bean（如类加载器、环境 Bean），设置 BeanPostProcessor 等。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 设置BeanFactory的类加载器、表达式解析器等基础属性</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 添加Spring内置的BeanPostProcessor</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 忽略部分Aware接口的自动注入（由ApplicationContextAwareProcessor处理）</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 注册系统Bean（如environment、systemProperties）</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;environment&quot;</span>, getEnvironment());</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;systemProperties&quot;</span>, System.getProperties());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：此步骤为 BeanFactory “赋能”，使其具备 Spring 容器的高级特性（如 Aware 接口支持、属性编辑）。</li></ul><h3 id="第五步：BeanFactory-后置处理（postProcessBeanFactory）"><a href="#第五步：BeanFactory-后置处理（postProcessBeanFactory）" class="headerlink" title="第五步：BeanFactory 后置处理（postProcessBeanFactory）"></a>第五步：BeanFactory 后置处理（postProcessBeanFactory）</h3><ul><li><strong>核心作用</strong>：允许子类扩展 BeanFactory 的功能，在 BeanDefinition 加载完成后、Bean 实例化前对 BeanFactory 进行定制。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法，由子类实现（如WebApplicationContext添加Servlet相关Bean）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：AnnotationConfigWebApplicationContext的实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ServletContextAwareProcessor</span>(<span class="built_in">this</span>.servletContext));</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：该步骤是 Spring 的扩展点，用户可通过重写此方法添加自定义逻辑。</li></ul><h3 id="第六步：执行-BeanFactoryPostProcessor（invokeBeanFactoryPostProcessors）"><a href="#第六步：执行-BeanFactoryPostProcessor（invokeBeanFactoryPostProcessors）" class="headerlink" title="第六步：执行 BeanFactoryPostProcessor（invokeBeanFactoryPostProcessors）"></a>第六步：执行 BeanFactoryPostProcessor（invokeBeanFactoryPostProcessors）</h3><ul><li><strong>核心作用</strong>：执行所有注册的<code>BeanFactoryPostProcessor</code>，对 BeanDefinition 进行修改（如属性占位符替换、扫描额外的 Bean）。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若使用AspectJ，注册相关的BeanFactoryPostProcessor</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>典型应用</strong>：<code>PropertySourcesPlaceholderConfigurer</code>用于替换 BeanDefinition 中的<code>$&#123;&#125;</code>占位符，<code>ConfigurationClassPostProcessor</code>用于解析<code>@Configuration</code>注解的配置类。</li></ul><h3 id="第七步：注册-BeanPostProcessor（registerBeanPostProcessors）"><a href="#第七步：注册-BeanPostProcessor（registerBeanPostProcessors）" class="headerlink" title="第七步：注册 BeanPostProcessor（registerBeanPostProcessors）"></a>第七步：注册 BeanPostProcessor（registerBeanPostProcessors）</h3><ul><li><strong>核心作用</strong>：注册所有<code>BeanPostProcessor</code>（Bean 后置处理器），用于在 Bean 实例化、初始化前后执行自定义逻辑（如 AOP 代理、属性注入增强）。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：<code>BeanPostProcessor</code>分为<code>BeanBeforeInitialization</code>和<code>BeanAfterInitialization</code>两类，Spring 会按优先级排序后注册，后续在 Bean 生命周期中触发。</li></ul><h3 id="第八步：初始化消息源（initMessageSource）"><a href="#第八步：初始化消息源（initMessageSource）" class="headerlink" title="第八步：初始化消息源（initMessageSource）"></a>第八步：初始化消息源（initMessageSource）</h3><ul><li><strong>核心作用</strong>：初始化国际化消息源（MessageSource），支持多语言配置。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">            ((HierarchicalMessageSource) <span class="built_in">this</span>.messageSource).setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若未自定义，创建默认的MessageSource</span></span><br><span class="line">        <span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">        dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">        <span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：默认使用<code>DelegatingMessageSource</code>，用户可通过注册名为<code>messageSource</code>的 Bean 自定义消息源。</li></ul><h3 id="第九步：初始化应用事件多播器（initApplicationEventMulticaster）"><a href="#第九步：初始化应用事件多播器（initApplicationEventMulticaster）" class="headerlink" title="第九步：初始化应用事件多播器（initApplicationEventMulticaster）"></a>第九步：初始化应用事件多播器（initApplicationEventMulticaster）</h3><ul><li><strong>核心作用</strong>：初始化事件多播器（ApplicationEventMulticaster），负责事件的发布与监听者的通知。</li><li><strong>关键源码</strong>：</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认创建SimpleApplicationEventMulticaster</span></span><br><span class="line">        <span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：事件多播器是 Spring 事件驱动模型的核心，支持同步 &#x2F; 异步事件发布。</li></ul><h3 id="第十步：初始化特殊-Bean（onRefresh）"><a href="#第十步：初始化特殊-Bean（onRefresh）" class="headerlink" title="第十步：初始化特殊 Bean（onRefresh）"></a>第十步：初始化特殊 Bean（onRefresh）</h3><ul><li><strong>核心作用</strong>：允许子类初始化特定场景的 Bean（如 Web 容器中的 DispatcherServlet、定时任务的 ScheduledTaskRegistrar）。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：AbstractRefreshableWebApplicationContext的实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onRefresh();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDispatcherServlet(); <span class="comment">// 注册Spring MVC的DispatcherServlet</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to register DispatcherServlet&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：该步骤是 Spring 针对特定场景的扩展点，不同类型的 ApplicationContext 有不同实现。</li></ul><h3 id="第十一步：注册事件监听器（registerListeners）"><a href="#第十一步：注册事件监听器（registerListeners）" class="headerlink" title="第十一步：注册事件监听器（registerListeners）"></a>第十一步：注册事件监听器（registerListeners）</h3><ul><li><strong>核心作用</strong>：注册所有应用事件监听器（ApplicationListener），并发布早期事件。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 注册容器中已有的监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 从BeanFactory中获取所有ApplicationListener类型的Bean并注册</span></span><br><span class="line">    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 发布早期收集的事件</span></span><br><span class="line">    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (earlyEventsToProcess != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">            getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：监听器注册后，可响应容器发布的事件（如<code>ContextRefreshedEvent</code>容器刷新完成事件）。</li></ul><h3 id="第十二步：完成容器刷新（finishRefresh）"><a href="#第十二步：完成容器刷新（finishRefresh）" class="headerlink" title="第十二步：完成容器刷新（finishRefresh）"></a>第十二步：完成容器刷新（finishRefresh）</h3><ul><li><strong>核心作用</strong>：初始化生命周期处理器，发布容器刷新完成事件，激活 Bean 的生命周期方法。</li><li><strong>关键源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 清除资源缓存</span></span><br><span class="line">    clearResourceCaches();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化生命周期处理器</span></span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 触发所有Bean的start()方法（实现Lifecycle接口的Bean）</span></span><br><span class="line">    getLifecycleProcessor().onRefresh();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 发布ContextRefreshedEvent事件</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 注册容器到MBeanServer（JMX支持）</span></span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：此步骤执行后，IOC 容器正式启动完成，Bean 已完成实例化和依赖注入，可对外提供服务。</li></ul><h2 id="二、核心总结"><a href="#二、核心总结" class="headerlink" title="二、核心总结"></a>二、核心总结</h2><ol><li><strong>流程本质</strong>：IOC 容器启动的十二步可归纳为 “<strong>容器初始化→资源加载与解析→BeanFactory 增强→Bean 生命周期处理→事件发布</strong>” 五大阶段。</li><li><strong>核心组件</strong>：<code>ApplicationContext</code>（容器入口）、<code>BeanFactory</code>（Bean 管理核心）、<code>BeanDefinition</code>（Bean 元数据）、<code>BeanPostProcessor</code>（Bean 增强）、<code>ApplicationEventMulticaster</code>（事件驱动）。</li><li><strong>扩展点</strong>：<code>postProcessBeanFactory</code>、<code>onRefresh</code>、<code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code>是 Spring 提供的核心扩展点，支持用户定制容器行为。</li></ol><p>通过以上步骤和源码分析，可清晰理解 Spring IOC 容器从创建到可用的完整链路，为后续深入学习 Bean 生命周期、依赖注入等机制奠定基础。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lock 与 synchronized 区别笔记</title>
      <link href="/posts/56582.html"/>
      <url>/posts/56582.html</url>
      
        <content type="html"><![CDATA[<h3 id="Lock-与-synchronized-的核心区别"><a href="#Lock-与-synchronized-的核心区别" class="headerlink" title="Lock 与 synchronized 的核心区别"></a><strong><code>Lock</code> 与 <code>synchronized</code> 的核心区别</strong></h3><h4 id="1-功能覆盖与扩展"><a href="#1-功能覆盖与扩展" class="headerlink" title="1. 功能覆盖与扩展"></a>1. <strong>功能覆盖与扩展</strong></h4><ul><li><p>**<code>Lock</code>**：</p><p>  几乎能实现 <code>synchronized</code> 的所有基础功能（保证线程安全、同步代码块），且具备 <code>synchronized</code> 不支持的高级特性：</p><ul><li>锁投票（如通过 <code>tryLock()</code> 实现多线程竞争时的灵活选择）；</li><li>定时锁等候（<code>tryLock(long time, TimeUnit unit)</code> 避免无限阻塞）；</li><li>可中断锁（<code>lockInterruptibly()</code> 允许中断等待锁的线程）；</li><li>支持公平 &#x2F; 非公平锁选择、多条件变量（<code>Condition</code>）等。</li></ul></li><li><p>**<code>synchronized</code>**：</p><p>  功能相对基础，仅支持最基本的同步需求，不具备上述高级特性：</p><ul><li>无法通过投票获取锁，一旦开始等待则必须等到锁释放；</li><li>不能中断等待锁的线程；</li><li>锁的释放只能在获取锁的同一堆栈帧中完成（自动释放，无法手动控制时机）。</li></ul></li></ul><h4 id="2-实现层面与释放机制"><a href="#2-实现层面与释放机制" class="headerlink" title="2. 实现层面与释放机制"></a>2. <strong>实现层面与释放机制</strong></h4><ul><li><p>**<code>Lock</code>**：</p><ul><li>是 JDK 5 引入的 <strong>API 层面的锁</strong>（位于 <code>java.util.concurrent.locks</code> 包），属于代码级别的实现；</li><li><strong>必须手动释放锁</strong>：需在 <code>finally</code> 块中显式调用 <code>unlock()</code>，否则可能导致锁长期占用，引发死锁或线程阻塞。</li></ul></li><li><p>**<code>synchronized</code>**：</p><ul><li>是 <strong>Java 语言内置的关键字</strong>，属于 JVM 层面的实现（由字节码指令 <code>monitorenter</code>&#x2F;<code>monitorexit</code> 控制）；</li><li><strong>自动释放锁</strong>：当同步代码块执行完毕或发生异常时，JVM 会自动释放锁，无需手动干预。</li></ul></li></ul><h4 id="3-抽象性与灵活性"><a href="#3-抽象性与灵活性" class="headerlink" title="3. 抽象性与灵活性"></a>3. <strong>抽象性与灵活性</strong></h4><ul><li><p>**<code>Lock</code>**：</p><p>  是 <strong>锁的抽象框架</strong>，<code>ReentrantLock</code> 等是其具体实现，支持通过接口定义灵活扩展，适配不同场景（如公平锁、读写锁 <code>ReentrantReadWriteLock</code> 等）。</p></li><li><p>**<code>synchronized</code>**：</p><p>  是固定的同步机制，实现逻辑封装在 JVM 中，用户无法自定义扩展，灵活性较低。</p></li></ul><h4 id="4-历史与适用场景"><a href="#4-历史与适用场景" class="headerlink" title="4. 历史与适用场景"></a>4. <strong>历史与适用场景</strong></h4><ul><li><p>**<code>synchronized</code>**：</p><p>  是 Java 早期就存在的同步机制，实现简单、易用，适合基础同步场景（如简单的共享资源操作），且 JVM 对其优化较好（如偏向锁、轻量级锁）。</p></li><li><p>**<code>Lock</code>**：</p><p>  是后期为弥补 <code>synchronized</code> 不足而设计的，适合复杂并发场景（如需要中断等待、定时获取锁、多条件唤醒等），但使用成本较高（需手动管理锁释放）。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th>维度</th><th><code>Lock</code></th><th><code>synchronized</code></th></tr></thead><tbody><tr><td>功能</td><td>基础功能 + 高级特性（定时、中断、公平锁等）</td><td>仅基础同步功能</td></tr><tr><td>实现层面</td><td>API 层面（代码级）</td><td>JVM 层面（关键字）</td></tr><tr><td>锁释放</td><td>手动释放（<code>finally</code> 中 <code>unlock()</code>）</td><td>自动释放（JVM 控制）</td></tr><tr><td>灵活性</td><td>高（可扩展、多场景适配）</td><td>低（固定实现）</td></tr><tr><td>适用场景</td><td>复杂并发需求</td><td>简单同步需求</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 请求处理与参数绑定笔记（常用 + 不常用，含示例）</title>
      <link href="/posts/30972.html"/>
      <url>/posts/30972.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、常用功能及示例"><a href="#一、常用功能及示例" class="headerlink" title="一、常用功能及示例"></a>一、常用功能及示例</h2><h3 id="1-请求映射与方法限定"><a href="#1-请求映射与方法限定" class="headerlink" title="1. 请求映射与方法限定"></a>1. 请求映射与方法限定</h3><ul><li><strong><code>@RequestMapping</code> 多属性配置</strong><ul><li>作用：灵活限定请求的方法、参数、头、内容类型等。</li><li>示例（限定请求方法、参数、请求头）：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test02&quot;, params = &#123;&quot;age=18&quot;, &quot;username&quot;, &quot;gender!=1&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test02&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例（限定请求头）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test03&quot;, headers = &#123;&quot;haha&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test03&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>示例（限定消费 &#x2F; 响应内容类型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test04&quot;, consumes = &quot;application/json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test04&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test05&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;你好，Spring MVC!&lt;/h1&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-简单参数绑定（-RequestParam）"><a href="#2-简单参数绑定（-RequestParam）" class="headerlink" title="2. 简单参数绑定（@RequestParam）"></a>2. 简单参数绑定（<code>@RequestParam</code>）</h3><ul><li><strong>作用</strong>：绑定 URL 普通参数（问号后的 <code>key=value</code>）。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/handle01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;username&quot;)</span> String user1,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(defaultValue = &quot;123456&quot;)</span> String password,</span></span><br><span class="line"><span class="params">        String cellphone,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(required = true)</span> String agreement)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理参数逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-JavaBean-自动绑定"><a href="#3-JavaBean-自动绑定" class="headerlink" title="3. JavaBean 自动绑定"></a>3. JavaBean 自动绑定</h3><ul><li><strong>作用</strong>：将请求参数自动映射到 JavaBean 的属性中（需属性名与参数名一致）。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/handle03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle03</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">    System.out.println(person); <span class="comment">// 直接输出绑定后的Person对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;handle03-OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-请求头绑定（-RequestHeader）"><a href="#4-请求头绑定（-RequestHeader）" class="headerlink" title="4. 请求头绑定（@RequestHeader）"></a>4. 请求头绑定（<code>@RequestHeader</code>）</h3><ul><li><strong>作用</strong>：获取请求头中的指定字段。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/handle04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle04</span><span class="params">(<span class="meta">@RequestHeader(&quot;host&quot;)</span> String host)</span> &#123;</span><br><span class="line">    System.out.println(host);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span> + host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-JSON-请求体绑定（-RequestBody）"><a href="#5-JSON-请求体绑定（-RequestBody）" class="headerlink" title="5. JSON 请求体绑定（@RequestBody）"></a>5. JSON 请求体绑定（<code>@RequestBody</code>）</h3><ul><li><strong>作用</strong>：将请求体的 JSON 数据自动转化为 Java 对象。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/handle07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle07</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok-&quot;</span>+person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-文件上传（MultipartFile）"><a href="#6-文件上传（MultipartFile）" class="headerlink" title="6. 文件上传（MultipartFile）"></a>6. 文件上传（<code>MultipartFile</code>）</h3><ul><li><strong>作用</strong>：处理单文件或多文件上传。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@RequestMapping(&quot;/handle08&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">handle08</span><span class="params">(Person person,</span></span><br><span class="line"><span class="params">                          <span class="meta">@RequestParam(&quot;headerImg&quot;)</span> MultipartFile headerImgFile,</span></span><br><span class="line"><span class="params">                          <span class="meta">@RequestParam(&quot;lifeImg&quot;)</span> MultipartFile[] lifeImgFiles)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="comment">// 处理单文件上传</span></span><br><span class="line">       headerImgFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\Aimg\\&quot;</span> + headerImgFile.getOriginalFilename()));</span><br><span class="line">       <span class="comment">// 处理多文件上传</span></span><br><span class="line">       <span class="keyword">for</span> (MultipartFile lifeImgFile : lifeImgFiles) &#123;</span><br><span class="line">           lifeImgFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\Aimg\\&quot;</span> + lifeImgFile.getOriginalFilename()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok!!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Servlet-API-直接操作（HttpServletRequest-HttpServletResponse）"><a href="#7-Servlet-API-直接操作（HttpServletRequest-HttpServletResponse）" class="headerlink" title="7. Servlet API 直接操作（HttpServletRequest&#x2F;HttpServletResponse）"></a>7. Servlet API 直接操作（<code>HttpServletRequest</code>&#x2F;<code>HttpServletResponse</code>）</h3><ul><li><strong>作用</strong>：直接使用原生 Servlet API 处理请求响应。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/handle10&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle10</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、不常用功能"><a href="#二、不常用功能" class="headerlink" title="二、不常用功能"></a>二、不常用功能</h2><table><thead><tr><th>功能 &#x2F; 注解</th><th>作用</th></tr></thead><tbody><tr><td><code>HttpEntity&lt;Person&gt;</code></td><td>封装请求头和请求体，可同时获取请求头信息和请求体对象（如 <code>entity.getHeaders()</code>、<code>entity.getBody()</code>）</td></tr><tr><td>矩阵变量（<code>@MatrixVariable</code>）</td><td>处理 URL 中的矩阵变量（如 <code>/&#123;path&#125;;var1=value1;var2=value2</code> 格式）</td></tr><tr><td><code>@CookieValue</code></td><td>专门用于获取 Cookie 中的值</td></tr><tr><td><code>@RequestPart</code></td><td>用于文件上传时的复杂表单（如混合了 JSON 和文件的场景）</td></tr><tr><td><code>Map</code>&#x2F;<code>Model</code>&#x2F;<code>ModelMap</code></td><td>服务端渲染时共享数据（结合模板引擎如 Thymeleaf 使用）</td></tr><tr><td><code>@ModelAttribute</code></td><td>前置数据绑定（方法或参数上使用，用于预处理模型数据）</td></tr><tr><td><code>Errors, BindingResult</code></td><td>数据校验结果（结合 <code>@Valid</code> 使用，用于接收校验错误信息）</td></tr><tr><td><code>@SessionAttributes</code></td><td>管理 Session 中的数据</td></tr><tr><td><code>UriComponentsBuilder</code></td><td>封装请求 URL，用于动态构造 URL 地址</td></tr><tr><td><code>@RequestAttribute</code></td><td>获取请求域中的属性（需提前在请求域中设置属性）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 请求处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>请求处理</title>
      <link href="/posts/42879.html"/>
      <url>/posts/42879.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>实验</th><th>内容</th><th>目标</th></tr></thead><tbody><tr><td>实验1</td><td>使用普通变量，收集请求参数</td><td>测试普通value封装</td></tr><tr><td>实验2</td><td>使用@RequestParam，逐一封装多个参数</td><td>测试@RequestParam与required</td></tr><tr><td>实验3</td><td>使用POJO，统一封装多个参数</td><td>测试bean封装</td></tr><tr><td>实验4</td><td>使用@RequestHeader获取请求头数据</td><td>测试@RequestHeader</td></tr><tr><td>实验5</td><td>使用@CookieValue获取Cookie数据</td><td>测试@CookieValue</td></tr><tr><td>实验6</td><td>使用POJO，级联封装复杂对象</td><td>测试级联封装</td></tr><tr><td>实验7</td><td>使用@RequestBody，封装JSON对象</td><td>测试JSON封装</td></tr><tr><td>实验8</td><td>使用@RequestPart&#x2F;@RequestParam，封装文件对象</td><td>测试文件上传</td></tr><tr><td>实验9</td><td>使用HttpEntity，封装请求原始数据</td><td>测试HttpEntity</td></tr><tr><td>实验10</td><td>使用原生Servlet API，获取原生请求对象</td><td>测试Servlet API</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 请求处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>响应数据类型笔记</title>
      <link href="/posts/15899.html"/>
      <url>/posts/15899.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、常用类型"><a href="#一、常用类型" class="headerlink" title="一、常用类型"></a>一、常用类型</h2><table><thead><tr><th>类型</th><th>作用</th><th>典型场景示例</th></tr></thead><tbody><tr><td><code>@ResponseBody + 对象</code></td><td>响应 JSON 等非页面数据</td><td>接口返回用户信息、列表数据</td></tr><tr><td><code>ResponseEntity&lt;B&gt;</code></td><td>完全自定义响应头、响应体数据</td><td>文件下载（自定义 <code>Content-Disposition</code> 等头）</td></tr><tr><td><code>String</code></td><td>返回逻辑视图地址（用于页面渲染）</td><td>跳转到 Thymeleaf 模板页面</td></tr><tr><td><code>Map</code>&#x2F;<code>Model</code></td><td>传递默认视图地址与数据（页面渲染用）</td><td>向页面共享用户列表、用户名等数据</td></tr><tr><td><code>ModelAndView</code></td><td>自定义模型和视图</td><td>同时指定页面模板和共享数据</td></tr></tbody></table><h2 id="二、不常用类型"><a href="#二、不常用类型" class="headerlink" title="二、不常用类型"></a>二、不常用类型</h2><table><thead><tr><th>类型</th><th>作用</th><th>适用场景</th></tr></thead><tbody><tr><td><code>HttpEntity&lt;B&gt;</code></td><td>自定义响应头、响应体数据</td><td>类似 <code>ResponseEntity</code>，但灵活性稍弱</td></tr><tr><td><code>HttpHeaders</code></td><td>仅返回响应头，无内容</td><td>需单独设置响应头的场景</td></tr><tr><td><code>ErrorResponse</code>&#x2F;<code>ProblemDetail</code></td><td>响应错误头、错误体</td><td>标准化的 API 错误返回</td></tr><tr><td><code>View</code></td><td>视图对象</td><td>自定义视图渲染逻辑</td></tr><tr><td><code>@ModelAttribute</code></td><td>传递默认视图地址与数据</td><td>页面渲染时共享数据</td></tr><tr><td><code>void</code></td><td>需自定义 response</td><td>直接操作 <code>HttpServletResponse</code> 输出</td></tr><tr><td><code>ListenableFuture&lt;V&gt;</code>&#x2F;<code>CompletableFuture&lt;V&gt;</code></td><td>异步结果响应</td><td>异步任务的结果返回</td></tr><tr><td><code>ResponseBodyEmitter</code>&#x2F;<code>SseEmitter</code></td><td>异步响应与流式数据响应</td><td>服务端推送、长轮询场景</td></tr><tr><td><code>StreamingResponseBody</code></td><td>流式数据响应</td><td>大文件分块传输</td></tr><tr><td><code>ReactiveAdapterRegistry</code></td><td>Webflux 模式支持</td><td>响应式编程场景</td></tr><tr><td><code>DeferredResult</code>&#x2F;<code>Callable</code></td><td>异步结果响应</td><td>异步处理 HTTP 请求</td></tr><tr><td>其他返回类型</td><td>被当做 <code>ModelAttribute</code></td><td>自动加入模型数据</td></tr></tbody></table><hr><h2 id="三、常用类型及示例"><a href="#三、常用类型及示例" class="headerlink" title="三、常用类型及示例"></a>三、常用类型及示例</h2><h3 id="1-ResponseBody-对象"><a href="#1-ResponseBody-对象" class="headerlink" title="1. @ResponseBody + 对象"></a>1. <code>@ResponseBody + 对象</code></h3><ul><li><strong>作用</strong>：响应 JSON 等非页面数据</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">1L</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user; <span class="comment">// 自动转 JSON 响应</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ResponseEntity"><a href="#2-ResponseEntity" class="headerlink" title="2. ResponseEntity&lt;B&gt;"></a>2. <code>ResponseEntity&lt;B&gt;</code></h3><ul><li><strong>作用</strong>：完全自定义响应头、响应体数据</li><li><strong>示例（文件下载）</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; downloadFile() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">byte</span>[] fileBytes = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\Aimg\\MaYi.jpg&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">            .header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=美女.jpg&quot;</span>)</span><br><span class="line">            .contentType(MediaType.IMAGE_JPEG)</span><br><span class="line">            .body(fileBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. <code>String</code></h3><ul><li><strong>作用</strong>：返回逻辑视图地址（用于页面渲染）</li><li><strong>示例（跳转到 Thymeleaf 页面）</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toLoginPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>; <span class="comment">// 对应 templates/login.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Map-Model"><a href="#4-Map-Model" class="headerlink" title="4. Map&#x2F;Model"></a>4. <code>Map</code>&#x2F;<code>Model</code></h3><ul><li><strong>作用</strong>：传递默认视图地址与数据（页面渲染用）</li><li><strong>示例（向页面共享用户数据）</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserList</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">25</span>)</span><br><span class="line">        );</span><br><span class="line">        model.addAttribute(<span class="string">&quot;users&quot;</span>, users); <span class="comment">// 共享用户列表到页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user/list&quot;</span>; <span class="comment">// 对应 templates/user/list.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-ModelAndView"><a href="#5-ModelAndView" class="headerlink" title="5. ModelAndView"></a>5. <code>ModelAndView</code></h3><ul><li><strong>作用</strong>：自定义模型和视图</li><li><strong>示例（同时指定页面和数据）</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order/detail&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">getOrderDetail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;order/detail&quot;</span>); <span class="comment">// 指定视图</span></span><br><span class="line">        mv.addObject(<span class="string">&quot;orderId&quot;</span>, <span class="number">1001</span>);</span><br><span class="line">        mv.addObject(<span class="string">&quot;amount&quot;</span>, <span class="number">99.9</span>);</span><br><span class="line">        <span class="keyword">return</span> mv; <span class="comment">// 传递数据并跳转页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 响应处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>响应处理</title>
      <link href="/posts/31056.html"/>
      <url>/posts/31056.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>实验</th><th>内容</th><th>目标</th></tr></thead><tbody><tr><td>实验1</td><td>返回JSON数据</td><td>测试对象json写出</td></tr><tr><td>实验2</td><td>返回ResponseEntity</td><td>测试文件下载</td></tr><tr><td>实验3</td><td>（了解）：引入thymeleaf模板引擎</td><td>测试服务端渲染</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 响应处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf 核心语法笔记</title>
      <link href="/posts/35285.html"/>
      <url>/posts/35285.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础配置"><a href="#一、基础配置" class="headerlink" title="一、基础配置"></a>一、基础配置</h2><ul><li><strong>命名空间声明</strong>：在 HTML 根标签中添加 Thymeleaf 命名空间，启用语法支持：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、核心语法分类及示例"><a href="#二、核心语法分类及示例" class="headerlink" title="二、核心语法分类及示例"></a>二、核心语法分类及示例</h2><h3 id="1-动态属性渲染（th-xxx）"><a href="#1-动态属性渲染（th-xxx）" class="headerlink" title="1. 动态属性渲染（th:xxx）"></a>1. 动态属性渲染（<code>th:xxx</code>）</h3><p>通过 <code>th:属性名</code> 动态设置 HTML 标签的属性值或执行指令，支持所有 HTML 属性及 Thymeleaf 自定义指令。</p><table><thead><tr><th>语法</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>th:text</code></td><td>动态渲染标签体内的文本</td><td><code>&lt;span th:text=&quot;$&#123;username&#125;&quot;&gt;&lt;/span&gt;</code>（显示 <code>Model</code> 中的 <code>username</code>）</td></tr><tr><td><code>th:属性名</code></td><td>动态设置标签的指定属性（如 <code>id</code>、<code>src</code>）</td><td><code>&lt;span th:id=&quot;$&#123;username&#125;&quot;&gt;&lt;/span&gt;</code>（用 <code>username</code> 作为 <code>id</code> 属性值）</td></tr><tr><td><code>th:attr</code></td><td>动态设置任意属性（适用于自定义属性）</td><td><code>&lt;div th:attr=&quot;data-id=$&#123;user.id&#125;&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>指令类（<code>th:if</code>&#x2F;<code>th:each</code>）</td><td>条件判断 &#x2F; 循环遍历</td><td>见下文详细说明</td></tr></tbody></table><h3 id="2-取值表达式"><a href="#2-取值表达式" class="headerlink" title="2. 取值表达式"></a>2. 取值表达式</h3><p>用于从 <code>Model</code> 或上下文获取数据，常用表达式如下：</p><table><thead><tr><th>表达式</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>$&#123;&#125;</code></td><td>变量取值（获取 <code>Model</code> 中的数据）</td><td><code>$&#123;username&#125;</code>（获取用户名）</td></tr><tr><td><code>@&#123;&#125;</code></td><td>URL 路径生成（自动拼接上下文路径）</td><td><code>&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;</code></td></tr><tr><td><code>#&#123;&#125;</code></td><td>国际化消息取值（从配置文件读取多语言）</td><td><code>#&#123;message.login.success&#125;</code></td></tr><tr><td><code>~&#123;&#125;</code></td><td>片段引用（复用页面片段）</td><td><code>th:insert=&quot;~&#123;common/header :: header&#125;&quot;</code></td></tr><tr><td><code>*&#123;&#125;</code></td><td>变量选择（简化对象属性访问）</td><td>配合 <code>th:object</code> 使用，如 <code>*&#123;name&#125;</code></td></tr></tbody></table><h3 id="3-循环遍历（th-each）"><a href="#3-循环遍历（th-each）" class="headerlink" title="3. 循环遍历（th:each）"></a>3. 循环遍历（<code>th:each</code>）</h3><p>用于遍历 <code>Model</code> 中的集合数据（如列表），语法：</p><p><code>th:each=&quot;元素变量名, 状态变量 : $&#123;集合&#125;&quot;</code></p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 遍历 users 集合，每次循环的元素为 user --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user : $&#123;users&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;user.id&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!-- 行内写法显示 id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!-- 显示用户名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>状态变量</strong>（可选，常用属性）：</p><ul><li><code>stat.index</code>：从 0 开始的索引</li><li><code>stat.count</code>：从 1 开始的计数</li><li><code>stat.odd</code>&#x2F;<code>stat.even</code>：是否为奇数 &#x2F; 偶数行</li><li><code>stat.first</code>&#x2F;<code>stat.last</code>：是否为第一 &#x2F; 最后一个元素</li></ul></li></ul><h3 id="4-条件判断（th-if）"><a href="#4-条件判断（th-if）" class="headerlink" title="4. 条件判断（th:if）"></a>4. 条件判断（<code>th:if</code>）</h3><p>根据表达式结果（布尔值）决定是否渲染当前标签，语法：</p><p><code>th:if=&quot;$&#123;条件表达式&#125;&quot;</code></p><ul><li><p><strong>示例</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 年龄 &gt;=18 显示“成年”，否则不显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;user.age &gt;= 18&#125;&quot;</span>&gt;</span>成年<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 搭配 th:unless 使用（等价于 !条件） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;user.age &gt;= 18&#125;&quot;</span>&gt;</span>未成年<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>简化写法</strong>：用三元运算符在 <code>th:text</code> 中直接判断：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age &gt;= 18 ? &#x27;成年&#x27; : &#x27;未成年&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-行内写法（-）"><a href="#5-行内写法（-）" class="headerlink" title="5. 行内写法（[[ ]]）"></a>5. 行内写法（<code>[[ ]]</code>）</h3><p>在 HTML 文本中直接嵌入取值表达式，等价于 <code>th:text</code>，更简洁：</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>密码：[[$&#123;password&#125;]]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 &lt;h2&gt;密码：&lt;span th:text=&quot;$&#123;password&#125;&quot;&gt;&lt;/span&gt;&lt;/h2&gt; --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、核心特点"><a href="#三、核心特点" class="headerlink" title="三、核心特点"></a>三、核心特点</h2><ul><li><strong>自然模板</strong>：模板文件本身是合法的 HTML，未渲染时可直接在浏览器打开。</li><li><strong>动态渲染</strong>：通过 <code>th:xxx</code> 指令将 <code>Model</code> 中的数据动态填充到页面。</li><li><strong>功能全面</strong>：支持变量取值、循环、判断、URL 处理、国际化等常见需求。</li></ul><h2 id="四、示例代码解析（结合提供的-HTML）"><a href="#四、示例代码解析（结合提供的-HTML）" class="headerlink" title="四、示例代码解析（结合提供的 HTML）"></a>四、示例代码解析（结合提供的 HTML）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 命名空间声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. th:text 渲染文本，th:id 动态设置id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span> <span class="attr">th:id</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3. 行内写法 [[ ]] 显示密码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>密码：[[$&#123;password&#125;]]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4. th:each 遍历 users 集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user : $&#123;users&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;user.id&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!-- 行内写法显示id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.getUsername()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!-- 调用对象方法取值（不推荐，建议用 $&#123;user.username&#125;） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!-- 直接访问属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age &gt;= 18 ? &#x27;成年&#x27; : &#x27;未成年&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!-- 三元运算符判断 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 响应处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Model 笔记</title>
      <link href="/posts/24710.html"/>
      <url>/posts/24710.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>在 Spring MVC（结合 Thymeleaf 模板引擎的服务端渲染场景中），<code>Model</code> 是用于<strong>向页面模板共享数据</strong>的核心对象，它能将后端的业务数据传递到前端页面，供 Thymeleaf 语法读取并渲染。</p><h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><p>当需要在服务端渲染页面时（如登录成功后展示用户列表、个人信息等），通过 <code>Model</code> 把数据从控制器（<code>Controller</code>）传递到页面模板（如 Thymeleaf 的 <code>.html</code> 文件）。</p><h2 id="三、使用方式"><a href="#三、使用方式" class="headerlink" title="三、使用方式"></a>三、使用方式</h2><p>在控制器方法中，通过方法参数注入 <code>Model</code> 对象，再调用其 <code>addAttribute()</code> 方法添加数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, Model model)</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟用户列表数据</span></span><br><span class="line">    List&lt;User&gt; userList = Arrays.asList(...);</span><br><span class="line">    <span class="comment">// 向 Model 中添加数据，key 为 &quot;users&quot;，值为 userList</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, userList);</span><br><span class="line">    <span class="comment">// 传递用户名</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">    <span class="comment">// 最终这些数据会被传递到页面模板中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、与页面模板的联动（以-Thymeleaf-为例）"><a href="#四、与页面模板的联动（以-Thymeleaf-为例）" class="headerlink" title="四、与页面模板的联动（以 Thymeleaf 为例）"></a>四、与页面模板的联动（以 Thymeleaf 为例）</h2><p>在 Thymeleaf 页面中，通过其语法（如 <code>th:text</code>、<code>th:each</code> 等）读取 <code>Model</code> 中传递的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 读取单个数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 遍历列表数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user : $&#123;users&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="五、核心意义"><a href="#五、核心意义" class="headerlink" title="五、核心意义"></a>五、核心意义</h2><p><code>Model</code> 是服务端渲染模式中<strong>后端与前端页面数据交互的桥梁</strong>，它让控制器能灵活地将业务数据传递给模板引擎，最终渲染出动态的页面内容。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 响应处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件下载</title>
      <link href="/posts/18452.html"/>
      <url>/posts/18452.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件下载核心知识点笔记"><a href="#文件下载核心知识点笔记" class="headerlink" title="文件下载核心知识点笔记"></a>文件下载核心知识点笔记</h1><h2 id="一、核心问题与解决方向"><a href="#一、核心问题与解决方向" class="headerlink" title="一、核心问题与解决方向"></a>一、核心问题与解决方向</h2><ul><li><strong>中文文件名乱码</strong>：需对文件名进行 URL 编码。</li><li><strong>大文件内存溢出（OOM）</strong>：采用分块读取（<code>InputStreamResource</code> 包装流）。</li><li><strong>资源泄漏</strong>：使用 <code>try-with-resources</code> 自动关闭 IO 资源。</li><li><strong>响应头配置</strong>：通过 <code>Content-Disposition</code>、<code>ContentType</code>、<code>ContentLength</code> 控制下载行为。</li></ul><h2 id="二、关键技术点"><a href="#二、关键技术点" class="headerlink" title="二、关键技术点"></a>二、关键技术点</h2><h3 id="1-中文文件名编码"><a href="#1-中文文件名编码" class="headerlink" title="1. 中文文件名编码"></a>1. 中文文件名编码</h3><p>使用 <code>URLEncoder.encode(filename, &quot;UTF-8&quot;)</code> 对中文文件名编码，避免浏览器下载时乱码。</p><h3 id="2-分块读取（防止-OOM）"><a href="#2-分块读取（防止-OOM）" class="headerlink" title="2. 分块读取（防止 OOM）"></a>2. 分块读取（防止 OOM）</h3><p>通过 <code>InputStreamResource</code> 包装文件输入流，由框架自动处理分块传输，避免大文件一次性加载到内存。</p><h3 id="3-响应头配置"><a href="#3-响应头配置" class="headerlink" title="3. 响应头配置"></a>3. 响应头配置</h3><table><thead><tr><th>响应头 &#x2F; 属性</th><th>作用</th><th>示例值</th></tr></thead><tbody><tr><td><code>Content-Disposition</code></td><td>控制文件下载行为，<code>attachment</code> 表示作为附件下载，需指定文件名。</td><td><code>attachment; filename=美女.jpg</code></td></tr><tr><td><code>ContentType</code></td><td>指定响应内容的媒体类型，二进制文件通用 <code>APPLICATION_OCTET_STREAM</code>。</td><td><code>MediaType.APPLICATION_OCTET_STREAM</code></td></tr><tr><td><code>ContentLength</code></td><td>指定文件的字节大小，便于前端感知下载进度。</td><td>文件实际字节数</td></tr></tbody></table><h2 id="三、Spring-MVC-实现示例（优化版）"><a href="#三、Spring-MVC-实现示例（优化版）" class="headerlink" title="三、Spring MVC 实现示例（优化版）"></a>三、Spring MVC 实现示例（优化版）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.InputStreamResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/download&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;InputStreamResource&gt; <span class="title function_">downloadFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 定义文件和原始文件名</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\Aimg\\MaYi.jpg&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> <span class="string">&quot;美女.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解决中文文件名乱码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedFilename</span> <span class="operator">=</span> URLEncoder.encode(originalFilename, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 分块读取 + 资源自动关闭（try-with-resources 语法）</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="type">InputStreamResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamResource</span>(inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                    .contentType(MediaType.APPLICATION_OCTET_STREAM)</span><br><span class="line">                    .contentLength(file.length()) <span class="comment">// 准确的文件大小</span></span><br><span class="line">                    .header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span> + encodedFilename)</span><br><span class="line">                    .body(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、关键优化说明"><a href="#四、关键优化说明" class="headerlink" title="四、关键优化说明"></a>四、关键优化说明</h2><ul><li><strong>资源安全</strong>：<code>try-with-resources</code> 确保文件输入流自动关闭，避免资源泄漏。</li><li><strong>性能可靠</strong>：<code>InputStreamResource</code> 分块传输大文件，彻底解决 OOM 风险。</li><li><strong>兼容性强</strong>：<code>URLEncoder</code> 处理中文文件名，兼容各类浏览器。</li><li><strong>参数准确</strong>：<code>file.length()</code> 保证 <code>ContentLength</code> 准确，提升下载体验。</li></ul><p>通过以上配置，可实现安全、高效、兼容的文件下载功能，覆盖中文乱码、大文件处理、资源管理等核心场景。</p><p>&#x3D;&#x3D;idea代码：&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springmvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springmvc.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.InputStreamResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// 相当于@Controller+@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseTestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/resp01&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">resp01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setUsername(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        person.setPassword(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        person.setCellphone(<span class="string">&quot;222222&quot;</span>);</span><br><span class="line">        person.setAgreement(<span class="literal">false</span>);</span><br><span class="line">        person.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        person.setHobby(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;足球&quot;</span>, <span class="string">&quot;篮球&quot;</span>&#125;);</span><br><span class="line">        person.setGrade(<span class="string">&quot;一年级&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载：</span></span><br><span class="line"><span class="comment">     *  HttpEntity:拿到整个请求数据</span></span><br><span class="line"><span class="comment">     *  ResponseEntity:拿到整个响应数据（响应头，响应体，状态码）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/download&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; download() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Aimg\\MaYi.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 一口气读会溢出</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = inputStream.readAllBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.文件名中文会乱码</span></span><br><span class="line">        <span class="comment">// 2.文件太大会导致 内存溢出</span></span><br><span class="line">        <span class="comment">// 解决：</span></span><br><span class="line">        <span class="comment">// 1.URLEncoder.encode(filename,&quot;UTF-8&quot;)：解决中文乱码问题</span></span><br><span class="line">        <span class="comment">// 2.分片下载：解决内存溢出问题</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;美女.jpg&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                <span class="comment">// 内容类型</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_OCTET_STREAM)</span><br><span class="line">                <span class="comment">// 内容大小</span></span><br><span class="line">                .contentLength(bytes.length)</span><br><span class="line">                <span class="comment">// Content-Disposition：内容处理方式，attachment：附件，filename：文件名</span></span><br><span class="line">                .header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + encode)</span><br><span class="line">                .body(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板代码</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/download1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;InputStreamResource&gt; <span class="title function_">download1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Aimg\\MaYi.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.文件名中文会乱码</span></span><br><span class="line">        <span class="comment">// 2.文件太大会导致 内存溢出</span></span><br><span class="line">        <span class="comment">// 解决：</span></span><br><span class="line">        <span class="comment">// 1.URLEncoder.encode(filename,&quot;UTF-8&quot;)：解决中文乱码问题</span></span><br><span class="line">        <span class="comment">// 2.分片下载：解决内存溢出问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.中文乱码解决</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;美女.jpg&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.文件太大会oom,oom:内存溢出</span></span><br><span class="line">        <span class="comment">// InputStreamResource：包装流，包装一个输入流，可以解决内存溢出问题</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InputStreamResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamResource</span>(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                <span class="comment">// 内容类型</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_OCTET_STREAM)</span><br><span class="line">                <span class="comment">// 内容大小</span></span><br><span class="line">                .contentLength(inputStream.available())</span><br><span class="line">                <span class="comment">// Content-Disposition：内容处理方式，attachment：附件，filename：文件名</span></span><br><span class="line">                .header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + encode)</span><br><span class="line">                .body(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring MVC </category>
          
          <category> 响应处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>懒汉式单例模式的线程问题</title>
      <link href="/posts/19396.html"/>
      <url>/posts/19396.html</url>
      
        <content type="html"><![CDATA[<p>在多线程的情况下 有可能创建出多个实例对象</p><p>可以用线程同步的方法去处理 比如把方法声明为synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;猪百万&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Cat</span> <span class="variable">c1</span> <span class="operator">=</span> Cat.getCatInstance();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">c2</span> <span class="operator">=</span> Cat.getCatInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(c1==c2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">c1.catchMouse();</span><br><span class="line">c2.catchMouse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Cat cat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Cat <span class="title function_">getCatInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cat == <span class="literal">null</span>)&#123;</span><br><span class="line">cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;喵喵喵~~~~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了单例模式（饿汉式的线程安全版本），<br>通过 <code>synchronized</code> 关键字保证了 <code>getCatInstance()</code> 方法在多线程环境下的安全性，确保只会创建一个 <code>Cat</code> 实例，因此 <code>c1 == c2</code> 的结果为 <code>true</code>。</p><p>这两个单例模式的实现方式有显著区别，核心差异在于<strong>同步的范围和效率</strong>，具体如下：</p><h3 id="1-第一个实现（双重检查锁-Double-Checked-Locking）"><a href="#1-第一个实现（双重检查锁-Double-Checked-Locking）" class="headerlink" title="1. 第一个实现（双重检查锁 &#x2F; Double-Checked Locking）"></a>1. 第一个实现（双重检查锁 &#x2F; Double-Checked Locking）</h3><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getCatInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cat == <span class="literal">null</span>) &#123;  <span class="comment">// 第一次检查（无锁）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Cat.class) &#123;  <span class="comment">// 同步块（缩小锁范围）</span></span><br><span class="line">            <span class="keyword">if</span> (cat == <span class="literal">null</span>) &#123;  <span class="comment">// 第二次检查（持有锁时）</span></span><br><span class="line">                cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>核心特点</strong>：</p><p>  仅在<code>cat</code>为<code>null</code>时才进入同步块，通过两次<code>null</code>检查（无锁时一次，持有锁时一次），既保证了线程安全，又减少了同步带来的性能损耗。</p><ul><li>第一次检查：避免已初始化后仍进入同步块（多数情况下直接返回，无需加锁）。</li><li>第二次检查：防止多线程同时通过第一次检查后，重复初始化（持有锁时再确认）。</li></ul></li><li><p><strong>优势</strong>：</p><p>  同步范围小（仅初始化时加锁），后续调用无需竞争锁，效率更高，适合高并发场景。</p></li></ul><h3 id="2-第二个实现（方法级同步）"><a href="#2-第二个实现（方法级同步）" class="headerlink" title="2. 第二个实现（方法级同步）"></a>2. 第二个实现（方法级同步）</h3><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Cat <span class="title function_">getCatInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cat == <span class="literal">null</span>) &#123;</span><br><span class="line">        cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>核心特点</strong>：</p><p>  直接在静态方法上使用<code>synchronized</code>，相当于对<code>Cat.class</code>加锁（与第一个实现的同步块锁对象相同），但<strong>每次调用方法都会触发同步</strong>。</p></li><li><p><strong>问题</strong>：</p><p>  即使<code>cat</code>已初始化（单例已创建），后续所有调用仍需竞争锁并排队执行，导致不必要的性能开销（尤其是高并发场景下）。</p></li></ul><h3 id="总结区别"><a href="#总结区别" class="headerlink" title="总结区别"></a>总结区别</h3><table><thead><tr><th>维度</th><th>双重检查锁（第一个）</th><th>方法级同步（第二个）</th></tr></thead><tbody><tr><td>同步范围</td><td>仅初始化时的同步块</td><td>整个方法（每次调用都同步）</td></tr><tr><td>性能</td><td>高（后续调用无锁）</td><td>低（每次调用都需竞争锁）</td></tr><tr><td>线程安全</td><td>安全（需配合<code>volatile</code>修饰<code>cat</code>）</td><td>安全（但代价高）</td></tr><tr><td>适用场景</td><td>高并发、频繁调用的单例</td><td>低并发、对性能不敏感的场景</td></tr></tbody></table><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>第一个实现需额外用<code>volatile</code>修饰<code>cat</code>变量（<code>private static volatile Cat cat;</code>），否则可能因指令重排序导致线程安全问题（可见性和有序性）。而第二个实现因方法级同步，无需<code>volatile</code>也能保证安全，但性能较差。</p><p>实际开发中，双重检查锁是更优的单例实现方式（需正确使用<code>volatile</code>）。</p><p>volatile</p><p>这是什么</p><p><code>volatile</code> 是 Java 中的一个<strong>关键字</strong>，主要用于修饰变量，核心作用是保证变量的 <strong>可见性</strong> 和 <strong>有序性</strong>，但不保证原子性。它常被用于多线程场景，解决线程间变量读取不一致或指令重排序导致的问题（比如之前提到的双重检查锁单例）。</p><h3 id="一、先搞懂：没有-volatile-会出什么问题？"><a href="#一、先搞懂：没有-volatile-会出什么问题？" class="headerlink" title="一、先搞懂：没有 volatile 会出什么问题？"></a>一、先搞懂：没有 volatile 会出什么问题？</h3><p>在多线程环境中，CPU、编译器和 JVM 为了优化性能，可能会做一些 “手脚”，导致变量操作不符合预期：</p><ol><li><strong>缓存导致的可见性问题</strong>：每个线程有自己的工作内存（缓存），对共享变量的修改会先存在工作内存，不会立即同步到主内存；其他线程读取时也从自己的缓存取，导致看不到最新值。</li><li><strong>指令重排序导致的有序性问题</strong>：编译器 &#x2F; CPU 会调整指令执行顺序（只要不影响单线程结果），但多线程下可能破坏逻辑正确性（比如双重检查锁中的 <code>cat = new Cat()</code> 被重排序）。</li></ol><h3 id="二、volatile-的核心作用"><a href="#二、volatile-的核心作用" class="headerlink" title="二、volatile 的核心作用"></a>二、volatile 的核心作用</h3><h4 id="1-保证可见性"><a href="#1-保证可见性" class="headerlink" title="1. 保证可见性"></a>1. 保证可见性</h4><p>当一个线程修改了 <code>volatile</code> 修饰的变量后，这个修改会<strong>立即同步到主内存</strong>；其他线程读取该变量时，会<strong>直接从主内存读取最新值</strong>，而不是从自己的工作缓存读取过期数据。</p><p><strong>举个例子</strong>：</p><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无 volatile：线程A修改flag后，线程B可能长期看不到，陷入死循环</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 volatile：线程A修改flag后，线程B能立即感知到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    flag = <span class="literal">true</span>; <span class="comment">// 修改volatile变量，立即同步到主内存</span></span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123; <span class="comment">// 每次读取都从主内存获取最新值，不会一直循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h4 id="2-禁止指令重排序"><a href="#2-禁止指令重排序" class="headerlink" title="2. 禁止指令重排序"></a>2. 禁止指令重排序</h4><p><code>volatile</code> 会禁止编译器和 CPU 对该变量相关的指令进行重排序，保证指令按代码书写的顺序执行，避免多线程下的逻辑混乱。</p><p><strong>关键场景：双重检查锁单例</strong></p><p>之前的双重检查锁实现中，<code>cat = new Cat()</code> 看似是一步操作，实际会被拆分为 3 步：</p><ol><li>分配内存空间；</li><li>初始化 Cat 对象；</li><li>将 cat 引用指向内存空间。</li></ol><p>没有 <code>volatile</code> 时，CPU 可能重排序为 <code>1→3→2</code>。此时线程 A 执行到步骤 3（cat 已非 null），线程 B 第一次检查发现 cat 不为 null，直接返回一个<strong>未初始化完成的 Cat 对象</strong>，导致错误。</p><p>用 <code>volatile</code> 修饰 cat 后，会禁止这种重排序，确保 <code>1→2→3</code> 执行，避免半初始化对象问题。</p><h3 id="三、volatile-的局限性：不保证原子性"><a href="#三、volatile-的局限性：不保证原子性" class="headerlink" title="三、volatile 的局限性：不保证原子性"></a>三、volatile 的局限性：不保证原子性</h3><p><code>volatile</code> 无法保证复合操作的原子性（原子性指操作要么全部完成，要么全部不执行，中间不会被打断）。</p><p><strong>举个反例</strong>：</p><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10个线程各执行1000次count++</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">            count++; <span class="comment">// 复合操作：读取count→加1→写入count</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终 <code>count</code> 的结果很可能小于 10000。因为 <code>count++</code> 是 3 步复合操作，<code>volatile</code> 只能保证每次读取的是最新值，但无法阻止多个线程同时执行 “读取 - 加 1 - 写入” 的步骤，导致值被覆盖。</p><p><strong>解决原子性问题</strong>：需配合锁（<code>synchronized</code>）或原子类（<code>AtomicInteger</code>）。</p><h3 id="四、volatile-的使用场景"><a href="#四、volatile-的使用场景" class="headerlink" title="四、volatile 的使用场景"></a>四、volatile 的使用场景</h3><ol><li><strong>状态标志位</strong>：比如多线程中的开关变量（如上面的 flag），用于线程间传递状态。</li><li><strong>双重检查锁单例</strong>：修饰单例变量，禁止指令重排序，避免半初始化对象。</li><li><strong>轻量级同步</strong>：适用于变量的操作是 “单次读 &#x2F; 写”（非复合操作）的场景，替代<code>synchronized</code>以提升性能。</li></ol><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><table><thead><tr><th>特性</th><th>volatile 是否保证？</th></tr></thead><tbody><tr><td>可见性</td><td>是</td></tr><tr><td>有序性</td><td>是（禁止重排序）</td></tr><tr><td>原子性</td><td>否（仅单次读写安全）</td></tr></tbody></table><p><code>volatile</code> 是一种轻量级的多线程同步方案，性能优于 <code>synchronized</code>，但适用场景有限。核心记住它的两大作用：解决可见性问题、禁止指令重排序，同时注意它不处理原子性问题。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Collections.synchronizedXXX 同步机制</title>
      <link href="/posts/5936.html"/>
      <url>/posts/5936.html</url>
      
        <content type="html"><![CDATA[<p><code>Collections.synchronizedXXX</code> 是 Java 集合框架中用于将非线程安全的集合转换为线程安全集合的工具方法，主要作用是通过 <strong>同步机制</strong> 保证多线程环境下集合操作的安全性。以下是对这类方法的总结：</p><h3 id="1-核心功能"><a href="#1-核心功能" class="headerlink" title="1. 核心功能"></a>1. 核心功能</h3><ul><li><strong>线程安全转换</strong>：将非线程安全的集合（如 <code>ArrayList</code>、<code>HashMap</code>、<code>HashSet</code> 等）包装为线程安全的版本，避免多线程并发操作时出现数据不一致或异常（如 <code>ConcurrentModificationException</code>）。</li><li><strong>同步实现方式</strong>：通过 <strong>包装器模式</strong>，在原集合的所有方法（如 <code>add</code>、<code>remove</code>、<code>get</code> 等）外层添加 <code>synchronized</code> 同步块，确保同一时刻只有一个线程能执行集合的方法。</li></ul><h3 id="2-常用方法及对应集合"><a href="#2-常用方法及对应集合" class="headerlink" title="2. 常用方法及对应集合"></a>2. 常用方法及对应集合</h3><table><thead><tr><th>方法</th><th>作用</th><th>对应的非线程安全集合</th><th>线程安全包装后的类型</th></tr></thead><tbody><tr><td><code>synchronizedList(List&lt;T&gt;)</code></td><td>将 List 转换为线程安全集合</td><td><code>ArrayList</code>、<code>LinkedList</code></td><td>同步化的 <code>List</code></td></tr><tr><td><code>synchronizedSet(Set&lt;T&gt;)</code></td><td>将 Set 转换为线程安全集合</td><td><code>HashSet</code>、<code>LinkedHashSet</code></td><td>同步化的 <code>Set</code></td></tr><tr><td><code>synchronizedMap(Map&lt;K,V&gt;)</code></td><td>将 Map 转换为线程安全集合</td><td><code>HashMap</code>、<code>LinkedHashMap</code></td><td>同步化的 <code>Map</code></td></tr><tr><td><code>synchronizedSortedSet(SortedSet&lt;T&gt;)</code></td><td>将有序 Set 转换为线程安全集合</td><td><code>TreeSet</code></td><td>同步化的 <code>SortedSet</code></td></tr><tr><td><code>synchronizedSortedMap(SortedMap&lt;K,V&gt;)</code></td><td>将有序 Map 转换为线程安全集合</td><td><code>TreeMap</code></td><td>同步化的 <code>SortedMap</code></td></tr><tr><td><code>synchronizedCollection(Collection&lt;T&gt;)</code></td><td>将任意 Collection 转换为线程安全</td><td>所有 <code>Collection</code> 实现类</td><td>同步化的 <code>Collection</code></td></tr></tbody></table><h3 id="3-使用注意事项"><a href="#3-使用注意事项" class="headerlink" title="3. 使用注意事项"></a>3. 使用注意事项</h3><ul><li><p><strong>迭代操作的线程安全</strong>：</p><p>  虽然 <code>synchronizedXXX</code> 方法保证了单个方法的线程安全，但 <strong>迭代操作（如 <code>for-each</code>、<code>iterator</code>）仍需手动加锁</strong>。因为迭代过程涉及多次方法调用（如 <code>hasNext()</code>、<code>next()</code>），若不加锁，其他线程可能在迭代中修改集合，导致 <code>ConcurrentModificationException</code>。</p><p>  示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; syncList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"><span class="comment">// 迭代时需手动同步</span></span><br><span class="line"><span class="keyword">synchronized</span> (syncList) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String s : syncList) &#123;</span><br><span class="line">        <span class="comment">// 迭代操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>性能问题</strong>：</p><p>  由于所有方法都通过 <code>synchronized</code> 加锁，本质是 <strong>悲观锁</strong>，多线程高并发场景下可能因锁竞争导致性能瓶颈。此时推荐使用 <code>java.util.concurrent</code> 包下的并发集合（如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>），它们采用更高效的并发策略（如分段锁、写时复制）。</p></li><li><p><strong>原集合的可见性</strong>：</p><p>  包装后的线程安全集合会代理所有操作到原集合，因此 <strong>不应再直接操作原集合</strong>，否则会破坏线程安全性。</p></li><li><p><strong>null 值支持</strong>：</p><p>  包装后的集合是否支持 <code>null</code> 元素，取决于原集合（如 <code>synchronizedMap(HashMap)</code> 支持 <code>null</code> 键值，而 <code>synchronizedMap(TreeMap)</code> 不支持）。</p></li></ul><h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li><p>多线程环境下对集合的操作频率低、并发量小，且需要简单实现线程安全的场景。</p></li><li><p>需兼容旧有非线程安全集合，快速改造为线程安全的临时方案。</p></li><li><p>不适合高并发场景（推荐用 <code>java.util.concurrent</code> 并发集合），也不适合需要精细同步控制的场景。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Collections.synchronizedXXX</code> 是一种简单的线程安全集合实现方式，通过全局同步保证安全性，但存在性能限制和迭代需手动加锁的问题。使用时需根据并发量和性能需求，选择合适的集合类型。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者问题</title>
      <link href="/posts/19877.html"/>
      <url>/posts/19877.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>生产者 - 消费者问题是多线程同步与通信的经典案例。存在两类线程：</p><ul><li><p><strong>生产者线程</strong>：负责生成数据，将数据放入共享缓冲区。</p></li><li><p><strong>消费者线程</strong>：负责从共享缓冲区取出数据并进行处理。</p><p>  共享缓冲区作为两者传递数据的中介，需保证操作线程安全。</p></li></ul><h2 id="二、核心问题"><a href="#二、核心问题" class="headerlink" title="二、核心问题"></a>二、核心问题</h2><h3 id="（一）线程同步"><a href="#（一）线程同步" class="headerlink" title="（一）线程同步"></a>（一）线程同步</h3><p>多个线程（生产者和消费者）同时操作共享缓冲区时，要保证操作原子性，避免数据不一致。比如生产者添加数据时，消费者不能同时取数据；生产者修改数据过程中，消费者不能读 “半成品” 数据。</p><h3 id="（二）线程通信"><a href="#（二）线程通信" class="headerlink" title="（二）线程通信"></a>（二）线程通信</h3><ul><li>缓冲区满时，生产者应等待，直到消费者取出数据腾出空间。</li><li>缓冲区空时，消费者应等待，直到生产者放入数据。</li></ul><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><h3 id="（一）同步机制（以-synchronized-为例）"><a href="#（一）同步机制（以-synchronized-为例）" class="headerlink" title="（一）同步机制（以 synchronized 为例）"></a>（一）同步机制（以 <code>synchronized</code> 为例）</h3><p>通过给共享资源（如案例中的 <code>Queue</code> 对象）加锁，保证同一时间只有一个线程能操作它，解决线程同步问题。例如代码中用 <code>synchronized (q)</code> 确保生产者修改数据和消费者读取数据的操作互斥，避免数据不一致。</p><h3 id="（二）等待-通知机制（wait-和-notify-notifyAll-）"><a href="#（二）等待-通知机制（wait-和-notify-notifyAll-）" class="headerlink" title="（二）等待 - 通知机制（wait() 和 notify()&#x2F;notifyAll()）"></a>（二）等待 - 通知机制（<code>wait()</code> 和 <code>notify()</code>&#x2F;<code>notifyAll()</code>）</h3><ul><li><code>wait()</code>：使当前线程进入等待状态，释放对象锁，直到其他线程调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒。</li><li><code>notify()</code>：唤醒在此对象监视器上等待的单个线程。</li><li><code>notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</li></ul><p>在生产者 - 消费者模型中，缓冲区满时生产者调用 <code>wait()</code> 等待；消费者取出数据后，调用 <code>notify()</code> 通知生产者继续生产。缓冲区空时，消费者调用 <code>wait()</code> 等待，生产者放入数据后调用 <code>notify()</code> 通知消费者继续消费。</p><h2 id="四、代码示例与分析"><a href="#四、代码示例与分析" class="headerlink" title="四、代码示例与分析"></a>四、代码示例与分析</h2><h3 id="（一）基础同步代码（解决数据一致性）"><a href="#（一）基础同步代码（解决数据一致性）" class="headerlink" title="（一）基础同步代码（解决数据一致性）"></a>（一）基础同步代码（解决数据一致性）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1017;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> 生产者(q)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> 消费者(q)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String tools;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 生产者 <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    生产者(Queue q)&#123;</span><br><span class="line">        <span class="built_in">this</span>.q = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.name = <span class="string">&quot;蛋&quot;</span>;</span><br><span class="line">                    q.tools = <span class="string">&quot;平底锅&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.name = <span class="string">&quot;核桃&quot;</span>;</span><br><span class="line">                    q.tools = <span class="string">&quot;锤子&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i = (i + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 消费者 <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    消费者(Queue q)&#123;</span><br><span class="line">        <span class="built_in">this</span>.q = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (q) &#123;</span><br><span class="line">                System.out.println(q.name + <span class="string">&quot; -- &quot;</span> + q.tools);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该代码通过 <code>synchronized</code> 保证了数据一致性，消费者不会读到 “半成品” 数据，但存在线程 “忙等”（无意义循环，浪费 CPU 资源）问题。</li></ul><h3 id="（二）优化后的等待-通知代码"><a href="#（二）优化后的等待-通知代码" class="headerlink" title="（二）优化后的等待 - 通知代码"></a>（二）优化后的等待 - 通知代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1017;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> 生产者(q)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> 消费者(q)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String tools;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 生产者 <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    生产者(Queue q)&#123;</span><br><span class="line">        <span class="built_in">this</span>.q = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.name = <span class="string">&quot;蛋&quot;</span>;</span><br><span class="line">                    q.tools = <span class="string">&quot;平底锅&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.name = <span class="string">&quot;核桃&quot;</span>;</span><br><span class="line">                    q.tools = <span class="string">&quot;锤子&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i = (i + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">                q.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    q.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 消费者 <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    消费者(Queue q)&#123;</span><br><span class="line">        <span class="built_in">this</span>.q = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (q) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    q.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(q.name + <span class="string">&quot; -- &quot;</span> + q.tools);</span><br><span class="line">                q.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者生产完数据后，调用 <code>notify()</code> 通知消费者消费，然后自己调用 <code>wait()</code> 进入等待状态，释放锁。</li><li>消费者等待到通知后，消费数据，然后调用 <code>notify()</code> 通知生产者生产，自己再调用 <code>wait()</code> 进入等待状态。实现了生产者和消费者有序协作，避免无意义循环，提高系统资源利用效率。</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>生产者 - 消费者问题是理解多线程同步与通信的重要场景。通过同步机制保证线程安全，通过等待 - 通知机制实现线程间高效协作，能构建稳定、高效的多线程程序。实际开发中，还可使用更高级的并发工具（如 <code>BlockingQueue</code> 等）更简洁地实现生产者 - 消费者模型。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>死锁问题</title>
      <link href="/posts/23317.html"/>
      <url>/posts/23317.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、死锁问题"><a href="#一、死锁问题" class="headerlink" title="一、死锁问题"></a>一、死锁问题</h4><h5 id="1-死锁的定义"><a href="#1-死锁的定义" class="headerlink" title="1. 死锁的定义"></a>1. 死锁的定义</h5><p>死锁是指两个或多个线程相互持有对方所需的资源，且彼此都不释放已持有的资源，导致所有线程永久阻塞的状态。</p><h5 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2. 死锁产生的必要条件"></a>2. 死锁产生的必要条件</h5><ul><li><strong>互斥条件</strong>：资源只能被一个线程持有（不可共享）。</li><li><strong>持有并等待</strong>：线程持有部分资源，同时等待其他资源。</li><li><strong>不可剥夺</strong>：资源不能被强制剥夺，只能由持有线程主动释放。</li><li><strong>循环等待</strong>：线程间形成环形等待链（T1 等待 T2 的资源，T2 等待 T1 的资源）。</li></ul><h5 id="3-死锁示例（Java-代码）"><a href="#3-死锁示例（Java-代码）" class="headerlink" title="3. 死锁示例（Java 代码）"></a>3. 死锁示例（Java 代码）</h5><p>java</p><p>运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockExample</span> &#123;</span><br><span class="line">    <span class="comment">// 定义两个资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1：先获取resource1，再尝试获取resource2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 持有 resource1，尝试获取 resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟处理时间，让线程2有机会获取resource2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread1 同时持有 resource1 和 resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2：先获取resource2，再尝试获取resource1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 持有 resource2，尝试获取 resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟处理时间，让线程1有机会获取resource1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2 同时持有 resource1 和 resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>结果</strong>：两个线程会永久阻塞，不会执行完同步块内容。</li></ul><h5 id="4-死锁的解决方法"><a href="#4-死锁的解决方法" class="headerlink" title="4. 死锁的解决方法"></a>4. 死锁的解决方法</h5><ul><li><strong>破坏循环等待</strong>：统一资源获取顺序（如按资源 ID 从小到大获取）。</li><li><strong>破坏持有并等待</strong>：一次性获取所有所需资源。</li><li>**使用 tryLock ()**：尝试获取资源时设置超时，超时后释放已持有的资源。</li></ul><p>老师样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadThread</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadThread</span>();</span><br><span class="line">        <span class="type">DeadThread</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里设置r1的flag为false，但t1可能已进入循环，需注意线程执行时机</span></span><br><span class="line">        r1.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 静态对象作为共享资源（类级别，所有实例共享）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 无限循环，持续尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 先获取o1，再尝试获取o2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot; 这是if中的语句 锁是o1&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                        System.out.println(name + <span class="string">&quot; 这是if中的语句 锁是o2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 先获取o2，再尝试获取o1（与if分支顺序相反）</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot; 这是else语句 锁是o2&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                        System.out.println(name + <span class="string">&quot; 这是else语句 锁是o1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程分类（前台线程与后台线程）知识点笔记</title>
      <link href="/posts/18957.html"/>
      <url>/posts/18957.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念与分类"><a href="#一、概念与分类" class="headerlink" title="一、概念与分类"></a>一、概念与分类</h2><ol><li><p><strong>前台线程（用户线程）</strong></p><ul><li>定义：默认创建的线程类型，负责核心业务逻辑，是程序运行的主体。</li><li>特点：JVM 必须等待所有前台线程执行完毕才会退出，即使主线程结束，其他前台线程仍可继续运行。</li></ul></li><li><p><strong>后台线程（守护线程 &#x2F; Daemon Thread）</strong></p><ul><li>定义：为前台线程提供服务的辅助线程（如日志、监控、垃圾回收等）。</li><li>特点：依赖前台线程存在，当所有前台线程结束后，JVM 会强制终止所有后台线程，无需等待其执行完毕。</li></ul></li></ol><h2 id="二、核心区别"><a href="#二、核心区别" class="headerlink" title="二、核心区别"></a>二、核心区别</h2><table><thead><tr><th>对比项</th><th>前台线程</th><th>后台线程</th></tr></thead><tbody><tr><td>默认类型</td><td>是（创建后默认为此类型）</td><td>否（需显式设置）</td></tr><tr><td>JVM 退出条件</td><td>等待所有前台线程执行完毕</td><td>随最后一个前台线程结束而终止</td></tr><tr><td>作用</td><td>执行核心业务逻辑</td><td>提供辅助服务</td></tr></tbody></table><h2 id="三、后台线程的设置与注意事项"><a href="#三、后台线程的设置与注意事项" class="headerlink" title="三、后台线程的设置与注意事项"></a>三、后台线程的设置与注意事项</h2><ol><li><p><strong>设置方法</strong></p><ul><li><p>调用 <code>Thread</code> 类的 <code>setDaemon(boolean on)</code> 方法，参数为 <code>true</code> 时设置为后台线程。</p></li><li><p>示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; ... &#125;);</span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>); <span class="comment">// 设置为后台线程</span></span><br><span class="line">daemonThread.start(); <span class="comment">// 必须在启动前设置</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>关键限制</strong></p><ul><li><strong>设置时机</strong>：必须在 <code>start()</code> 方法调用前设置，否则会抛出 <code>IllegalThreadStateException</code>。</li><li><strong>继承性</strong>：若父线程是后台线程，子线程默认也是后台线程（可通过 <code>setDaemon()</code> 修改）。</li><li><strong>资源处理</strong>：后台线程被强制终止时，不会执行 <code>finally</code> 块中的资源释放逻辑，需谨慎处理资源。</li></ul></li></ol><h2 id="四、典型应用场景"><a href="#四、典型应用场景" class="headerlink" title="四、典型应用场景"></a>四、典型应用场景</h2><ul><li><strong>前台线程</strong>：用户交互线程（如 GUI 事件处理）、核心业务计算线程等。</li><li><strong>后台线程</strong>：垃圾回收线程（JVM 自带的后台线程）、日志输出线程、定时任务监控线程等。</li></ul><h2 id="五、示例说明（结合代码）"><a href="#五、示例说明（结合代码）" class="headerlink" title="五、示例说明（结合代码）"></a>五、示例说明（结合代码）</h2><ul><li>主线程（<code>main</code>）和 <code>FrontThread</code> 是前台线程，执行完毕后才会触发 JVM 退出判断。</li><li><code>DeadThread</code> 被设置为后台线程，当所有前台线程（<code>main</code> 和 <code>FrontThread</code>）结束后，即使其 500 次循环未完成，也会被强制终止。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>isolation：隔离级别</title>
      <link href="/posts/49474.html"/>
      <url>/posts/49474.html</url>
      
        <content type="html"><![CDATA[<p>，其中<strong>隔离级别（Isolation Level）</strong> 是控制多个并发事务之间数据可见性的关键属性。它决定了一个事务可能受到其他并发事务影响的程度。</p><h3 id="一、事务隔离级别的定义"><a href="#一、事务隔离级别的定义" class="headerlink" title="一、事务隔离级别的定义"></a>一、事务隔离级别的定义</h3><p>事务隔离级别是数据库为了处理并发访问而设计的规则，用于平衡<strong>数据一致性</strong>和<strong>并发性能</strong>。Spring 通过<code>@Transactional</code>的<code>isolation</code>属性指定隔离级别，其值对应数据库的标准隔离级别。</p><h3 id="二、Spring-支持的隔离级别（枚举：Isolation）"><a href="#二、Spring-支持的隔离级别（枚举：Isolation）" class="headerlink" title="二、Spring 支持的隔离级别（枚举：Isolation）"></a>二、Spring 支持的隔离级别（枚举：<code>Isolation</code>）</h3><p>Spring 定义了 5 种隔离级别，对应数据库的 SQL 标准：</p><ol><li><p><strong>DEFAULT（默认）</strong></p><ul><li>含义：使用数据库默认的隔离级别（大多数数据库默认是<code>READ_COMMITTED</code>，如 MySQL、SQL Server）。</li><li>使用场景：大多数情况下的默认选择，无需显式指定。</li></ul></li><li><p><strong>READ_UNCOMMITTED（读未提交）</strong></p><ul><li>含义：一个事务可以读取另一个未提交事务的数据。</li><li>问题：可能出现<strong>脏读</strong>（读取到未提交的无效数据）。</li><li>性能：最高（并发能力强），但一致性最低。</li></ul></li><li><p><strong>READ_COMMITTED（读已提交）</strong></p><ul><li>含义：一个事务只能读取另一个已提交事务的数据。</li><li>解决：避免<strong>脏读</strong>，但可能出现<strong>不可重复读</strong>（同一事务中多次读取同一数据，结果不一致）。</li><li>适用：大多数互联网应用，平衡了一致性和性能。</li></ul></li><li><p><strong>REPEATABLE_READ（可重复读）</strong></p><ul><li>含义：同一事务中多次读取同一数据，结果始终一致（不受其他事务提交影响）。</li><li>解决：避免<strong>脏读</strong>和<strong>不可重复读</strong>，但可能出现<strong>幻读</strong>（读取范围内的数据总量变化）。</li><li>备注：MySQL 的默认隔离级别（通过 MVCC 机制实现）。</li></ul></li><li><p><strong>SERIALIZABLE（串行化）</strong></p><ul><li>含义：事务完全串行执行（最严格的隔离），相当于单线程处理。</li><li>解决：避免所有并发问题（脏读、不可重复读、幻读）。</li><li>问题：性能极低，并发能力差。</li><li>适用：数据一致性要求极高的场景（如金融核心交易）。</li></ul></li></ol><h3 id="三、关键概念解释"><a href="#三、关键概念解释" class="headerlink" title="三、关键概念解释"></a>三、关键概念解释</h3><ul><li><strong>脏读</strong>：事务 A 读取了事务 B 未提交的数据，若 B 回滚，A 读取的数据无效。</li><li><strong>不可重复读</strong>：事务 A 多次读取同一数据，期间事务 B 修改并提交了该数据，导致 A 前后读取结果不一致。</li><li><strong>幻读</strong>：事务 A 读取某范围数据，期间事务 B 新增 &#x2F; 删除了该范围内的数据，导致 A 再次读取时结果行数变化。</li></ul><h3 id="四、-Transactional中隔离级别的使用示例"><a href="#四、-Transactional中隔离级别的使用示例" class="headerlink" title="四、@Transactional中隔离级别的使用示例"></a>四、<code>@Transactional</code>中隔离级别的使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Isolation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认隔离级别（推荐）</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserDefault</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式指定隔离级别为读已提交</span></span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserReadCommitted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式指定隔离级别为串行化（谨慎使用）</span></span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.SERIALIZABLE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserSerializable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h3><ol><li><strong>数据库支持</strong>：隔离级别依赖数据库实现，不同数据库可能有差异（如 PostgreSQL 的<code>REPEATABLE_READ</code>可避免幻读）。</li><li><strong>性能权衡</strong>：隔离级别越高，一致性越好，但并发性能越差，需根据业务场景选择。</li><li><strong>默认值推荐</strong>：无特殊需求时，使用<code>DEFAULT</code>即可，避免过度设计。</li><li><strong>与传播行为的区别</strong>：隔离级别控制并发数据可见性，而传播行为（<code>propagation</code>）控制事务的嵌套关系。</li></ol><p>通过合理设置隔离级别，可以在保证数据正确性的前提下，最大化系统的并发处理能力。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 事务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>propagation：传播行为</title>
      <link href="/posts/22633.html"/>
      <url>/posts/22633.html</url>
      
        <content type="html"><![CDATA[<p>事务传播行为（Propagation）定义了多个事务方法相互调用时，事务的创建、嵌套、隔离规则，核心解决 “方法调用时事务如何联动” 的问题。以下是 7 种传播行为及其特性的总结：</p><h3 id="1-REQUIRED（默认值）"><a href="#1-REQUIRED（默认值）" class="headerlink" title="1. REQUIRED（默认值）"></a>1. REQUIRED（默认值）</h3><ul><li><strong>特性</strong>：如果当前有事务，就加入该事务；如果没有，就新建一个事务。</li><li><strong>核心</strong>：“随大流”，所有操作合并到同一事务中，要么一起成功，要么一起回滚。</li><li><strong>场景</strong>：大多数业务场景（如订单创建时同时扣库存、减余额）。</li></ul><h3 id="2-SUPPORTS"><a href="#2-SUPPORTS" class="headerlink" title="2. SUPPORTS"></a>2. SUPPORTS</h3><ul><li><strong>特性</strong>：如果当前有事务，就加入；如果没有，就以非事务方式执行（不开启事务）。</li><li><strong>核心</strong>：“可选事务”，有无事务均可，不主动创建事务。</li><li><strong>场景</strong>：查询操作（如订单详情查询，有事务则参与，无则直接执行）。</li></ul><h3 id="3-MANDATORY"><a href="#3-MANDATORY" class="headerlink" title="3. MANDATORY"></a>3. MANDATORY</h3><ul><li><strong>特性</strong>：必须在已存在的事务中执行；如果当前没有事务，直接抛异常。</li><li><strong>核心</strong>：“强制依赖”，自己不创建事务，必须依赖上层调用者的事务。</li><li><strong>场景</strong>：核心操作（如资金扣减，必须在调用者的事务中执行，防止无事务时数据错乱）。</li></ul><h3 id="4-REQUIRES-NEW"><a href="#4-REQUIRES-NEW" class="headerlink" title="4. REQUIRES_NEW"></a>4. REQUIRES_NEW</h3><ul><li><strong>特性</strong>：无论当前是否有事务，都新建一个独立事务；若当前有事务，则先暂停原事务，新事务执行完再恢复。</li><li><strong>核心</strong>：“独立分家”，新事务与原事务完全隔离，各自独立提交 &#x2F; 回滚。</li><li><strong>场景</strong>：日志记录（主事务失败，日志仍需保存，避免丢失操作记录）。</li></ul><h3 id="5-NOT-SUPPORTED"><a href="#5-NOT-SUPPORTED" class="headerlink" title="5. NOT_SUPPORTED"></a>5. NOT_SUPPORTED</h3><ul><li><strong>特性</strong>：以非事务方式执行；若当前有事务，则暂停原事务，执行完后恢复。</li><li><strong>核心</strong>：“拒绝事务”，不参与任何事务，强制非事务执行。</li><li><strong>场景</strong>：耗时操作（如批量数据导出，避免事务长时间占用资源）。</li></ul><h3 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6. NEVER"></a>6. NEVER</h3><ul><li><strong>特性</strong>：必须以非事务方式执行；若当前有事务，直接抛异常。</li><li><strong>核心</strong>：“严格禁止事务”，比 NOT_SUPPORTED 更严格，不允许在事务中执行。</li><li><strong>场景</strong>：特殊操作（如某些不允许事务控制的脚本执行）。</li></ul><h3 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7. NESTED"></a>7. NESTED</h3><ul><li><strong>特性</strong>：如果当前有事务，就在嵌套事务中执行（依赖外层事务，有独立保存点）；如果没有，就新建事务（同 REQUIRED）。</li><li><strong>核心</strong>：“嵌套子事务”，外层事务回滚时，嵌套事务也回滚；但嵌套事务回滚时，外层事务可继续执行（通过保存点控制部分回滚）。</li><li><strong>场景</strong>：复杂业务中的分步操作（如订单提交时，优惠券扣减失败可单独回滚，不影响订单其他步骤）。</li></ul><h3 id="关键特性对比"><a href="#关键特性对比" class="headerlink" title="关键特性对比"></a>关键特性对比</h3><table><thead><tr><th>传播行为</th><th>是否创建新事务</th><th>与原事务的关系</th><th>回滚影响范围</th></tr></thead><tbody><tr><td>REQUIRED</td><td>按需创建</td><td>融入原事务，共享一个事务</td><td>一起回滚</td></tr><tr><td>REQUIRES_NEW</td><td>强制创建</td><td>独立事务，原事务被暂停</td><td>各自独立回滚</td></tr><tr><td>NESTED</td><td>嵌套在原事务中</td><td>依赖原事务，有独立保存点</td><td>外层回滚影响内层，内层回滚不影响外层</td></tr></tbody></table><p>理解传播行为的核心是：明确 “新方法是否需要事务”“与调用者事务的关系”“回滚时如何联动”，从而根据业务场景选择合适的规则，避免事务失效或数据不一致。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 事务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务管理细节</title>
      <link href="/posts/9450.html"/>
      <url>/posts/9450.html</url>
      
        <content type="html"><![CDATA[<h1 id="在-Spring-框架中，-Transactional注解用于声明事务管理"><a href="#在-Spring-框架中，-Transactional注解用于声明事务管理" class="headerlink" title="在 Spring 框架中，@Transactional注解用于声明事务管理"></a>在 Spring 框架中，<code>@Transactional</code>注解用于声明事务管理</h1><h2 id="一、事务管理器的原理"><a href="#一、事务管理器的原理" class="headerlink" title="一、事务管理器的原理"></a>一、事务管理器的原理</h2><h3 id="1、事务管理器（transactionManager）"><a href="#1、事务管理器（transactionManager）" class="headerlink" title="1、事务管理器（transactionManager）"></a>1、事务管理器（transactionManager）</h3><ul><li>作用：控制事务的获取、提交、回滚。</li><li>底层默认：<code>JdbcTransactionManager</code>。</li></ul><h3 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h3><ol><li>事务管理器（TransactionManager）：控制事务的提交和回滚。</li><li>事务拦截器（TransactionInterceptor）：控制事务何时提交和回滚。<ul><li>回滚触发：<code>completeTransactionAfterThrowing(txInfo, ex)</code>（方法执行出现异常时，执行回滚）。</li><li>提交触发：<code>commitTransactionAfterReturning(txInfo)</code>（方法正常返回时，执行提交）。</li></ul></li></ol><h2 id="二、timeout"><a href="#二、timeout" class="headerlink" title="二、timeout"></a>二、timeout</h2><ol><li>timeout（同 timeoutString）：超时时间，事务超时，秒为单位；</li></ol><p>一旦超过约定时间，事务就会回滚。<br>超时时间是指：从方法开始，到最后一次据库操作结束的时间。<br>写法可以是：</p><ol><li>@Transactional(timeout &#x3D; 3)</li><li>@Transactional(timeoutString &#x3D; “3”)<br> 效果相同</li></ol><h2 id="三、readOnly：只读优化（优化项，并不能控制什么）"><a href="#三、readOnly：只读优化（优化项，并不能控制什么）" class="headerlink" title="三、readOnly：只读优化（优化项，并不能控制什么）"></a>三、readOnly：只读优化（优化项，并不能控制什么）</h2><p>如果对数据库的操作都是只读的，开启可以优化操作速度。</p><p>写法：</p><ol><li>@Transactional(readOnly &#x3D; true&#x2F;false)</li></ol><h2 id="四、rollbackFor（同rollbackForClassName）"><a href="#四、rollbackFor（同rollbackForClassName）" class="headerlink" title="四、rollbackFor（同rollbackForClassName）"></a>四、rollbackFor（同rollbackForClassName）</h2><h3 id="1-rollbackFor-作用"><a href="#1-rollbackFor-作用" class="headerlink" title="1.rollbackFor 作用"></a>1.rollbackFor 作用</h3><p>指明哪些异常需要触发事务回滚（并非所有异常都必然导致回滚）。</p><h3 id="2-、异常分类"><a href="#2-、异常分类" class="headerlink" title="2.、异常分类"></a>2.、异常分类</h3><table><thead><tr><th>异常类型</th><th>说明</th></tr></thead><tbody><tr><td>运行时异常</td><td>unchecked exception（非受检异常）</td></tr><tr><td>编译时异常</td><td>checked exception（受检异常）</td></tr></tbody></table><h3 id="3-回滚默认机制"><a href="#3-回滚默认机制" class="headerlink" title="3.回滚默认机制"></a>3.回滚默认机制</h3><table><thead><tr><th>异常类型</th><th>回滚规则</th></tr></thead><tbody><tr><td>运行时异常</td><td>回滚</td></tr><tr><td>编译时异常</td><td>不回滚</td></tr></tbody></table><h3 id="4-写法："><a href="#4-写法：" class="headerlink" title="4.写法："></a>4.写法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;IOException.class&#125;, //IO异常</span></span><br><span class="line"><span class="meta">rollbackForClassName = &quot;java.lang.Exception&quot;)</span> <span class="comment">//所有异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;指定IO异常可以回滚<br>【可以指定哪些异常需要回滚】：<br>【回滚 &#x3D; 运行时异常 + 指定回滚异常】</p><h2 id="五、noRollbackFor（同noRollbackForClassName）"><a href="#五、noRollbackFor（同noRollbackForClassName）" class="headerlink" title="五、noRollbackFor（同noRollbackForClassName）"></a>五、noRollbackFor（同noRollbackForClassName）</h2><h3 id="1-noRollbackFor作用"><a href="#1-noRollbackFor作用" class="headerlink" title="1.noRollbackFor作用"></a>1.noRollbackFor作用</h3><p>指明哪些异常不需要回滚。<br>【不回滚 &#x3D; 编译时异常 + 指定回滚异常】</p><h3 id="2-写法"><a href="#2-写法" class="headerlink" title="2.写法"></a>2.写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(norollbackFor = &#123;ArithmeticException.class&#125;, //数学运算异常</span></span><br></pre></td></tr></table></figure><p>数学运算异常属于运行时异常，会回滚，用noRollbackFor之后，会不进行回滚。</p><h2 id="六、-isolation：隔离级别"><a href="#六、-isolation：隔离级别" class="headerlink" title="六、 isolation：隔离级别"></a>六、 <a href="isolation%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.md">isolation：隔离级别</a></h2><p>Spring 定义了 5 种隔离级别，对应数据库的 SQL 标准：</p><ol><li><p><strong>DEFAULT（默认）</strong></p><ul><li>含义：使用数据库默认的隔离级别（大多数数据库默认是<code>READ_COMMITTED</code>，如 MySQL、SQL Server）。</li><li>使用场景：大多数情况下的默认选择，无需显式指定。</li></ul></li><li><p><strong>READ_UNCOMMITTED（读未提交）</strong></p><ul><li>含义：一个事务可以读取另一个未提交事务的数据。</li><li>问题：可能出现<strong>脏读</strong>（读取到未提交的无效数据）。</li><li>性能：最高（并发能力强），但一致性最低。</li></ul></li><li><p><strong>READ_COMMITTED（读已提交）</strong></p><ul><li>含义：一个事务只能读取另一个已提交事务的数据。</li><li>解决：避免<strong>脏读</strong>，但可能出现<strong>不可重复读</strong>（同一事务中多次读取同一数据，结果不一致）。</li><li>适用：大多数互联网应用，平衡了一致性和性能。</li></ul></li><li><p><strong>REPEATABLE_READ（可重复读）</strong></p><ul><li>含义：同一事务中多次读取同一数据，结果始终一致（不受其他事务提交影响）。</li><li>解决：避免<strong>脏读</strong>和<strong>不可重复读</strong>，但可能出现<strong>幻读</strong>（读取范围内的数据总量变化）。</li><li>备注：MySQL 的默认隔离级别（通过 MVCC 机制实现）。</li></ul></li><li><p><strong>SERIALIZABLE（串行化）</strong></p><ul><li>含义：事务完全串行执行（最严格的隔离），相当于单线程处理。</li><li>解决：避免所有并发问题（脏读、不可重复读、幻读）。</li><li>问题：性能极低，并发能力差。</li><li>适用：数据一致性要求极高的场景（如金融核心交易）。</li></ul></li></ol><h2 id="七、-propagation：传播行为"><a href="#七、-propagation：传播行为" class="headerlink" title="七、[[propagation：传播行为]]"></a>七、[[propagation：传播行为]]</h2>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 事务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(注意)数组比较方法笔记</title>
      <link href="/posts/32612.html"/>
      <url>/posts/32612.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-x-y（引用比较）"><a href="#1-x-y（引用比较）" class="headerlink" title="1. x &#x3D;&#x3D; y（引用比较）"></a>1. x &#x3D;&#x3D; y（引用比较）</h2><ul><li><p><strong>本质</strong>：比较两个数组变量的内存地址是否相同</p></li><li><p><strong>核心逻辑</strong>：判断是否指向内存中同一个数组对象</p></li><li><p><strong>适用场景</strong>：检查两个数组变量是否引用同一个实例</p></li><li><p><strong>示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] b = a;      <span class="comment">// 指向同一对象</span></span><br><span class="line"><span class="type">int</span>[] c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">// 新对象，内容相同但地址不同</span></span><br><span class="line"></span><br><span class="line">a == b → <span class="literal">true</span></span><br><span class="line">a == c → <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>特点</strong>：与数组类型无关，仅关注引用是否相同</p></li></ul><h2 id="2-x-equals-y-（数组对象的-equals-方法）"><a href="#2-x-equals-y-（数组对象的-equals-方法）" class="headerlink" title="2. x.equals (y)（数组对象的 equals 方法）"></a>2. x.equals (y)（数组对象的 equals 方法）</h2><ul><li><p><strong>本质</strong>：继承自 Object 类的 equals 方法，等价于 x &#x3D;&#x3D; y</p></li><li><p><strong>核心逻辑</strong>：同样比较引用地址，而非数组内容</p></li><li><p><strong>适用场景</strong>：同 x &#x3D;&#x3D; y，无实际额外价值</p></li><li><p><strong>示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.equals(b) → <span class="literal">true</span>（同x == y）</span><br><span class="line">a.equals(c) → <span class="literal">false</span>（同x == y）</span><br></pre></td></tr></table></figure></li><li><p><strong>特点</strong>：数组未重写 equals 方法，行为与 &#x3D;&#x3D; 完全一致</p></li></ul><h2 id="3-Arrays-equals-x-y-（一维内容比较）"><a href="#3-Arrays-equals-x-y-（一维内容比较）" class="headerlink" title="3. Arrays.equals (x, y)（一维内容比较）"></a>3. Arrays.equals (x, y)（一维内容比较）</h2><ul><li><p><strong>本质</strong>：比较两个数组的内容是否完全一致</p></li><li><p><strong>核心逻辑</strong>：</p><ul><li>先比较数组长度是否相同</li><li>再逐一比较对应位置元素是否相等</li><li>对对象数组会调用元素的 equals () 方法</li></ul></li><li><p><strong>适用场景</strong>：一维数组的内容比较（基本类型 &#x2F; 对象类型均可）</p></li><li><p><strong>示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] y = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] z = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.equals(x,y) → <span class="literal">true</span>（长度+元素全相同）</span><br><span class="line">Arrays.equals(x,z) → <span class="literal">false</span>（元素顺序不同）</span><br></pre></td></tr></table></figure></li><li><p><strong>局限性</strong>：不支持多维数组（会比较子数组引用而非内容）</p></li></ul><h2 id="4-Arrays-deepEqual-x-y-（深度内容比较）"><a href="#4-Arrays-deepEqual-x-y-（深度内容比较）" class="headerlink" title="4. Arrays.deepEqual (x, y)（深度内容比较）"></a>4. Arrays.deepEqual (x, y)（深度内容比较）</h2><ul><li><p><strong>本质</strong>：递归比较数组内容，支持多维数组</p></li><li><p><strong>核心逻辑</strong>：</p><ul><li>对一维数组：行为同 Arrays.equals ()</li><li>对多维数组：递归比较每个子数组的内容</li></ul></li><li><h2 id="适用场景：-多维数组的内容比较-包含数组类型元素的对象数组比较"><a href="#适用场景：-多维数组的内容比较-包含数组类型元素的对象数组比较" class="headerlink" title="适用场景：  - 多维数组的内容比较  - 包含数组类型元素的对象数组比较"></a><strong>适用场景</strong>：<br>  - 多维数组的内容比较<br>  - 包含数组类型元素的对象数组比较</h2></li><li><p><strong>示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] m1 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] m2 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] m3 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">4</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.deepEqual(m1,m2) → <span class="literal">true</span>（深层内容相同）</span><br><span class="line">Arrays.deepEqual(m1,m3) → <span class="literal">false</span>（子数组内容不同）</span><br></pre></td></tr></table></figure></li><li><p><strong>特点</strong>：唯一能正确比较多维数组内容的方法</p></li></ul><h2 id="对比总结表"><a href="#对比总结表" class="headerlink" title="对比总结表"></a>对比总结表</h2><table><thead><tr><th>方法</th><th>比较对象</th><th>适用场景</th><th>多维数组支持</th><th>核心特点</th></tr></thead><tbody><tr><td>x &#x3D;&#x3D; y</td><td>引用地址</td><td>判断是否同一对象</td><td>不支持</td><td>最基础的内存地址比较</td></tr><tr><td>x.equals(y)</td><td>引用地址</td><td>同 x &#x3D;&#x3D; y</td><td>不支持</td><td>与 &#x3D;&#x3D; 完全等价，无特殊作用</td></tr><tr><td>Arrays.equals(x,y)</td><td>一维数组内容</td><td>比较一维数组是否完全相同</td><td>不支持</td><td>只比较表层元素，不递归</td></tr><tr><td>Arrays.deepEqual(x,y)</td><td>深层内容</td><td>多维数组内容比较</td><td>支持</td><td>递归比较所有层级的元素内容</td></tr></tbody></table><h2 id="关键使用原则"><a href="#关键使用原则" class="headerlink" title="关键使用原则"></a>关键使用原则</h2><ol><li>判断是否同一数组对象 → 用 x &#x3D;&#x3D; y（或 x.equals (y)，但推荐前者）</li><li>比较一维数组内容 → 用 Arrays.equals (x,y)</li><li>比较多维数组内容 → 必须用 Arrays.deepEqual (x,y)</li><li>内容比较时，顺序不同则认为不相等（均为顺序敏感比较）</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Collections 工具类与 Arrays 类常用方法笔记</title>
      <link href="/posts/30028.html"/>
      <url>/posts/30028.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Collections-工具类（操作集合）"><a href="#一、Collections-工具类（操作集合）" class="headerlink" title="一、Collections 工具类（操作集合）"></a>一、Collections 工具类（操作集合）</h2><h3 id="1-排序相关"><a href="#1-排序相关" class="headerlink" title="1. 排序相关"></a>1. 排序相关</h3><ul><li><code>sort(List&lt;T&gt; list)</code>：对 List 按自然排序（元素需实现 Comparable 接口）</li><li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>：按自定义比较器排序 List</li></ul><h3 id="2-查找与最值"><a href="#2-查找与最值" class="headerlink" title="2. 查找与最值"></a>2. 查找与最值</h3><ul><li><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code>：二分查找元素（需先排序）</li><li><code>max(Collection&lt;? extends T&gt; coll)</code>：获取集合中自然排序的最大元素</li><li><code>min(Collection&lt;? extends T&gt; coll)</code>：获取集合中自然排序的最小元素</li></ul><h3 id="3-集合操作"><a href="#3-集合操作" class="headerlink" title="3. 集合操作"></a>3. 集合操作</h3><ul><li><code>reverse(List&lt;?&gt; list)</code>：反转 List 中元素顺序</li><li><code>shuffle(List&lt;?&gt; list)</code>：随机打乱 List 元素</li><li><code>fill(List&lt;? super T&gt; list, T obj)</code>：用指定对象填充 List 所有元素</li><li><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code>：复制源 List 到目标 List</li><li><code>addAll(Collection&lt;? super T&gt; c, T... elements)</code>：向集合批量添加元素</li><li><code>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</code>：替换 List 中所有旧值为新值</li></ul><h3 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4. 线程安全"></a>4. 线程安全</h3><ul><li><code>synchronizedList(List&lt;T&gt; list)</code>：返回线程安全的 List</li><li><code>synchronizedMap(Map&lt;K,V&gt; m)</code>：返回线程安全的 Map</li><li><code>synchronizedSet(Set&lt;T&gt; s)</code>：返回线程安全的 Set</li></ul><h2 id="二、Arrays-工具类（操作数组）"><a href="#二、Arrays-工具类（操作数组）" class="headerlink" title="二、Arrays 工具类（操作数组）"></a>二、Arrays 工具类（操作数组）</h2><h3 id="1-排序相关-1"><a href="#1-排序相关-1" class="headerlink" title="1. 排序相关"></a>1. 排序相关</h3><ul><li><code>sort(int[] a)</code>：对基本类型数组排序（int、long 等均有重载）</li><li><code>sort(Object[] a)</code>：对对象数组排序（元素需实现 Comparable 接口）</li><li><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code>：按自定义比较器排序对象数组</li></ul><h3 id="2-查找相关"><a href="#2-查找相关" class="headerlink" title="2. 查找相关"></a>2. 查找相关</h3><ul><li><code>binarySearch(int[] a, int key)</code>：二分查找数组中元素（需先排序，基本类型均有重载）</li><li><code>binarySearch(Object[] a, Object key)</code>：二分查找对象数组中元素</li></ul><h3 id="3-数组转换"><a href="#3-数组转换" class="headerlink" title="3. 数组转换"></a>3. 数组转换</h3><ul><li><code>toString(int[] a)</code>：将数组转为字符串（如 “[1,2,3]”，基本类型均有重载）</li><li><code>asList(T... a)</code>：将数组转为 List（返回固定大小的 List，不可增删）</li><li><code>deepToString(Object[] a)</code>：将多维数组转为字符串</li></ul><h3 id="4-填充与复制"><a href="#4-填充与复制" class="headerlink" title="4. 填充与复制"></a>4. 填充与复制</h3><ul><li><code>fill(int[] a, int val)</code>：用指定值填充数组所有元素（基本类型均有重载）</li><li><code>copyOf(int[] original, int newLength)</code>：复制数组并指定新长度（基本类型均有重载）</li><li><code>copyOfRange(int[] original, int from, int to)</code>：复制数组指定范围元素（左闭右开）</li></ul><h3 id="5-判断与哈希"><a href="#5-判断与哈希" class="headerlink" title="5. 判断与哈希"></a>5. 判断与哈希</h3><ul><li><code>equals(int[] a, int[] a2)</code>：判断两个数组是否相等（长度 + 元素均相同，基本类型均有重载）</li><li><code>hashCode(int[] a)</code>：计算数组的哈希值</li></ul><h2 id="三、核心区别"><a href="#三、核心区别" class="headerlink" title="三、核心区别"></a>三、核心区别</h2><table><thead><tr><th>维度</th><th>Collections 工具类</th><th>Arrays 类</th></tr></thead><tbody><tr><td>操作对象</td><td>集合（List、Set、Map 等）</td><td>数组（基本类型数组、对象数组）</td></tr><tr><td>核心作用</td><td>增强集合功能（排序、同步、操作）</td><td>增强数组功能（排序、转换、复制）</td></tr><tr><td>典型场景</td><td>List 排序、集合线程安全化</td><td>数组转 List、数组排序</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 类 &amp; 接口 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 同步机制 synchronized</title>
      <link href="/posts/12960.html"/>
      <url>/posts/12960.html</url>
      
        <content type="html"><![CDATA[<p>在并发程序中，<strong>只有当多个线程争抢同一个锁对象时，才能实现对临界资源（共享资源）的同步控制</strong>。如果锁对象不同，多个线程会各自持有不同的锁，无法相互限制，会导致并发安全问题（如数据不一致、重复操作等）。</p><h3 id="核心逻辑：锁的-“互斥性”-依赖于-“同一把锁”"><a href="#核心逻辑：锁的-“互斥性”-依赖于-“同一把锁”" class="headerlink" title="核心逻辑：锁的 “互斥性” 依赖于 “同一把锁”"></a>核心逻辑：锁的 “互斥性” 依赖于 “同一把锁”</h3><ul><li><strong>相同锁</strong>：多个线程会排队等待获取这把锁，同一时间只有一个线程能执行同步代码（实现 “互斥”），从而保证共享资源的安全。</li><li><strong>不同锁</strong>：每个线程可以同时获取自己的锁，同步代码会被并发执行，无法保证共享资源的安全。</li></ul><h2 id="一、核心概念定义"><a href="#一、核心概念定义" class="headerlink" title="一、核心概念定义"></a>一、核心概念定义</h2><h3 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h3><ul><li><p><strong>本质</strong>：Java 提供的用于实现线程同步的核心关键字，是实现 “互斥” 和 “原子性” 的基础工具。</p></li><li><p><strong>作用</strong>：保证多个线程对共享资源的访问是 “串行执行” 的，避免并发安全问题（如数据不一致、重复操作）。</p></li><li><p><strong>适用场景</strong>：可作用于两个维度：</p></li><li><p>修饰方法：生成 “同步函数”；</p></li><li><p>修饰代码块：生成 “同步代码块”。</p></li></ul><h3 id="2-同步函数"><a href="#2-同步函数" class="headerlink" title="2. 同步函数"></a>2. 同步函数</h3><ul><li><strong>本质</strong>：被 synchronized 关键字修饰的方法，是 synchronized 的一种具体应用结果。</li></ul><p><strong>核心特性</strong>：</p><ul><li><p>同步范围：默认同步整个方法体，线程进入方法时获取锁，退出方法时释放锁；</p></li><li><p>锁对象固定：由方法类型（静态 &#x2F; 非静态）决定，不可自定义。</p></li></ul><h2 id="二、synchronized-与同步函数的关系（核心区分）"><a href="#二、synchronized-与同步函数的关系（核心区分）" class="headerlink" title="二、synchronized 与同步函数的关系（核心区分）"></a>二、synchronized 与同步函数的关系（核心区分）</h2><h3 id="1-包含与被包含关系"><a href="#1-包含与被包含关系" class="headerlink" title="1. 包含与被包含关系"></a>1. 包含与被包含关系</h3><ul><li>synchronized 是 “工具”，同步函数是 “工具的产物”：</li></ul><p>只有用 synchronized 修饰方法，才能生成同步函数；没有 synchronized，就不存在 “同步函数” 这一概念。</p><h3 id="2-关键区别（表格对比）"><a href="#2-关键区别（表格对比）" class="headerlink" title="2. 关键区别（表格对比）"></a>2. 关键区别（表格对比）</h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>对比维度</td><td>synchronized 关键字</td><td>同步函数</td></tr><tr><td>概念本质</td><td>同步工具（关键字）</td><td>被工具修饰的方法（应用结果）</td></tr><tr><td>作用范围</td><td>灵活：可修饰方法、可修饰代码块</td><td>固定：仅覆盖整个方法体</td></tr><tr><td>锁对象灵活性</td><td>修饰代码块时可自定义锁对象（如 new Object()）</td><td>锁对象固定（非静态→this，静态→类名.class）</td></tr><tr><td>核心能力</td><td>提供同步机制的 “基础能力”</td><td>借助 synchronized 实现 “方法级同步”</td></tr></tbody></table><h2 id="三、同步函数的分类与锁对象规则"><a href="#三、同步函数的分类与锁对象规则" class="headerlink" title="三、同步函数的分类与锁对象规则"></a>三、同步函数的分类与锁对象规则</h2><p>同步函数按 “是否静态” 分为两类，核心区别在于锁对象不同，这是保证同步的关键。</p><h3 id="1-非静态同步函数"><a href="#1-非静态同步函数" class="headerlink" title="1. 非静态同步函数"></a>1. 非静态同步函数</h3><ul><li><p><strong>锁对象</strong>：当前对象实例（this），即调用该方法的对象。</p></li><li><p><strong>等价转换</strong>：非静态同步函数本质是 “用 this 作为锁的同步代码块”，示例如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 非静态同步函数​</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;​</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;售票操作&quot;</span>);​</span><br><span class="line"></span><br><span class="line">&#125;​</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价的同步代码块（锁对象为 this）​</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;​</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;​</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;售票操作&quot;</span>);​</span><br><span class="line"></span><br><span class="line">&#125;​</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>适用场景</strong>：多线程操作 “同一对象实例的共享资源”（如同一售票窗口的票）。</li></ul><h3 id="2-静态同步函数"><a href="#2-静态同步函数" class="headerlink" title="2. 静态同步函数"></a>2. 静态同步函数</h3><ul><li><p><strong>锁对象</strong>：当前类的字节码对象（类名.class），一个类只有一个字节码对象，全局唯一。</p></li><li><p><strong>等价转换</strong>：静态同步函数本质是 “用 类名.class 作为锁的同步代码块”，示例如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 静态同步函数​</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;​</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;静态售票操作&quot;</span>);​</span><br><span class="line"></span><br><span class="line">&#125;​</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价的同步代码块（锁对象为 类名.class）​</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;​</span><br><span class="line"><span class="keyword">synchronized</span> (SaleThread.class) &#123;</span><br><span class="line">​</span><br><span class="line">System.out.println(<span class="string">&quot;静态售票操作&quot;</span>);​</span><br><span class="line"></span><br><span class="line">&#125;​</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>适用场景</strong>：多线程操作 “类级别的共享资源”（如静态变量、全局配置）。</li></ul><h2 id="四、同步的核心原则（保证线程安全的关键）"><a href="#四、同步的核心原则（保证线程安全的关键）" class="headerlink" title="四、同步的核心原则（保证线程安全的关键）"></a>四、同步的核心原则（保证线程安全的关键）</h2><h3 id="1-锁对象一致性原则"><a href="#1-锁对象一致性原则" class="headerlink" title="1. 锁对象一致性原则"></a>1. 锁对象一致性原则</h3><ul><li><p><strong>核心逻辑</strong>：多个线程要实现同步（互斥访问共享资源），必须争抢 “同一把锁”。</p></li><li><p>若锁对象相同：线程排队获取锁，同一时间只有一个线程执行同步代码，安全；</p></li><li><p>若锁对象不同：线程各自持有不同锁，同步代码并发执行，存在安全问题（如数据错误）。</p></li></ul><h3 id="2-不同场景的锁对象匹配示例"><a href="#2-不同场景的锁对象匹配示例" class="headerlink" title="2. 不同场景的锁对象匹配示例"></a>2. 不同场景的锁对象匹配示例</h3><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>场景</td><td>同步函数类型</td><td>同步代码块需用的锁对象</td><td>目的</td></tr><tr><td>非静态同步函数 + 同步代码块</td><td>非静态同步函数</td><td>this</td><td>保证同一对象的操作互斥</td></tr><tr><td>静态同步函数 + 同步代码块</td><td>静态同步函数</td><td>类名.class</td><td>保证类级别的操作互斥</td></tr></tbody></table><h2 id="五、常见误区与注意事项"><a href="#五、常见误区与注意事项" class="headerlink" title="五、常见误区与注意事项"></a>五、常见误区与注意事项</h2><ol><li><strong>误区 1：同步函数等同于 synchronized</strong></li></ol><p>错误：同步函数是 synchronized 的应用之一，synchronized 还能修饰代码块，两者不是同一概念。</p><ol start="2"><li><strong>误区 2：静态同步函数的锁是 this</strong></li></ol><p>错误：静态方法属于 “类”，不属于 “对象”，锁对象是 类名.class，而非 this（this 仅存在于非静态方法中）。</p><ol start="3"><li><strong>注意事项：同步范围并非越大越好</strong></li></ol><p>同步函数同步整个方法体，若方法中包含非共享资源操作，会导致 “锁粒度太大”，降低并发效率；此时建议用 synchronized 代码块，只同步 “共享资源相关的核心代码”。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 锁机制 &amp; 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表（如 HashMap）中的高效的位运算技巧</title>
      <link href="/posts/28462.html"/>
      <url>/posts/28462.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (n&lt;<span class="number">0</span>)?<span class="number">1</span>:(n&gt;=MAXMUM_CAPACITY ? MAXMUM_CAPACITY : n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用就是把我们传入的初始容量值 变成离他最近的而且是2的整数次方的值<br>17  –&gt; 32<br>16  –&gt;16<br>31  –&gt;32<br>33  –&gt;64</p><p>帮助理解：<br>    二进制 <code>10000000010</code> 对应的十进制是 1026，假设这就是 <code>cap-1</code> 的值（即 <code>n = 1026</code>），执行过程如下：</p><ol><li><p>初始 <code>n = 10000000010</code>（二进制）</p></li><li><p><code>n |= n &gt;&gt;&gt; 1</code><br> 右移 1 位得到 <code>01000000001</code>，按位或后结果为 <code>11000000011</code></p></li><li><p><code>n |= n &gt;&gt;&gt; 2</code><br> 右移 2 位得到 <code>00110000000</code>，按位或后结果为 <code>11110000011</code></p></li><li><p><code>n |= n &gt;&gt;&gt; 4</code><br> 右移 4 位得到 <code>00001111000</code>，按位或后结果为 <code>11111111011</code></p></li><li><p><code>n |= n &gt;&gt;&gt; 8</code><br> 右移 8 位得到 <code>00000000111</code>，按位或后结果为 <code>11111111111</code></p></li><li><p><code>n |= n &gt;&gt;&gt; 16</code><br> 右移 16 位后结果为 0，按位或后值不变</p></li><li><p>最终结果是二进制 <code>11111111111</code>（十进制 2047），这是大于等于 1026 的最小的 2 的幂次方减 1（2¹¹-1）。</p></li></ol><ul><li>注意：<code>cap - 1</code> 这一步的核心作用就是<strong>处理原始容量本身已经是 2 的幂次方的情况</strong>，确保最终计算结果正确。</li></ul><h4 id="根据哈希值-计算元素在桶中的索引"><a href="#根据哈希值-计算元素在桶中的索引" class="headerlink" title="根据哈希值 计算元素在桶中的索引"></a>根据哈希值 计算元素在桶中的索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h 就是哈希值 (经过扰动函数之后的)</span></span><br><span class="line"><span class="comment">//length 哈希桶的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> length)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return h%length</span></span><br><span class="line"><span class="keyword">return</span> h&amp;(length-<span class="number">1</span>);<span class="comment">//这个写法 相当于把h%length 前提是 length为2的整数次方</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 类 &amp; 接口 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库操作</title>
      <link href="/posts/61028.html"/>
      <url>/posts/61028.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作数据库："><a href="#操作数据库：" class="headerlink" title="操作数据库："></a>操作数据库：</h2><ul><li>1、导入包： spring-boot-starter-data-jdbc、mysql-connector-java</li><li>2、配置数据库连接信息：在 application.properties 中 spring.datasource.*</li><li>3、可以直接使用 DataSource、JdbcTemplate</li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 事务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP-总结</title>
      <link href="/posts/35434.html"/>
      <url>/posts/35434.html</url>
      
        <content type="html"><![CDATA[<p>AOP通过对逻辑的切入，在方法执行前后 对方法进行 修饰，包装，以及利用，可以达到很多效果（自己理解） </p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="模板化的业务逻辑（事务）"><a href="#模板化的业务逻辑（事务）" class="headerlink" title="模板化的业务逻辑（事务）"></a>模板化的业务逻辑（事务）</h3><ol><li>获取数据库连接</li><li>设置非自动提交</li><li>执行 SQL</li><li>&#x3D;&#x3D;封装返回值&#x3D;&#x3D;</li><li>正常：提交</li><li>异常：回滚</li><li>关闭链接</li></ol><h3 id="模板化的业务逻辑（权限）（假设使用-Role-“admin”-注解）"><a href="#模板化的业务逻辑（权限）（假设使用-Role-“admin”-注解）" class="headerlink" title="模板化的业务逻辑（权限）（假设使用 @Role (“admin”) 注解）"></a>模板化的业务逻辑（权限）（假设使用 @Role (“admin”) 注解）</h3><ol><li>拿到用户身份</li><li>拿到目标方法标注的所有注解</li><li>&#x3D;&#x3D;判定是否为注解指定的身份用户&#x3D;&#x3D;</li><li>是：执行目标方法</li><li>不是：记录非法请求</li></ol><h2 id="（AI）"><a href="#（AI）" class="headerlink" title="（AI）"></a>（AI）</h2><p>AOP（面向切面编程）在项目中主要用于解决系统中具有横切性质的问题，通过将分散在各个业务逻辑中的共性功能抽取出来，实现代码复用和关注点分离。以下是 AOP 在项目中常见的应用场景：</p><ol><li><p><strong>日志记录</strong></p><p> 无需在每个方法中手动编写日志代码，通过 AOP 可以统一拦截方法的调用，自动记录方法的入参、出参、执行时间、调用者信息等，便于系统调试和运维监控。</p></li><li><p><strong>权限验证</strong></p><p> 在接口调用前，通过 AOP 拦截请求，检查用户是否拥有访问权限（如登录状态、角色权限等），避免在每个接口中重复编写权限校验逻辑。</p></li><li><p><strong>事务管理</strong></p><p> 针对数据库操作，通过 AOP 在方法执行前开启事务，执行后根据结果提交或回滚事务，简化事务控制代码，确保数据一致性。</p></li><li><p><strong>异常处理</strong></p><p> 统一捕获方法执行过程中抛出的异常，进行标准化处理（如格式化错误信息、记录异常日志、返回友好提示等），减少代码中的 try-catch 冗余。</p></li><li><p><strong>性能监控</strong>【这个有专业】</p><p> 通过 AOP 统计方法的执行时间、调用频率等指标，分析系统瓶颈，例如监控接口响应时间、数据库查询耗时等。</p></li><li><p><strong>缓存处理</strong></p><p> 在方法调用前检查缓存中是否存在结果，存在则直接返回缓存数据；方法执行后将结果存入缓存，减少重复计算或数据库访问。</p></li><li><p><strong>数据校验</strong></p><p> 对方法入参进行统一校验（如参数合法性、格式正确性），不符合规则时直接拦截并返回错误，避免在业务逻辑中分散校验代码。</p></li><li><p><strong>分布式追踪</strong></p><p> 在微服务架构中，通过 AOP 在请求入口生成追踪 ID，并在服务调用链中传递，结合日志实现全链路追踪，便于排查跨服务问题。</p></li></ol><p>AOP 的核心价值在于<strong>解耦</strong>，让业务代码专注于核心逻辑，而将通用功能（如日志、权限）以切面的形式独立维护，提升代码的可维护性和扩展性。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BeanFactory 核心集合</title>
      <link href="/posts/13048.html"/>
      <url>/posts/13048.html</url>
      
        <content type="html"><![CDATA[<p>记 BeanFactory 核心集合，记住这 5 个核心 “仓库”：</p><ol><li><strong>Bean 定义仓库</strong>：<code>beanDefinitionMap</code>（存蓝图）+ <code>beanDefinitionNames</code>（记顺序）</li><li><strong>单例成品仓库</strong>：<code>singletonObjects</code>（存可用的单例 Bean）</li><li><strong>单例半成品仓库</strong>：<code>earlySingletonObjects</code>（存未完成的单例，解决循环依赖）</li><li><strong>单例工厂仓库</strong>：<code>singletonFactories</code>（生产半成品的工厂）</li><li><strong>关系仓库</strong>：<code>aliasMap</code>（别名）+ 两个依赖 Map（记谁依赖谁）</li></ol><p>一句话锚点：**”定义排好队，成品半成品分开存，工厂负责造半成品，关系网要记牢”**<br><img src="/2025-10-14_19-23-12-0.png" alt="2025-10-14_19-23-12-0.png"></p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP-流程 &amp; AOP-连接点 &amp; AOP-@Pointcut()</title>
      <link href="/posts/1348.html"/>
      <url>/posts/1348.html</url>
      
        <content type="html"><![CDATA[<p>单切面：<br>    正常链路：前置通知 -&gt; 目标方法执行 -&gt; 返回通知 -&gt; 后置通知<br>    异常链路：前置通知 -&gt; 目标方法执行 -&gt; 异常通知 -&gt; 后置通知<br>多切面：<br>    按照切面优先级，@Order(1) 指定优先级，数字越小优先级越高，越是代理最外层<br>后置像finally一样一定执行</p><p>![[2025-10-10_19-34-37-0.png]]</p><p>JoinPoint连接点信息，<br>&#x2F;** </p><ul><li>告诉Spring当前类是一个切面类  </li><li>告诉Spring，以下通知方法，何时何地被调用  </li><li>何时？  </li><li>@Before 在目标方法之前运行  </li><li>@After 在目标方法之后运行  </li><li>@AfterReturning 运行在目标方法正常返回之后  </li><li>@AfterThrowing 运行在目标方法抛出异常之后  </li><li>@Around  以上的四合一，可以修改返回值</li><li>何地？  </li><li>execution(public * com.atguigu.spring.aop.<em>.</em>(..))<br>*&#x2F;</li></ul><p><code>@Pointcut</code> 是 Spring AOP 中用于<strong>定义切入点</strong>的注解，它可以精确指定哪些方法需要被增强（织入通知逻辑）。其核心作用是<strong>集中定义切入点表达式</strong>，供 <code>@Before</code>、<code>@After</code>、<code>@Around</code> 等通知注解复用，避免重复编写表达式。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li><strong>定义切入点</strong>：在一个&#x3D;&#x3D;空方法&#x3D;&#x3D;上使用 <code>@Pointcut</code>，方法体通常为空（仅作为切入点的 “标识”）。</li><li><strong>引用切入点</strong>：在通知注解中通过方法名引用该切入点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 标识这是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义切入点：匹配 com.example.service 包下所有类的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethod</span><span class="params">()</span> &#123;&#125; <span class="comment">// 方法名即切入点标识，无实际逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 引用切入点：对 serviceMethod() 匹配的方法执行前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;serviceMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeService</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前的日志...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于-Around的注意"><a href="#对于-Around的注意" class="headerlink" title="对于@Around的注意"></a>对于@Around的注意</h3><p><img src="/2025-10-14_23-26-19-0.png" alt="2025-10-14_23-26-19-0.png"><br>如图所示，此时如果目标方法异常，环绕通知给出的是 异常通知，而日志通知则给出的是 返回通知，并没有报错。</p><p>原因：<br>    此时，环绕通知 对于 日志 来说，就相当于目标方法，也就是说，环绕通知 是 日志的目标方法，环绕通知 此时用 try-catch 把异常“吞”掉了，所以对于 日志来说，是没有异常的。<br>所以，为了 多切面情况下异常感知链路是通的，建议环绕通知一定抛出异常。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP-代理对象执行顺序</title>
      <link href="/posts/24360.html"/>
      <url>/posts/24360.html</url>
      
        <content type="html"><![CDATA[<p><img src="/2025-10-10_20-26-07-0.png" alt="2025-10-10_20-26-07-0.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span> 注解  优先级</span><br></pre></td></tr></table></figure><p>核心规则是：<strong>数字越小，优先级越高</strong>（即高优先级切面的通知先执行 “前置逻辑”，后执行 “后置逻辑”）。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP-实现步骤 &amp; 切入点表达式语法</title>
      <link href="/posts/11398.html"/>
      <url>/posts/11398.html</url>
      
        <content type="html"><![CDATA[<p>![[Pasted image 20251003194032.png]]</p><h3 id="切入点表达式语法"><a href="#切入点表达式语法" class="headerlink" title="切入点表达式语法"></a>切入点表达式语法</h3><p><code>@Pointcut</code> 的值是<strong>切入点表达式</strong>，用于匹配目标方法。常用语法有：</p><h4 id="1-execution-：最常用，按方法签名匹配"><a href="#1-execution-：最常用，按方法签名匹配" class="headerlink" title="1. execution()：最常用，按方法签名匹配"></a>1. <code>execution()</code>：最常用，按方法签名匹配</h4><p>语法：<code>execution(修饰符 返回值 包名.类名.方法名(参数) 异常)</code></p><p>通配符：</p><ul><li><code>*</code>：匹配任意字符（如任意返回值、任意方法名）</li><li><code>..</code>：匹配任意层级的包或任意参数（如 <code>com.example..*</code> 表示 <code>com.example</code> 下所有子包）</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配 com.example.service 包下所有类的 public 方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(public * com.example.service.*.*(..))&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 com.example.dao 包及子包下所有类的任意方法（返回值为 String）</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(String com.example.dao..*.*(..))&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 UserService 类中参数为 (String, int) 的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.example.service.UserService.*(String, int))&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="2-within-：按类-包匹配（比-execution-更粗粒度）"><a href="#2-within-：按类-包匹配（比-execution-更粗粒度）" class="headerlink" title="2. within()：按类 &#x2F; 包匹配（比 execution 更粗粒度）"></a>2. <code>within()</code>：按类 &#x2F; 包匹配（比 <code>execution</code> 更粗粒度）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配 com.example.service 包下所有类的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.example.service.*)&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 com.example.service 包及子包下所有类的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.example.service..*)&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="3-annotation-：按方法上的注解匹配"><a href="#3-annotation-：按方法上的注解匹配" class="headerlink" title="3. @annotation()：按方法上的注解匹配"></a>3. <code>@annotation()</code>：按方法上的注解匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有标注了 @Log 注解的方法（自定义注解）</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.example.annotation.Log)&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="4-args-：按方法参数类型匹配"><a href="#4-args-：按方法参数类型匹配" class="headerlink" title="4. args()：按方法参数类型匹配"></a>4. <code>args()</code>：按方法参数类型匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个参数为 String 类型的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;args(String, ..)&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配参数类型为 User 且有 @Valid 注解的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;args(@javax.validation.Valid com.example.entity.User)&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="5-bean-：按-Spring-容器中的-Bean-名称匹配"><a href="#5-bean-：按-Spring-容器中的-Bean-名称匹配" class="headerlink" title="5. bean()：按 Spring 容器中的 Bean 名称匹配"></a>5. <code>bean()</code>：按 Spring 容器中的 Bean 名称匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配名称为 &quot;userService&quot; 的 Bean 的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;bean(userService)&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配名称以 &quot;Service&quot; 结尾的 Bean 的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;bean(*Service)&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="组合切入点"><a href="#组合切入点" class="headerlink" title="组合切入点"></a>组合切入点</h3><p>通过逻辑运算符（<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>）组合多个切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配 service 包中且标注了 @Log 的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.example.service..*) &amp;&amp; @annotation(com.example.annotation.Log)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceWithLog</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 service 包或 dao 包中的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.example.service..*) || within(com.example.dao..*)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceOrDao</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li><code>@Pointcut</code> 必须定义在<strong>切面类</strong>（<code>@Aspect</code> 标注的类）中。</li><li>切入点方法的访问修饰符通常为 <code>public</code>，返回值为 <code>void</code>，方法名自定义（作为引用标识）。</li><li>表达式优先级：<code>execution</code> &gt; <code>within</code> &gt; <code>bean</code>（从细到粗），按需选择合适的粒度。</li></ul><p>通过 <code>@Pointcut</code> 可以清晰、灵活地定义需要增强的目标方法，是 AOP 中 “面向切面” 思想的核心实现。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三层缓存机制-Spring容器</title>
      <link href="/posts/12910.html"/>
      <url>/posts/12910.html</url>
      
        <content type="html"><![CDATA[<p>三级缓存【源码】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;  </span><br><span class="line">    <span class="comment">// 1. 先从一级缓存（成品单例）中获取</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 如果一级缓存中没有，且当前Bean正在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">        <span class="comment">// 2.1 从二级缓存（早期单例）中获取</span></span><br><span class="line">        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.2 如果二级缓存中没有，且允许早期引用</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;  </span><br><span class="line">            <span class="comment">// 加锁保证线程安全</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonLock.tryLock()) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// 双重检查：再次从一级缓存确认</span></span><br><span class="line">                singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    <span class="comment">// 再次从二级缓存确认</span></span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);  </span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="comment">// 3. 从三级缓存（单例工厂）中获取工厂</span></span><br><span class="line">                        ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="built_in">this</span>.singletonFactories.get(beanName);  </span><br><span class="line">                        <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;  </span><br><span class="line">                            <span class="comment">// 3.1 通过工厂生成早期实例</span></span><br><span class="line">                            singletonObject = singletonFactory.getObject();  </span><br><span class="line">                            <span class="comment">// 3.2 从三级缓存移除工厂，将实例放入二级缓存</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">this</span>.singletonFactories.remove(beanName) != <span class="literal">null</span>) &#123;  </span><br><span class="line">                                <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);  </span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                                <span class="comment">// 兜底：再次从一级缓存获取（防止并发问题）</span></span><br><span class="line">                                singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                <span class="built_in">this</span>.singletonLock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> singletonObject;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025-10-14_20-05-59-0.png" alt="源码"></p><p>图解：<br><img src="/2025-10-14_20-38-50-0.png" alt="2025-10-14_20-38-50-0.png"><br>单例对象池【成品区】<br>早期单例对象池【半成品区】<br>单例工厂【实现了ObjectFactory接口的】</p><p><img src="/2025-10-14_19-55-41-0.png" alt="2025-10-14_19-55-41-0.png"></p><p>Spring 的三层缓存机制是解决<strong>单例 Bean 循环依赖</strong>的核心方案，通过三级缓存分层存储不同状态的 Bean 实例，既保证了单例唯一性，又避免了循环依赖导致的死锁或实例不完整问题。</p><p>三层缓存从上到下（查询顺序）依次是：</p><ol><li><p><strong>一级缓存（singletonObjects）</strong></p><ul><li>存储<strong>完全初始化完成</strong>的单例 Bean 实例（已注入依赖、执行完初始化方法）。</li><li>这是最终可用的 “成品” 缓存，优先查询，命中即返回。</li></ul></li><li><p><strong>二级缓存（earlySingletonObjects）</strong></p><ul><li>存储<strong>已实例化但未完全初始化</strong>的单例 Bean 实例（如刚创建对象，还没注入依赖）。</li><li>是 “半成品” 缓存，用于临时存放提前暴露的实例，解决循环依赖时的临时引用。</li></ul></li><li><p><strong>三级缓存（singletonFactories）</strong></p><ul><li>存储<strong>单例 Bean 的工厂对象（ObjectFactory）</strong>，工厂的作用是生成 Bean 的早期实例（放入二级缓存）。</li><li>当 Bean 实例化后，Spring 会创建一个工厂并放入此缓存，延迟生成早期实例，避免不必要的提前暴露。</li></ul></li></ol><h3 id="核心流程（以-A-依赖-B，B-依赖-A-为例）："><a href="#核心流程（以-A-依赖-B，B-依赖-A-为例）：" class="headerlink" title="核心流程（以 A 依赖 B，B 依赖 A 为例）："></a>核心流程（以 A 依赖 B，B 依赖 A 为例）：</h3><ol><li>A 实例化后，将生成 A 的工厂放入三级缓存。</li><li>A 需要注入 B，此时去创建 B。</li><li>B 实例化后，将生成 B 的工厂放入三级缓存。</li><li>B 需要注入 A，从三级缓存取出 A 的工厂，生成 A 的早期实例放入二级缓存，同时移除三级缓存的 A 工厂。</li><li>B 注入 A 后完成初始化，放入一级缓存。</li><li>A 注入 B 后完成初始化，放入一级缓存，同时移除二级缓存的 A 早期实例。</li></ol><p><strong>一句话记忆</strong>：</p><p>三级缓存 “工厂造半成品，二级存半成品，一级存成品”，通过分层缓存解决了循环依赖中 “先有鸡还是先有蛋” 的问题。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架中的工具类</title>
      <link href="/posts/10084.html"/>
      <url>/posts/10084.html</url>
      
        <content type="html"><![CDATA[<p><code>AnnotationUtils</code>类<br><code>ClassUtils</code>类<br><code>TypeUtils</code>类<br><code>ReflectionUtils</code>类</p><p>在 Spring 框架中，<code>AnnotationUtils</code>、<code>ClassUtils</code>、<code>TypeUtils</code> 和 <code>ReflectionUtils</code> 都是工具类，主要用于简化 Java 反射、注解处理、类操作等底层逻辑。它们封装了大量繁琐的反射 API 和类型处理逻辑，是 Spring 内部实现的重要支撑，也常被开发者在业务代码中直接使用。</p><h3 id="1-AnnotationUtils（注解工具类）"><a href="#1-AnnotationUtils（注解工具类）" class="headerlink" title="1. AnnotationUtils（注解工具类）"></a>1. <code>AnnotationUtils</code>（注解工具类）</h3><p><strong>作用</strong>：专门用于处理 Java 注解的工具类，提供注解查找、属性提取、注解继承等功能，解决了 Java 原生反射在处理注解时的诸多限制（如无法直接获取继承的注解）。</p><p><strong>核心功能</strong>：</p><ul><li>查找类、方法、字段上的注解（包括继承的注解）。</li><li>提取注解的属性值，支持默认值处理。</li><li>判断注解是否存在或匹配特定类型。</li><li>处理注解的组合（组合注解）和元注解。</li></ul><p><strong>常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类上的注解（包括父类继承的）</span></span><br><span class="line"><span class="type">Annotation</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(User.class, Service.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法上的注解属性值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> AnnotationUtils.getValue(method.getAnnotation(RequestMapping.class), <span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断注解是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasAnnotation</span> <span class="operator">=</span> AnnotationUtils.isAnnotationPresent(bean.getClass(), Component.class);</span><br></pre></td></tr></table></figure><h3 id="2-ClassUtils（类操作工具类）"><a href="#2-ClassUtils（类操作工具类）" class="headerlink" title="2. ClassUtils（类操作工具类）"></a>2. <code>ClassUtils</code>（类操作工具类）</h3><p><strong>作用</strong>：处理类和类加载器相关的工具类，提供类名解析、类加载、类型判断等功能，简化类层面的操作。</p><p><strong>核心功能</strong>：</p><ul><li>解析类名（如处理数组、内部类的类名格式）。</li><li>安全地加载类（封装类加载器逻辑，避免 <code>ClassNotFoundException</code> 直接抛出）。</li><li>判断类的类型关系（如是否为接口、是否为数组、是否为基本类型）。</li><li>获取类的包名、简单类名，处理类的继承关系。</li></ul><p><strong>常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载类（默认使用线程上下文类加载器）</span></span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.forName(<span class="string">&quot;com.example.User&quot;</span>, ClassUtils.class.getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为集合类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isCollection</span> <span class="operator">=</span> ClassUtils.isAssignable(clazz, Collection.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的简单名称（处理内部类，如 &quot;User$Address&quot; → &quot;User.Address&quot;）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">simpleName</span> <span class="operator">=</span> ClassUtils.getShortName(clazz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的包名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> ClassUtils.getPackageName(clazz);</span><br></pre></td></tr></table></figure><h3 id="3-TypeUtils（类型工具类）"><a href="#3-TypeUtils（类型工具类）" class="headerlink" title="3. TypeUtils（类型工具类）"></a>3. <code>TypeUtils</code>（类型工具类）</h3><p><strong>作用</strong>：处理 Java 泛型类型（<code>Type</code>）的工具类，主要用于解析泛型类型信息（如泛型参数、通配符等），解决了原生反射中泛型类型擦除导致的信息获取困难问题。</p><p><strong>核心功能</strong>：</p><ul><li>解析泛型类型（如从 <code>List&lt;String&gt;</code> 中提取实际类型参数 <code>String</code>）。</li><li>判断两个类型是否兼容（考虑泛型通配符，如 <code>List&lt;? extends Number&gt;</code> 与 <code>List&lt;Integer&gt;</code> 是否兼容）。</li><li>处理类型变量（<code>TypeVariable</code>）、参数化类型（<code>ParameterizedType</code>）等复杂类型。</li></ul><p><strong>常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取泛型接口的实际类型参数（如 List&lt;String&gt; → String）</span></span><br><span class="line">Type[] typeArgs = TypeUtils.getTypeArguments(list.getClass(), List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断类型是否兼容（如 Integer 是否兼容 Number）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isCompatible</span> <span class="operator">=</span> TypeUtils.isAssignable(Integer.class, Number.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析字段的泛型类型（如 Map&lt;String, Integer&gt; 字段的类型参数）</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> User.class.getField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">fieldType</span> <span class="operator">=</span> (ParameterizedType) field.getGenericType();</span><br><span class="line"><span class="type">Type</span> <span class="variable">keyType</span> <span class="operator">=</span> fieldType.getActualTypeArguments()[<span class="number">0</span>]; <span class="comment">// String</span></span><br></pre></td></tr></table></figure><h3 id="4-ReflectionUtils（反射工具类）"><a href="#4-ReflectionUtils（反射工具类）" class="headerlink" title="4. ReflectionUtils（反射工具类）"></a>4. <code>ReflectionUtils</code>（反射工具类）</h3><p><strong>作用</strong>：封装 Java 反射 API 的工具类，简化字段、方法、构造器的访问和操作，自动处理访问权限（如突破 <code>private</code> 修饰符的限制）。</p><p><strong>核心功能</strong>：</p><ul><li>获取类的字段、方法（包括私有成员）。</li><li>调用方法（包括私有方法）、设置 &#x2F; 获取字段值（包括私有字段）。</li><li>遍历类的方法或字段，支持过滤条件。</li><li>处理反射操作中的异常（将检查型异常转为非检查型异常）。</li></ul><p><strong>常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的私有字段并设置值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ReflectionUtils.findField(User.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">ReflectionUtils.makeAccessible(field); <span class="comment">// 突破 private 限制</span></span><br><span class="line">ReflectionUtils.setField(field, user, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用类的私有方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReflectionUtils.findMethod(User.class, <span class="string">&quot;privateMethod&quot;</span>, String.class);</span><br><span class="line">ReflectionUtils.invokeMethod(method, user, <span class="string">&quot;参数&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历类的所有方法（含父类）</span></span><br><span class="line">ReflectionUtils.doWithMethods(User.class, method -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法名：&quot;</span> + method.getName());</span><br><span class="line">&#125;, method -&gt; method.getParameterCount() == <span class="number">0</span>); <span class="comment">// 过滤无参方法</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这四个工具类分工明确，共同解决了 Java 反射和类型处理中的常见问题：</p><ul><li><code>AnnotationUtils</code> → 专注注解处理</li><li><code>ClassUtils</code> → 专注类和类加载器操作</li><li><code>TypeUtils</code> → 专注泛型类型解析</li><li><code>ReflectionUtils</code> → 专注字段、方法的反射操作</li></ul><p>它们在 Spring 内部被广泛用于框架实现（如注解扫描、依赖注入、AOP 代理等），同时也为开发者提供了简洁的 API，避免重复编写复杂的反射逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口</title>
      <link href="/posts/35204.html"/>
      <url>/posts/35204.html</url>
      
        <content type="html"><![CDATA[<p>当接口中 只有一个抽象方法的时候  可以用@FunctionalInterface 注解声明为函数式接口</p><p>凡是声明为函数式接口的接口 都可以用lambda表达式来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> atestdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用lambda表达式传参+函数式接口</span></span><br><span class="line">test(()-&gt;System.out.println(<span class="string">&quot;当...刀卷刃了&quot;</span>));</span><br><span class="line">test(()-&gt;System.out.println(<span class="string">&quot;刷...斩钢碎石&quot;</span>));</span><br><span class="line">test(()-&gt;System.out.println(<span class="string">&quot;不灵不灵...一刀999&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(刀 dao)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;准备............&quot;</span>);</span><br><span class="line">dao.cut();</span><br><span class="line">System.out.println(<span class="string">&quot;结束............&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">interface 刀&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 类 &amp; 接口 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Collection &amp; List接口</title>
      <link href="/posts/15543.html"/>
      <url>/posts/15543.html</url>
      
        <content type="html"><![CDATA[<p>代码中使用的<code>Vector</code>、<code>ArrayList</code>、<code>Stack</code>、<code>LinkedList</code>均属于 Java 集合框架中的<strong>List 接口实现类</strong>（<code>Stack</code>继承自<code>Vector</code>），它们都实现了<code>Collection</code>接口的所有方法，因此基础功能一致。但由于底层数据结构不同，它们在特性和适用场景上存在差异。以下是它们的对比整理：</p><h3 id="一、共性（均实现-Collection-List-接口）"><a href="#一、共性（均实现-Collection-List-接口）" class="headerlink" title="一、共性（均实现 Collection&#x2F;List 接口）"></a>一、共性（均实现 Collection&#x2F;List 接口）</h3><p>所有类都支持以下核心方法（来自<code>Collection</code>和<code>List</code>接口）：</p><table><thead><tr><th>方法分类</th><th>核心方法</th></tr></thead><tbody><tr><td><strong>添加元素</strong></td><td><code>add(E e)</code>、<code>addAll(Collection&lt;? extends E&gt; c)</code></td></tr><tr><td><strong>删除元素</strong></td><td><code>remove(Object o)</code>、<code>removeAll(Collection&lt;?&gt; c)</code>、<code>clear()</code>、<code>remove(int index)</code>（List 特有）</td></tr><tr><td><strong>查询判断</strong></td><td><code>contains(Object o)</code>、<code>containsAll(Collection&lt;?&gt; c)</code>、<code>size()</code>、<code>isEmpty()</code></td></tr><tr><td><strong>交集操作</strong></td><td><code>retainAll(Collection&lt;?&gt; c)</code></td></tr><tr><td><strong>遍历 &#x2F; 转换</strong></td><td><code>iterator()</code>、<code>toArray()</code>、<code>get(int index)</code>（List 特有，按索引访问）</td></tr></tbody></table><h3 id="二、特性差异（底层结构与核心区别）"><a href="#二、特性差异（底层结构与核心区别）" class="headerlink" title="二、特性差异（底层结构与核心区别）"></a>二、特性差异（底层结构与核心区别）</h3><table><thead><tr><th>集合类</th><th>底层数据结构</th><th>线程安全性</th><th>读写效率特点</th><th>特有方法（部分）</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Vector</strong></td><td>动态数组（数组）</td><td>线程安全（方法加锁）</td><td>增删效率低（需扩容 &#x2F; 移位），查询效率高（索引访问）</td><td><code>addElement(E obj)</code>、<code>elementAt(int index)</code></td><td>多线程环境，需线程安全时</td></tr><tr><td><strong>ArrayList</strong></td><td>动态数组（数组）</td><td>线程不安全</td><td>增删效率低（同 Vector），查询效率高</td><td>无特有方法（完全实现 List 接口）</td><td>单线程环境，查询操作频繁时</td></tr><tr><td><strong>Stack</strong></td><td>动态数组（继承 Vector）</td><td>线程安全</td><td>基于栈结构（LIFO），尾部操作效率高</td><td><code>push(E item)</code>、<code>pop()</code>、<code>peek()</code></td><td>需要栈结构（先进后出）操作时</td></tr><tr><td><strong>LinkedList</strong></td><td>双向链表</td><td>线程不安全</td><td>增删效率高（无需移位），查询效率低（需遍历）</td><td><code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code></td><td>增删操作频繁，尤其是首尾操作</td></tr></tbody></table><h3 id="三、关键区别总结"><a href="#三、关键区别总结" class="headerlink" title="三、关键区别总结"></a>三、关键区别总结</h3><ol><li><strong>线程安全</strong>：仅<code>Vector</code>和<code>Stack</code>是线程安全的（方法加<code>synchronized</code>），<code>ArrayList</code>和<code>LinkedList</code>线程不安全。</li><li><strong>数据结构</strong>：<ul><li><code>Vector</code>&#x2F;<code>ArrayList</code>&#x2F;<code>Stack</code>基于数组，适合随机访问（通过索引快速定位）。</li><li><code>LinkedList</code>基于链表，适合频繁插入 &#x2F; 删除（尤其是首尾位置）。</li></ul></li><li><strong>效率</strong>：<ul><li>查询频繁选<code>ArrayList</code>（单线程）或<code>Vector</code>（多线程）。</li><li>增删频繁选<code>LinkedList</code>。</li><li>栈操作选<code>Stack</code>（或<code>Deque</code>的<code>push/pop</code>，更推荐）。</li></ul></li></ol><p>这些差异决定了它们的适用场景，实际开发中需根据线程安全需求和操作类型（查询 &#x2F; 增删）选择合适的集合类。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 类 &amp; 接口 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式 &amp; 多例模式</title>
      <link href="/posts/58745.html"/>
      <url>/posts/58745.html</url>
      
        <content type="html"><![CDATA[<p>单例模式和多例模式都是创建型设计模式，用于控制类的实例化过程：</p><p><strong>单例模式（Singleton）</strong></p><ul><li>核心特点：一个类在整个系统中只能创建唯一实例，且提供全局访问点。</li><li>实现方式：私有构造方法 + 静态方法返回唯一实例，通常配合线程安全处理。</li><li>适用场景：全局资源管理（如日志管理器、配置中心）、工具类等，需确保资源唯一或状态一致的场景。</li></ul><p><strong>多例模式（Multiton）</strong></p><ul><li>核心特点：一个类可以创建有限个（预先定义数量）的实例，通过键值等方式管理和获取特定实例。</li><li>实现方式：私有构造方法 + 静态容器（如 Map）存储实例，通过静态方法根据标识返回对应实例。</li><li>适用场景：需要控制实例数量的场景（如线程池、数据库连接池），或特定类型的实例集合（如不同国家的货币实例）。</li></ul><p>两者的核心区别在于：单例模式严格限制为 1 个实例，多例模式限制为固定数量的多个实例，均通过私有构造防止外部随意创建实例。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于String的 intern()方法</title>
      <link href="/posts/58346.html"/>
      <url>/posts/58346.html</url>
      
        <content type="html"><![CDATA[<p>在上述 Java 代码的最后一个示例中，判断<code>k1 == k2</code>结果为<code>true</code> ，这需要结合<code>String</code>类的特性、字符串拼接原理以及<code>intern()</code>方法的作用来进行解释，具体如下：</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">k1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">k1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">k2</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">System.out.println(k1 == k2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>String k1 = new String(&quot;hello&quot;) + new String(&quot;world&quot;);</code></strong> ：<ul><li>首先，<code>new String(&quot;hello&quot;)</code>会在堆内存中创建一个<code>String</code>对象，<code>new String(&quot;world&quot;)</code>同样会在堆内存中创建一个<code>String</code>对象。</li><li>对于字符串拼接操作<code>+</code> ，在 Java 中，其实质是通过<code>StringBuilder</code>类来实现的。具体来说，编译器会将代码隐式地转换为类似以下形式：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">k1</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><ul><li>而<code>toString()</code>方法会返回一个新的<code>String</code>对象，该对象位于堆内存中，内容为<code>&quot;helloworld&quot;</code>。所以此时，<code>k1</code>指向的是堆内存中通过字符串拼接后新创建的<code>String</code>对象。</li></ul><ol start="2"><li><p><strong><code>k1.intern();</code></strong> ：</p><p> <code>intern()</code>方法是<code>String</code>类的一个本地方法。它的作用是：如果字符串常量池中已经包含了与调用<code>intern()</code>方法的字符串对象内容相同的字符串（由<code>equals()</code>方法确定），则返回常量池中该字符串的引用；否则，会将该字符串对象添加到常量池中，并返回常量池中该字符串的引用。</p><ul><li>对于<code>k1</code>，在调用<code>intern()</code>方法之前，常量池中并没有<code>&quot;helloworld&quot;</code>这个字符串，所以调用<code>intern()</code>方法后，会将<code>k1</code>所指向的字符串<code>&quot;helloworld&quot;</code>添加到常量池中，然后返回常量池中<code>&quot;helloworld&quot;</code>的引用。但这里需要注意，<strong>如果没有将返回值重新赋值给<code>k1</code> ，<code>k1</code>依然指向堆中的对象</strong> 。</li></ul></li><li><p><strong><code>String k2 = &quot;helloworld&quot;;</code></strong> ：</p><p> 这是通过直接赋值的方式创建字符串对象，这种方式创建的字符串对象会首先去字符串常量池中查找是否存在<code>&quot;helloworld&quot;</code>。因为之前已经调用了<code>k1.intern();</code> ，使得<code>&quot;helloworld&quot;</code>被添加到了常量池中，所以<code>k2</code>直接指向常量池中已存在的<code>&quot;helloworld&quot;</code>字符串对象。</p></li><li><p><strong><code>System.out.println(k1 == k2);</code></strong> ：</p><p> <code>==</code>运算符比较的是两个引用是否指向同一个对象。在本示例中，由于之前<code>k1.intern()</code>的返回值没有重新赋值给<code>k1</code> ，所以<code>k1</code>还是指向堆中的对象，<code>k2</code>指向常量池中的对象，此时比较结果应该是<code>false</code> 。但在 JDK 6 及之前的版本中，<code>intern()</code>方法是在永久代中维护字符串常量池，而 JDK 7 及之后，字符串常量池被移动到了堆内存中，并且<code>intern()</code>方法的实现也有了变化。</p></li></ol><p>&#x3D;&#x3D;<strong>在 JDK 7 及之后，<code>intern()</code>方法如果发现常量池中不存在对应的字符串，会将堆中该字符串对象的引用复制到常量池中，而不是重新创建一个新的对象。 因此，在这个示例中，<code>k1.intern()</code>执行后，常量池中存储的就是堆中<code>k1</code>所指向对象的引用，所以<code>k1</code>和<code>k2</code>指向的是同一个对象（本质是常量池中的引用指向了堆中<code>k1</code>所指向的对象 ），最终<code>k1 == k2</code>的结果为<code>true</code>。</strong>&#x3D;&#x3D;</p><hr><p>在 Java 中，<code>String</code>类的<code>intern()</code>方法返回值是一个<code>String</code>类型，具体来说：</p><ul><li><p><strong>若字符串常量池中已存在与调用<code>intern()</code>方法的字符串对象内容相同的字符串</strong>：</p><ul><li>依据<code>equals()</code>方法来判断字符串内容是否相等。当相等情况出现时，<code>intern()</code>方法会返回常量池中该字符串的引用。</li></ul><p><strong>若字符串常量池中不存在与调用<code>intern()</code>方法的字符串对象内容相同的字符串</strong>：</p><ul><li>在 JDK 6 及之前版本中，会在永久代的字符串常量池中创建一个新的字符串对象，其内容与调用<code>intern()</code>方法的字符串对象相同，然后返回这个新创建在常量池中的字符串对象的引用。</li><li>而在 JDK 7 及之后版本，字符串常量池被移至堆内存。此时，<code>intern()</code>方法会将堆中该字符串对象的引用复制到常量池中 ，然后返回常量池中这个<strong>引用</strong>，也就是指向堆中原有字符串对象的引用。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA命名规则</title>
      <link href="/posts/64866.html"/>
      <url>/posts/64866.html</url>
      
        <content type="html"><![CDATA[<p>Java 常用命名规则整合：</p><ol><li><p><strong>类 &#x2F; 接口 &#x2F; 枚举类</strong>：</p><p> 帕斯卡命名法（PascalCase），首字母及后续单词首字母均大写。</p><ul><li>类：多为名词，如 <code>UserService</code>、<code>OrderController</code>；异常类以 <code>Exception</code> 结尾，如 <code>LoginException</code>。</li><li>接口：描述功能，如 <code>UserRepository</code>、<code>Validator</code>（可加 <code>I</code> 前缀，如 <code>IUserDao</code>，非强制）。</li><li>枚举类：类名同普通类，如 <code>Season</code>；枚举值全大写 + 下划线，如 <code>SPRING</code>、<code>ORDER_PAID</code>。</li></ul></li><li><p><strong>包名</strong>：</p><p> 全小写，用点分隔，通常以公司域名倒写为前缀，如 <code>com.company.util</code>、<code>org.project.service</code>。</p></li><li><p><strong>文件名</strong>：</p><p> 与类名完全一致（包括大小写），如类 <code>User.java</code> 对应文件 <code>User.java</code>。</p></li><li><p><strong>方法名</strong>：</p><p> 驼峰命名法（camelCase），首字母小写，后续单词首字母大写，多为动词短语，如 <code>getUserInfo()</code>、<code>submitOrder()</code>。</p></li><li><p><strong>变量 &#x2F; 参数</strong>：</p><p> 驼峰命名法（camelCase），首字母小写，清晰表意，如 <code>userAge</code>、<code>inputValue</code>（避免单字母，循环变量可用 <code>i</code>、<code>j</code>）。</p></li><li><p><strong>常量</strong>：</p><p> 全大写 + 下划线分隔（UPPER_SNAKE_CASE），如 <code>MAX_RETRY_COUNT</code>、<code>DEFAULT_ENCODING</code>（需用 <code>static final</code> 修饰）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP-专业术语</title>
      <link href="/posts/24618.html"/>
      <url>/posts/24618.html</url>
      
        <content type="html"><![CDATA[<p>![[Pasted image 20251003171638.png]]Spring动态切入关注点</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP-日志</title>
      <link href="/posts/25274.html"/>
      <url>/posts/25274.html</url>
      
        <content type="html"><![CDATA[<ul><li>静态代理：编码期间就决定好了代理的关系<br>  定义：代理对象，是目标对象的接口的子类型，代理对象本身并不是目标对象，而是将目标对象作为自己的属性。<br>  优点：同一种类型的所有对象都能代理<br>  缺点：范围太小了，只能负责部分接口代理</li><li>动态代理：运行期间才决定好了代理关系（拦截器：拦截所有）<br>  定义：目标对象在执行期间会被动态拦截，插入指定逻辑<br>  优点：可以代理世间万物<br>  缺点：难写</li></ul><h2 id="代理对象proxy需要传递三个参数"><a href="#代理对象proxy需要传递三个参数" class="headerlink" title="代理对象proxy需要传递三个参数"></a>代理对象proxy需要传递三个参数</h2><p>分别是：</p><ul><li>ClassLoader loader 类加载器</li><li>Class&lt;?&gt;[] interfaces 目标对象实现的接口  </li><li>InvocationHandler h 代理逻辑</li></ul><h4 id="1、对于类加载器："><a href="#1、对于类加载器：" class="headerlink" title="1、对于类加载器："></a>1、对于类加载器：</h4><p>userService.getClass().getClassLoader()</p><table><thead><tr><th>写法</th><th>获取的类加载器</th><th>推荐度</th></tr></thead><tbody><tr><td><code>userService.getClass().getClassLoader()</code></td><td><code>UserServiceImpl</code>的类加载器</td><td>一般</td></tr><tr><td><code>UserService.class.getClassLoader()</code></td><td><code>UserService</code>接口的类加载器</td><td>推荐</td></tr><tr><td>更推荐使用 **<code>UserService.class.getClassLoader()</code>**，原因是：</td><td></td><td></td></tr></tbody></table><ul><li>动态代理的核心是 “代理接口”，使用接口的类加载器更符合语义（代理类需要实现该接口）。</li><li>避免因 <code>UserServiceImpl</code> 被特殊类加载器加载而导致的潜在问题。</li></ul><h4 id="2、对于接口："><a href="#2、对于接口：" class="headerlink" title="2、对于接口："></a>2、对于接口：</h4><p>获取接口的来源：（第二种在动态代理中获取是错误的）</p><ol><li><p><strong><code>userService.getClass().getInterfaces()</code></strong></p><ul><li>含义：获取<code>userService</code>实例所属类（即<code>UserServiceImpl</code>）所实现的<strong>所有接口</strong></li><li>特点：<ul><li>如果<code>UserServiceImpl</code>实现了多个接口（如<code>UserService</code>、<code>AnotherService</code>），会返回所有接口</li><li>代理对象会实现所有这些接口，可转换为其中任意一个接口类型</li></ul></li><li>适用场景：需要代理目标类实现的所有接口时使用</li></ul></li><li><p><strong><code>UserService.class.getInterfaces()</code></strong></p><ul><li>含义：获取<code>UserService</code>接口本身所继承的<strong>父接口</strong>（如果有的话）</li><li>特点：<ul><li>如果<code>UserService</code>没有继承其他接口，会返回空数组</li><li>这种方式<strong>错误</strong>，因为代理需要的是目标类实现的接口，而不是接口的父接口</li></ul></li><li>问题：会导致生成的代理对象没有实现<code>UserService</code>接口，从而无法正常使用</li></ul></li><li><p><strong><code>new Class[] &#123;UserService.class&#125;</code></strong></p><ul><li>含义：显式指定只代理<code>UserService</code>这一个接口</li><li>特点：<ul><li>无论<code>UserServiceImpl</code>实现了多少接口，代理对象只实现<code>UserService</code></li><li>最常用、最推荐的方式，明确指定需要代理的接口</li></ul></li><li>适用场景：只需要代理特定接口时使用（绝大多数情况）</li></ul></li></ol><h3 id="总结建议"><a href="#总结建议" class="headerlink" title="总结建议"></a>总结建议</h3><ul><li>第 2 种方式（<code>UserService.class.getInterfaces()</code>）是错误的，会导致代理失效</li><li>第 1 种和第 3 种在<code>UserServiceImpl</code>只实现<code>UserService</code>一个接口时效果相同</li><li><strong>推荐使用第 3 种方式</strong>，因为：<ol><li>明确指定要代理的接口，代码意图更清晰</li><li>避免意外代理不需要的接口</li><li>即使目标类未来实现了更多接口，也不会影响当前代理的范围</li></ol></li></ul><p><img src="D:\Obsidian\note\SSM\tmp8838.png" alt="\tmp8838"></p><h4 id="3-对于代理逻辑"><a href="#3-对于代理逻辑" class="headerlink" title="3.对于代理逻辑"></a>3.对于代理逻辑</h4><p>假设我们有一个简单的接口和实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、类写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独的InvocationHandler实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 目标对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 增强逻辑：方法执行前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【日志】&quot;</span> + method.getName() + <span class="string">&quot;方法开始执行，参数：&quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 增强逻辑：方法执行后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【日志】&quot;</span> + method.getName() + <span class="string">&quot;方法执行结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyWithClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(target); <span class="comment">// 使用实现类</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            UserService.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;UserService.class&#125;,</span><br><span class="line">            handler</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        proxy.addUser(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Lambda 表达式写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyWithLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用Lambda表达式实现InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (proxy, method, args1) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 增强逻辑：方法执行前</span></span><br><span class="line">            System.out.println(<span class="string">&quot;【日志】&quot;</span> + method.getName() + <span class="string">&quot;方法开始执行，参数：&quot;</span> + args1[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用目标方法</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args1);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 增强逻辑：方法执行后</span></span><br><span class="line">            System.out.println(<span class="string">&quot;【日志】&quot;</span> + method.getName() + <span class="string">&quot;方法执行结束&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            UserService.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;UserService.class&#125;,</span><br><span class="line">            handler</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用代理方法</span></span><br><span class="line">        proxy.addUser(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种写法的对比：</p><table><thead><tr><th align="center">维度</th><th align="center">Lambda 表达式写法</th><th align="center">类写法</th></tr></thead><tbody><tr><td align="center"><strong>代码简洁性</strong></td><td align="center">更简洁，无需定义单独类，逻辑直接写在使用处</td><td align="center">代码量稍多，需要单独定义类和方法</td></tr><tr><td align="center"><strong>可读性</strong></td><td align="center">简单逻辑（如单行日志）可读性高；复杂逻辑（多分支、大量代码）会显得臃肿</td><td align="center">结构清晰，复杂逻辑可通过方法拆分提高可读性</td></tr><tr><td align="center"><strong>复用性</strong></td><td align="center"><strong>无法复用</strong>，逻辑与当前场景绑定</td><td align="center"><strong>可复用</strong>，同一个<code>LogHandler</code>可用于多个代理场景</td></tr><tr><td align="center"><strong>状态管理</strong></td><td align="center">难以维护状态（如需保存额外变量，需依赖外部 final 变量）</td><td align="center">可通过类的成员变量轻松维护状态（如目标对象、配置参数）</td></tr><tr><td align="center"><strong>调试难度</strong></td><td align="center">匿名实现，调试时栈轨迹中无具体类名，定位问题稍复杂</td><td align="center">有明确类名和方法名，调试栈轨迹清晰</td></tr><tr><td align="center"><strong>适用场景</strong></td><td align="center">简单代理逻辑（如日志、计时），且无需复用</td><td align="center">复杂代理逻辑（如事务管理、权限校验），或需要多处复用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>容器-生命周期</title>
      <link href="/posts/61559.html"/>
      <url>/posts/61559.html</url>
      
        <content type="html"><![CDATA[<p>![[Pasted image 20251001163039.png]]</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>容器-注入</title>
      <link href="/posts/16580.html"/>
      <url>/posts/16580.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>在 Spring 中，用<code>@Bean</code>将组件添加到容器后，为什么在<code>@Controller</code>等组件中还需要用<code>@Autowired</code>自动注入一遍？</p><h3 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h3><p><code>@Bean</code>和<code>@Autowired</code>是 Spring IoC（控制反转）机制中两个核心且互补的步骤，作用不同，缺一不可：</p><ol><li><p><strong><code>@Bean</code>：负责 “注册组件到容器”</strong></p><ul><li>作用：告诉 Spring 创建指定对象，并将其放入容器中管理（相当于 “把工具放进仓库”）。</li><li>例：用<code>@Bean</code>定义<code>DataSource</code>（数据库连接池），Spring 会创建该实例并保存到容器，但此时它仅存在于容器中，未被其他组件使用。</li></ul></li><li><p><strong><code>@Autowired</code>：负责 “从容器中获取并注入组件”</strong></p><ul><li>作用：当某个组件（如<code>@Controller</code>、<code>@Service</code>）需要依赖容器中的其他组件时，告诉 Spring“从容器中找一个该类型的组件，注入给我使用”（相当于 “从仓库取工具”）。</li><li>例：<code>UserController</code>需要<code>DataSource</code>操作数据库，用<code>@Autowired</code>标注<code>DataSource</code>字段，Spring 会自动从容器中找到已注册的<code>DataSource</code>实例并注入。</li></ul></li></ol><p><strong>总结</strong>：</p><ul><li><code>@Bean</code>是 “存”：将组件注册到容器，作为依赖的 “提供者”；</li><li><code>@Autowired</code>是 “取”：从容器获取依赖并注入，作为依赖的 “使用者”。<br>  两者结合实现组件解耦：组件无需自己创建依赖，由 Spring 统一管理和注入，这是 Spring IoC 的核心思想。</li></ul><hr><h3 id="1-Autowired"><a href="#1-Autowired" class="headerlink" title="1.@Autowired"></a>1.@Autowired</h3><pre><code>自动装配，原理：Spring调用  容器.getBean</code></pre><h3 id="2-Qualifier"><a href="#2-Qualifier" class="headerlink" title="2.@Qualifier"></a>2.@Qualifier</h3><pre><code>@Qualifier(&quot;zhangsan&quot;) //指定名字 精确指定，如果容器中有多个名字，可以指定组件名可以指定名字自动装配</code></pre><h3 id="3-4"><a href="#3-4" class="headerlink" title="3 &amp; 4"></a>3 &amp; 4</h3><h4 id="3-Primary"><a href="#3-Primary" class="headerlink" title="3.@Primary"></a>3.@Primary</h4><pre><code>@Primary //如果一个接口有多个实现类，使用@Primary注解，可以指定默认的实现类 (主组件)</code></pre><h4 id="4-Resource"><a href="#4-Resource" class="headerlink" title="4.@Resource"></a>4.@Resource</h4><pre><code>@Resource 也是自动注入</code></pre><h3 id="问题：-Autowired-和-Resource-的区别？"><a href="#问题：-Autowired-和-Resource-的区别？" class="headerlink" title="问题：@Autowired 和 @Resource 的区别？"></a>问题：@Autowired 和 @Resource 的区别？</h3><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><p>均用于 Spring 的依赖注入，可将容器中的 Bean 注入到目标组件中。</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li><p><strong>来源不同</strong></p><ul><li>@Autowired：Spring 框架自带（org.springframework 包）</li><li>@Resource：JDK 自带（javax.annotation 包，属于 Java EE 规范）</li></ul></li><li><p><strong>默认注入方式</strong></p><ul><li>@Autowired：默认按<strong>类型（byType）</strong> 匹配 Bean</li><li>@Resource：默认按<strong>名称（byName）</strong> 匹配 Bean</li></ul></li><li><p><strong>多 Bean 场景处理</strong></p><ul><li>@Autowired：需配合 @Qualifier 注解指定 Bean 名称</li><li>@Resource：可直接通过 name 属性指定 Bean 名称</li></ul></li><li><p><strong>支持的注入位置</strong></p><ul><li>@Autowired：支持字段、构造方法、setter 方法</li><li>@Resource：支持字段、setter 方法，不支持构造方法</li></ul></li><li><p><strong>属性差异</strong></p><ul><li>@Autowired：仅支持 required 属性（控制是否必须注入，默认 true）</li><li>@Resource：支持 name（指定 Bean 名）、type（指定 Bean 类型）等属性</li></ul></li></ol><hr><p>@AutoWired &#x2F;&#x2F;自动注入组件的，基本类型不可以注入</p><p>@Value ：</p><ol><li>@Value(“字面值”)：直接赋值</li><li>@Value(“${key}”) ：动态从配置文件中取出某一项的值</li><li>@Value(“#{SpEL}”)：Spring Expression Language：Spring 表达式语言</li><li>更多写法在Spring.io 官网查看<br>@Value（“${key : 默认值}”）&#x2F;&#x2F;取不到的时候是默认值</li></ol><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource()"></a>PropertySource()</h3><pre><code>说明属性来源，把指定的文件导入容器中，供我们使用1.classpath:cat.properties  : 从自己的项目类路径下找2.classpath*:Log4j-charsets.properties : 从所有包的类路径下找</code></pre><h3 id="ResourceUtils-getFile-路径"><a href="#ResourceUtils-getFile-路径" class="headerlink" title="ResourceUtils.getFile(路径)"></a>ResourceUtils.getFile(路径)</h3><p>工具类，获取文件</p><p><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5CtmpF440.png" alt="tmpF440.png"></p><hr><h1 id="注入组件的方法"><a href="#注入组件的方法" class="headerlink" title="注入组件的方法"></a>注入组件的方法</h1><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>实验</td><td>内容</td><td>目标</td></tr><tr><td>实验1</td><td>@Autowired</td><td>理解自动装配</td></tr><tr><td>实验2</td><td>@Qualifier</td><td>理解类型&#x2F;具名注入</td></tr><tr><td>实验3</td><td>@Primary</td><td>理解多组件注入方式</td></tr><tr><td>实验4</td><td>@Resource</td><td>扩展其他非Spring注解支持</td></tr><tr><td>实验5</td><td>setter方法注入</td><td>理解setter方法注入</td></tr><tr><td>实验6</td><td>构造器注入</td><td>理解构造器注入</td></tr><tr><td>实验7</td><td>xxxAware</td><td>理解感知接口</td></tr><tr><td>实验8</td><td>@Value</td><td>理解配置文件取值</td></tr><tr><td>实验9</td><td>SpEL</td><td>理解Spring表达式基本使用</td></tr><tr><td>实验10</td><td>@PropertySource</td><td>理解 properties文件注入</td></tr><tr><td>实验11</td><td>@Profile</td><td>理解多环境</td></tr></tbody></table><p>原生方式启动ioc容器，需要配置xml文件，具体看视频，了解即可<br><a href="https://www.bilibili.com/video/BV14WtLeDEit?spm_id_from=333.788.videopod.episodes&vd_source=5e4f6f78c6de6ba4386afe617a1f26be&p=33">https://www.bilibili.com/video/BV14WtLeDEit?spm_id_from=333.788.videopod.episodes&amp;vd_source=5e4f6f78c6de6ba4386afe617a1f26be&amp;p=33</a></p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>免费个人图床搭建【最佳方案】</title>
      <link href="/posts/14664.html"/>
      <url>/posts/14664.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>搭建个人图床的方法有很多，可以通过很多平台赠送的免费额度来存储自己的文件</p><p><strong>首先</strong></p><p>​需要下载这个软件 —— PicGo:<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">下载地址</a></p><blockquote><p><strong>其次</strong></p><p>你还需要准备</p><p>​1.自己的自定义域名（这个可以去阿里云或者腾讯云买一个，并不是很贵）</p><p>​2.一个平台账号（下面会说一种我在用的，还可以去上面的PicGo下载地址里面查看官方文档，也有其他平台的配置方法）</p></blockquote></blockquote><h2 id="1-通过-七牛云-PicGo-搭建个人图床"><a href="#1-通过-七牛云-PicGo-搭建个人图床" class="headerlink" title="1.通过 七牛云 + PicGo 搭建个人图床"></a>1.通过 七牛云 + PicGo 搭建个人图床</h2><p>我最开始先搭建了七牛云的存储服务，等所有配置都弄完才发现一个关键问题：从七牛云复制出来的资源链接，默认是 HTTP 协议的。但现在绝大部分网站都用的是 HTTPS 协议，浏览器会拦截 HTTPS 页面里的 HTTP 资源（也就是“混合内容”），直接导致这些资源用不了。 要解决这个问题，就得给七牛云的资源配 SSL 证书才能用 HTTPS 访问，可七牛云本身不提供免费证书，还得自己额外申请、再手动配置，步骤看着挺麻烦，我就没继续弄了。</p><p>如果实在想在七牛云上存储，貌似也是可以申请免费SSL证书的，可以通过下面关键词自行搜索一下</p><ol><li><p><strong>免费申请 SSL 证书</strong>：通过 <a href="https://letsencrypt.org/">Let’s Encrypt</a>（完全免费，90 天自动续期）或国内的 <a href="https://www.trustasia.com/free-ssl-certificate/">TrustAsia 免费证书</a> 申请域名型 SSL 证书（DV 证书）；</p></li><li><p>在七牛云绑定自定义域名并配置 HTTPS：</p><ul><li><p>先在你的域名服务商（如阿里云、腾讯云）将自定义域名（比如 <code>img.yourdomain.com</code>）解析到七牛云的 CDN 或对象存储域名；</p></li><li><p>登录七牛云控制台，在 “CDN→域名管理” 或 “对象存储→存储空间→域名管理” 中，添加这个自定义域名，然后上传你申请的 SSL 证书，开启 HTTPS；</p></li></ul></li><li><p>之后通过 <code>https://img.yourdomain.com/xxx.jpg</code> 引用七牛云资源，就能完美适配你的 HTTPS 网站，解决混合内容问题。</p></li></ol><h2 id="2-通过-Cloudflare-R2-PicGo-搭建个人图床（推荐）"><a href="#2-通过-Cloudflare-R2-PicGo-搭建个人图床（推荐）" class="headerlink" title="2.通过 Cloudflare R2 + PicGo 搭建个人图床（推荐）"></a>2.通过 Cloudflare R2 + PicGo 搭建个人图床（推荐）</h2><p>Cloudflare R2每月给用户提供免费额度，对于普通用户来说完全够用。<strong>（如果超出免费额度是要收费的，但是费用也是很可观的）</strong></p><ul><li>免费额度：<ul><li><strong>存储</strong>：每月提供 10GB - 月的免费存储额度。存储使用量以 GB - 月为计费指标，通过平均一个计费周期（30 天）内每天的峰值存储量来计算。</li><li><strong>操作请求</strong>：A 类操作每月免费 100 万次，B 类操作每月免费 1000 万次。A 类操作包括 ListBuckets、PutBucket、ListObjects 等改变状态的操作；B 类操作包括 HeadBucket、HeadObject、GetObject 等读取现有状态的操作。</li><li><strong>出口流量</strong>：通过 Workers API 直接访问、通过 S3 兼容 API 访问以及通过 r2.dev 子域名访问时，数据从 R2 存储桶传输到公共互联网产生的出口流量完全免费。</li></ul></li><li>收费制度：<ul><li><strong>存储</strong>：超出免费额度后，标准存储每 GB - 月收费 0.015 美元。</li><li><strong>操作请求</strong>：超出免费额度后，A 类操作每 100 万次收费 4.50 美元，B 类操作每 1000 万次收费 0.36 美元。</li></ul></li></ul><p>此外，如果使用的是 Infrequent Access 存储类，还会有数据检索费用，为每 GB 0.01 美元。</p><p><img src="https://lxztu.xyz/PicGo/Cloudflare01.png" alt="Cloudflare R2提供的免费额度"></p><h3 id="一、配置Cloudflare："><a href="#一、配置Cloudflare：" class="headerlink" title="一、配置Cloudflare："></a>一、配置Cloudflare：</h3><h4 id="1-先在官网注册一个账号-Cloudflare"><a href="#1-先在官网注册一个账号-Cloudflare" class="headerlink" title="1.先在官网注册一个账号 Cloudflare"></a>1.先在官网注册一个账号 <a href="https://dash.cloudflare.com/login">Cloudflare</a></h4><h4 id="2-注册之后需要添加一个付费计划，选择Free计划添加到订阅，添加的时候我们需要一个信用卡或者国区的PayPal账号，我是使用的我的信用卡，没有用PayPal账号。"><a href="#2-注册之后需要添加一个付费计划，选择Free计划添加到订阅，添加的时候我们需要一个信用卡或者国区的PayPal账号，我是使用的我的信用卡，没有用PayPal账号。" class="headerlink" title="2.注册之后需要添加一个付费计划，选择Free计划添加到订阅，添加的时候我们需要一个信用卡或者国区的PayPal账号，我是使用的我的信用卡，没有用PayPal账号。"></a>2.注册之后需要添加一个付费计划，选择Free计划添加到订阅，添加的时候我们需要一个信用卡或者国区的PayPal账号，我是使用的我的信用卡，没有用PayPal账号。</h4><h4 id="3-然后点击左边栏中的-R2对象存储-概述，然后在右边界面我们点击创建存储桶"><a href="#3-然后点击左边栏中的-R2对象存储-概述，然后在右边界面我们点击创建存储桶" class="headerlink" title="3.然后点击左边栏中的 R2对象存储-概述，然后在右边界面我们点击创建存储桶"></a>3.然后点击左边栏中的 R2对象存储-概述，然后在右边界面我们点击创建存储桶</h4><p><img src="https://lxztu.xyz/PicGo/Cloudflare02.png" alt="选择界面"></p><p>在这个界面，存储桶的名称可以自定义，位置建议选择亚太地区，其他都默认。</p><h4 id="4-创建完成之后，还无法直接用过公共的URL来访问，选择-设置-找到R2-dev子域，设置成允许访问，这时上传图片已经可以通过给定的默认URL来访问了"><a href="#4-创建完成之后，还无法直接用过公共的URL来访问，选择-设置-找到R2-dev子域，设置成允许访问，这时上传图片已经可以通过给定的默认URL来访问了" class="headerlink" title="4.创建完成之后，还无法直接用过公共的URL来访问，选择 设置-找到R2.dev子域，设置成允许访问，这时上传图片已经可以通过给定的默认URL来访问了"></a>4.创建完成之后，还无法直接用过公共的URL来访问，选择 设置-找到R2.dev子域，设置成允许访问，这时上传图片已经可以通过给定的默认URL来访问了</h4><p>但是，此时的URL需要挂梯子才能访问，国内访问太慢或者直接无法访问，我们需要通过设置自定义域名解决</p><h4 id="5-我们可以去阿里云或者腾讯云购买自己的域名，也不是很贵"><a href="#5-我们可以去阿里云或者腾讯云购买自己的域名，也不是很贵" class="headerlink" title="5.我们可以去阿里云或者腾讯云购买自己的域名，也不是很贵"></a>5.我们可以去<a href="https://wanwang.aliyun.com/domain/?spm=5176.30275541.J_ZGek9Blx07Hclc3Ddt9dg.1.6d242f3dtEuMxr&scm=20140722.S_card@@%E4%BA%A7%E5%93%81@@3417315.S_new~UND~card.ID_card@@%E4%BA%A7%E5%93%81@@3417315-RL_%E5%9F%9F%E5%90%8D-LOC_2024SPSearchCard-OR_ser-PAR1_2150423517590644092997433e2e3c-V_4-RE_new8-P0_0-P1_0">阿里云</a>或者<a href="https://cloud.tencent.com/product/domain">腾讯云</a>购买自己的域名，也不是很贵</h4><p>（由于我已经配置好了，没有截图了）</p><ol><li>之后在左侧导航栏，点击<strong>账号主页</strong>，在右侧页面点击<strong>加入域</strong>，之后，填入你自己的域名，选择Free计划</li><li>在跳转界面点击<strong>继续前往激活</strong>，弹窗<strong>确认</strong>-设置DNS记录，在跳转的界面中，会有两个更新<strong>名称服务器</strong>的DNS，</li><li>这时候需要我们打开之前购买平台的<strong>域名控制台</strong>，找到<strong>域名列表</strong>，对需要操作的域名点击<strong>管理</strong></li><li>这样会跳到基本信息栏，我们在左侧栏中选择<strong>DNS修改</strong>，进入页面之后，点击修改DNS服务器，将刚才复制的两个网址修改到上面</li><li>回到Cloudflare，之后等待一段时间后，域名的状态就会从 <em><strong>待处理的名称服务器更新</strong></em> 变成 <em><strong>活动</strong></em></li><li>接下来把自定义域名配置到存储桶，点击左侧的<strong>R2对象存储-概述</strong>,之后点到我们创建的<strong>存储桶</strong>，点到<strong>设置</strong>，找到<strong>自定义域</strong>，填入我们的自定义域名，点击<strong>连接域</strong>，之后等待自定义域名生效，即可通过自定义域名浏览文件。</li><li>这样图床就<strong>搭建成功</strong>了</li></ol><h3 id="二、连接PicGo"><a href="#二、连接PicGo" class="headerlink" title="二、连接PicGo"></a>二、连接PicGo</h3><h4 id="1-下载完成后，我们要在PicGo上下载插件"><a href="#1-下载完成后，我们要在PicGo上下载插件" class="headerlink" title="1.下载完成后，我们要在PicGo上下载插件"></a>1.下载完成后，我们要在PicGo上下载插件</h4><ol><li>找到插件设置，搜索 <strong>s3</strong>，找到 <strong>s3-lls 1.0.2</strong> 下载安装。</li></ol><h4 id="2-之后进行图床设置"><a href="#2-之后进行图床设置" class="headerlink" title="2.之后进行图床设置"></a>2.之后进行图床设置</h4><ol><li>找到图床<strong>Amazon S3</strong>进行设置</li><li>点击编辑默认的设置，自定义图床配置名，<strong>应用密钥ID</strong>以及<strong>应用密钥</strong>，需要从Cloudflare网站来获取</li><li>点击左侧导航栏中<strong>R2对象存储-概述</strong>，点击<strong>管理API令牌</strong>，之后<strong>创建API令牌</strong>，令牌名称自定义没有影响，权限选择<strong>对象读和写</strong>，然后<strong>创建API令牌</strong>，然后就会生成 <strong>访问密钥ID</strong> 和 <strong>机密访问密钥</strong>，这两个可以存到记事本中保存一下，好像是只能看一次。</li><li><strong>访问密钥ID</strong> 和 <strong>机密访问密钥</strong> 分别对应 PicGo中 <strong>应用密钥ID</strong> 和 <strong>应用密钥</strong> ，复制过去即可</li><li><strong>桶</strong> 填入我们创建<strong>存储桶</strong>的名字</li><li><strong>文件路径</strong>设置为<code>PicGo/&#123;fullName&#125;</code> ,这样以后访问的路径就是 <code>域名/PicGo/你的文件名</code>，也可以自定义。</li><li><strong>地区</strong> 填入auto</li><li><strong>自定义节点</strong> 设置为 <code>https://&lt;账户ID&gt;.r2.cloudflarestorage.com</code>，其中 <em><strong>账户ID</strong></em>换成你自己 <strong>存储桶的账户ID</strong>，在<strong>R2对象存储-概述</strong>界面，可以看到 <strong>Use R2 with APIs</strong> ，下面的 <strong>Account ID</strong> 就是你的账户ID，替换之后填入即可。</li><li><strong>自定义域名</strong> 填入你的自定义域名，记得要加上前面的http部分，如<code>https://lxztu.xyz</code></li><li>下面的两个设置都是yes，之后点击<strong>确定</strong>，把配置好的设置为默认图床，这样就配置好可以使用了。</li></ol><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><p>我们可以在上传区拖拽批量上传照片，然后在相册区域可以批量复制图片的URL进行使用，非常方便。</p><h3 id="三、如果依旧不明白如何配置"><a href="#三、如果依旧不明白如何配置" class="headerlink" title="三、如果依旧不明白如何配置"></a>三、如果依旧不明白如何配置</h3><p>本文参考视频：</p><p><a href="https://www.bilibili.com/video/BV1eZCrY4E17/?share_source=copy_web&vd_source=e8c688f5a8b51b9365d17f48d7d64d6d">【个人图床最佳方案：Cloudflare R2 + PicGo！免费、稳定、国内+国外网络双向互通！】</a></p><p>结合本文 和 视频，可能让你更快的配置好</p>]]></content>
      
      
      <categories>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客文章加密插件</title>
      <link href="/posts/10029.html"/>
      <url>/posts/10029.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你有给文章加密的需求，可以通过一个插件来实现这个功能 —— <strong>hexo-blog-encrypt</strong></p><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>1.打开Hexo博客根目录，在根目录下执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure><p>其实只下载这个插件就可以直接使用了，接下来就是使用的方法了</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>1.可以通过tags针对一类文章进行加密</p><p>在配置文件<code>[BlogRoot]\_config.yml</code>中添加下面的代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">theme:</span> <span class="string">xray</span></span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br></pre></td></tr></table></figure><p>之后 tags中列出的标签 就会按照设置的密码进行加密</p><p>2.通过Front matter配置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> 加密</span><br><span class="line">date: 2025-09-27 16:03:20</span><br><span class="line">password: hello world</span><br><span class="line">abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">message: 您好, 这里需要密码.</span><br><span class="line">theme: xray</span><br><span class="line">wrong<span class="emphasis">_pass_</span>message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line"><span class="section">wrong<span class="emphasis">_hash_</span>message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>在需要加密的文章中加入上面的Front matter，就可以加密成功了</p><p>3.主题配置</p><p>theme可以设置自己喜欢的加密样式，可以在线挑选自己喜欢的<strong>主题</strong>，有以下这些样式，可以点击查看</p><ul><li><p><a href="https://mhexo.github.io/2020/12/23/Theme-Test-Default/">default</a></p></li><li><p><a href="https://mhexo.github.io/2020/12/23/Theme-Test-Blink/">blink</a></p></li><li><p><a href="https://mhexo.github.io/2020/12/23/Theme-Test-Shrink/">shrink</a></p></li><li><p><a href="https://mhexo.github.io/2020/12/23/Theme-Test-Flip/">flip</a></p></li><li><p><a href="https://mhexo.github.io/2020/12/23/Theme-Test-Up/">up</a></p></li><li><p><a href="https://mhexo.github.io/2020/12/23/Theme-Test-Surge/">surge</a></p></li><li><p><a href="https://mhexo.github.io/2020/12/23/Theme-Test-Wave/">wave</a></p></li><li><p><a href="https://mhexo.github.io/2020/12/23/Theme-Test-Xray/">xray</a></p></li></ul><blockquote><p>！PS:貌似这个加密对相册是无效的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown速查表</title>
      <link href="/posts/3713.html"/>
      <url>/posts/3713.html</url>
      
        <content type="html"><![CDATA[<h1 id="全面常用-Markdown-速查表"><a href="#全面常用-Markdown-速查表" class="headerlink" title="全面常用 Markdown 速查表"></a>全面常用 Markdown 速查表</h1><p>本速查表涵盖日常写作、笔记、文档编辑中高频使用的语法，包含基础格式、进阶排版、特殊元素等类别，每个语法均附「语法示例」和「效果展示」，方便直接复制使用。</p><blockquote><p><strong>由于我刚开始使用Markdown <del><em>并且又有些健忘</em></del>，特此用AI整理了以下总结  方便后续使用查找</strong></p></blockquote><h2 id="一、标题（6-级）"><a href="#一、标题（6-级）" class="headerlink" title="一、标题（6 级）"></a>一、标题（6 级）</h2><p>通过 <code>#</code> 数量区分级别，<code>#</code> 后加空格（规范写法），支持 1-6 级标题，级别越高字体越小。</p><table><thead><tr><th>语法示例</th><th>效果展示</th><th>说明</th></tr></thead><tbody><tr><td><code># 一级标题</code></td><td># 一级标题</td><td>常用作文档大标题，字体最大</td></tr><tr><td><code>## 二级标题</code></td><td>## 二级标题</td><td>常用作章节标题</td></tr><tr><td><code>### 三级标题</code></td><td>### 三级标题</td><td>常用作小节标题</td></tr><tr><td><code>#### 四级标题</code></td><td>#### 四级标题</td><td>层级更细的子标题</td></tr><tr><td><code>##### 五级标题</code></td><td>##### 五级标题</td><td>字体较小，适合细节分类</td></tr><tr><td><code>###### 六级标题</code></td><td>###### 六级标题</td><td>最小级别标题，慎用</td></tr></tbody></table><h2 id="二、文本样式（加粗-斜体-删除线等）"><a href="#二、文本样式（加粗-斜体-删除线等）" class="headerlink" title="二、文本样式（加粗 &#x2F; 斜体 &#x2F; 删除线等）"></a>二、文本样式（加粗 &#x2F; 斜体 &#x2F; 删除线等）</h2><p>用于突出或修饰文本，支持多种组合样式，满足不同强调需求。</p><table><thead><tr><th>语法示例</th><th>效果展示</th><th>说明</th></tr></thead><tbody><tr><td><code>**加粗文本**</code></td><td><strong>加粗文本</strong></td><td>最常用强调方式，突出核心信息</td></tr><tr><td><code>*斜体文本*</code></td><td><em>斜体文本</em></td><td>用于轻微强调或区分（如书名、术语）</td></tr><tr><td><code>***加粗斜体***</code></td><td><em><strong>加粗斜体</strong></em></td><td>双重强调，慎用避免视觉杂乱</td></tr><tr><td><code>~~删除线文本~~</code></td><td><del>删除线文本</del></td><td>表示废弃、修改前的内容</td></tr><tr><td><code>==高亮文本==</code></td><td>&#x3D;&#x3D; 高亮文本 &#x3D;&#x3D;</td><td>突出重点内容（部分平台支持，如 Typora）</td></tr><tr><td><code>H~2~O</code></td><td>H<del>2</del>O</td><td>下标，用于化学式、脚注标记</td></tr><tr><td><code>X^2^</code></td><td>X^2^</td><td>上标，用于公式、指数（如平方、幂次）</td></tr></tbody></table><h2 id="三、列表（有序-无序-嵌套-任务列表）"><a href="#三、列表（有序-无序-嵌套-任务列表）" class="headerlink" title="三、列表（有序 &#x2F; 无序 &#x2F; 嵌套 &#x2F; 任务列表）"></a>三、列表（有序 &#x2F; 无序 &#x2F; 嵌套 &#x2F; 任务列表）</h2><p>用于梳理内容结构，支持有序排列、无序分类、层级嵌套，以及可勾选的任务列表。</p><h3 id="1-无序列表（常用）"><a href="#1-无序列表（常用）" class="headerlink" title="1. 无序列表（常用）"></a>1. 无序列表（常用）</h3><p>用 <code>-</code>、<code>*</code>、<code>+</code> 开头（效果一致，推荐统一用 <code>-</code> 保持规范），后面加空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 列表项1（用 - 开头）</span><br><span class="line"><span class="bullet">-</span> 列表项2</span><br><span class="line"><span class="bullet">  -</span> 嵌套子项1（前面加 2 个空格）</span><br><span class="line"><span class="bullet">  -</span> 嵌套子项2</span><br><span class="line"><span class="bullet">    -</span> 二级嵌套（再加 2 个空格，最多支持多层）</span><br><span class="line"><span class="bullet">*</span> 列表项3（用 * 开头，效果同上）</span><br><span class="line"><span class="bullet">+</span> 列表项4（用 + 开头，效果同上）</span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><ul><li><p>列表项 1（用 - 开头）</p></li><li><p>列表项 2</p><ul><li>嵌套子项 1（前面加 2 个空格）</li><li>嵌套子项 2<ul><li>二级嵌套（再加 2 个空格，最多支持多层）</li></ul></li></ul></li><li><p>列表项 3（用 * 开头，效果同上）</p></li><li><p>列表项 4（用 + 开头，效果同上）</p></li></ul><h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2. 有序列表"></a>2. 有序列表</h3><p>用「数字 + .」开头，后面加空格，序号会自动递增（即使手动写错，渲染后也会修正）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一步：准备材料</span><br><span class="line"><span class="bullet">2.</span> 第二步：操作步骤</span><br><span class="line"><span class="bullet">   1.</span> 子步骤1（前面加 2 个空格）</span><br><span class="line"><span class="bullet">   2.</span> 子步骤2</span><br><span class="line"><span class="bullet">3.</span> 第三步：完成检查</span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><ol><li>第一步：准备材料</li><li>第二步：操作步骤<ol><li>子步骤 1（前面加 2 个空格）</li><li>子步骤 2</li></ol></li><li>第三步：完成检查</li></ol><h3 id="3-任务列表（待办-已办）"><a href="#3-任务列表（待办-已办）" class="headerlink" title="3. 任务列表（待办 &#x2F; 已办）"></a>3. 任务列表（待办 &#x2F; 已办）</h3><p>用 <code>- [ ]</code> 表示待办，<code>- [x]</code> 表示已办（<code>[ ]</code> 内的空格和 <code>x</code> 需英文格式）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 已完成任务1（如：学习标题语法）</span><br><span class="line"><span class="bullet">-</span> [x] 已完成任务2（如：练习列表嵌套）</span><br><span class="line"><span class="bullet">-</span> [ ] 待办任务1（如：掌握表格对齐）</span><br><span class="line"><span class="bullet">-</span> [ ] 待办任务2（如：尝试代码块）</span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：  </p><ul><li><input checked="" disabled="" type="checkbox"> 已完成任务 1（如：学习标题语法）</li><li><input checked="" disabled="" type="checkbox"> 已完成任务 2（如：练习列表嵌套）</li><li><input disabled="" type="checkbox"> 待办任务 1（如：掌握表格对齐）</li><li><input disabled="" type="checkbox"> 待办任务 2（如：尝试代码块）</li></ul><h2 id="四、链接（普通链接-锚点-邮箱链接）"><a href="#四、链接（普通链接-锚点-邮箱链接）" class="headerlink" title="四、链接（普通链接 &#x2F; 锚点 &#x2F; 邮箱链接）"></a>四、链接（普通链接 &#x2F; 锚点 &#x2F; 邮箱链接）</h2><p>用于插入外部链接、文档内跳转或邮箱地址，支持自定义显示文本。</p><table><thead><tr><th>类型</th><th>语法示例</th><th>效果展示</th><th>说明</th></tr></thead><tbody><tr><td>普通链接</td><td><code>[Markdown 官网](https://daringfireball.net/projects/markdown/)</code></td><td><a href="https://daringfireball.net/projects/markdown/">Markdown 官网</a></td><td>点击文本跳转到指定网址</td></tr><tr><td>带提示链接</td><td><code>[知乎](https://www.zhihu.com &quot;点击跳转到知乎首页&quot;)</code></td><td><a href="https://www.zhihu.com/">知乎</a></td><td>鼠标悬停时显示提示文本（双引号内内容）</td></tr><tr><td>锚点链接（文档内跳转）</td><td>1. 先定义锚点：<code>&lt;a id=&quot;top&quot;&gt;顶部&lt;/a&gt;</code>2. 再写跳转链接：<code>[回到顶部](#top)</code></td><td><a href="https://www.doubao.com/chat/21842978001778434#top">回到顶部</a></td><td>用于长文档内快速跳转（锚点 ID 需唯一）</td></tr><tr><td>邮箱链接</td><td><code>&lt;example@163.com&gt;</code> 或 <code>[联系我](mailto:example@163.com)</code></td><td><a href="mailto:example@163.com">example@163.com</a> 或 <a href="mailto:example@163.com">联系我</a></td><td>点击可直接调用邮箱客户端发送邮件</td></tr></tbody></table><h2 id="五、图片（普通图片-带链接图片-本地图片）"><a href="#五、图片（普通图片-带链接图片-本地图片）" class="headerlink" title="五、图片（普通图片 &#x2F; 带链接图片 &#x2F; 本地图片）"></a>五、图片（普通图片 &#x2F; 带链接图片 &#x2F; 本地图片）</h2><p>用于插入图片，支持网络图片、本地图片，还可给图片加跳转链接。</p><table><thead><tr><th>类型</th><th>语法示例</th><th>说明</th></tr></thead><tbody><tr><td>网络图片</td><td><code>![Markdown 图标](https://picsum.photos/id/0/200/100 &quot;Markdown 图标&quot;)</code></td><td><code>!</code> 开头（区别于链接），<code>[]</code> 内是「替代文本」（图片加载失败时显示），<code>()</code> 内是图片 URL + 可选标题（悬停显示），<code>200/100</code> 可指定宽 &#x2F; 高（部分平台支持）</td></tr><tr><td>本地图片</td><td><code>![我的截图](./images/screenshot.png)</code></td><td>用于插入本地文件，<code>./images/</code> 是图片相对于当前文档的路径（需确保路径正确）</td></tr><tr><td>带链接图片</td><td><code>[![Markdown 图标](https://picsum.photos/id/0/200/100)](https://daringfireball.net/projects/markdown/)</code></td><td>把图片嵌套进链接，点击图片跳转到指定网址（外层 <code>[]()</code> 是链接，内层 <code>![]()</code> 是图片）</td></tr></tbody></table><p><strong>效果展示（网络图片）</strong>：</p><p><img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27400%27%20height=%27256%27/%3e" alt="img"><img src="https://picsum.photos/id/0/200/100" alt="image"></p><h2 id="六、引用（单层-嵌套-混合样式）"><a href="#六、引用（单层-嵌套-混合样式）" class="headerlink" title="六、引用（单层 &#x2F; 嵌套 &#x2F; 混合样式）"></a>六、引用（单层 &#x2F; 嵌套 &#x2F; 混合样式）</h2><p>用于引用他人观点、文献内容或突出强调的文本，支持多层嵌套和混合其他样式。</p><h3 id="1-单层引用"><a href="#1-单层引用" class="headerlink" title="1. 单层引用"></a>1. 单层引用</h3><p>用 <code>&gt;</code> 开头，后面加空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; Markdown 是一种轻量级标记语言，由约翰·格鲁伯（John Gruber）于 2004 年创建。</span></span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><blockquote><p>Markdown 是一种轻量级标记语言，由约翰・格鲁伯（John Gruber）于 2004 年创建。</p></blockquote><h3 id="2-嵌套引用"><a href="#2-嵌套引用" class="headerlink" title="2. 嵌套引用"></a>2. 嵌套引用</h3><p>通过增加 <code>&gt;</code> 数量实现嵌套（每层加一个 <code>&gt;</code>）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 第一层引用：这是主引用内容</span></span><br><span class="line">&gt;&gt; 第二层引用：嵌套在第一层内的子引用</span><br><span class="line">&gt;&gt;&gt; 第三层引用：可继续嵌套，建议不超过 3 层（避免视觉过深）</span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><blockquote><p>第一层引用：这是主引用内容</p><blockquote><p>第二层引用：嵌套在第一层内的子引用</p><blockquote><p>第三层引用：可继续嵌套，建议不超过 3 层（避免视觉过深）</p></blockquote></blockquote></blockquote><h3 id="3-混合样式引用"><a href="#3-混合样式引用" class="headerlink" title="3. 混合样式引用"></a>3. 混合样式引用</h3><p>引用内可嵌套加粗、列表、链接等样式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; <span class="strong">**注意事项**</span>：</span></span><br><span class="line"><span class="quote">&gt; 1. 引用内可放有序列表</span></span><br><span class="line"><span class="quote">&gt; 2. 也可放无序列表：</span></span><br><span class="line"><span class="quote">&gt;    - 子项1</span></span><br><span class="line"><span class="quote">&gt;    - 子项2（带链接：[<span class="string">Markdown 指南</span>](<span class="link">https://www.markdownguide.org/</span>)）</span></span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><blockquote><p><strong>注意事项</strong>：</p><ol><li>引用内可放有序列表</li><li>也可放无序列表：<ul><li>子项 1</li><li>子项 2（带链接：<a href="https://www.markdownguide.org/">Markdown 指南</a>）</li></ul></li></ol></blockquote><h2 id="七、代码（单行代码-多行代码块-语法高亮）"><a href="#七、代码（单行代码-多行代码块-语法高亮）" class="headerlink" title="七、代码（单行代码 &#x2F; 多行代码块 &#x2F; 语法高亮）"></a>七、代码（单行代码 &#x2F; 多行代码块 &#x2F; 语法高亮）</h2><p>用于展示代码片段，避免代码被误渲染，支持单行和多行，且可指定语言实现语法高亮。</p><h3 id="1-单行代码"><a href="#1-单行代码" class="headerlink" title="1. 单行代码"></a>1. 单行代码</h3><p>用 **单个反引号(`)** 包裹代码（反引号在键盘 <code>Esc</code> 键下方）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印语句在 Python 中是 <span class="code">`print(&quot;Hello World&quot;)`</span>，在 JavaScript 中是 <span class="code">`console.log(&quot;Hello World&quot;)`</span>。</span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><p>打印语句在 Python 中是 <code>print(&quot;Hello World&quot;)</code>，在 JavaScript 中是 <code>console.log(&quot;Hello World&quot;)</code>。</p><h3 id="2-多行代码块（常用）"><a href="#2-多行代码块（常用）" class="headerlink" title="2. 多行代码块（常用）"></a>2. 多行代码块（常用）</h3><p>用 **三个反引号(`&#96;&#96;)** 包裹代码，开头的 `&#96;&#96;后可指定代码语言（如 <code>python</code>、<code>javascript</code>），实现语法高亮。</p><p><strong>效果展示</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是 Python 多行代码示例（带语法高亮）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_sum</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算两个数的和&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(a, (<span class="built_in">int</span>, <span class="built_in">float</span>)) <span class="keyword">and</span> <span class="built_in">isinstance</span>(b, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请输入数字类型&quot;</span></span><br><span class="line"></span><br><span class="line">result = calculate_sum(<span class="number">5</span>, <span class="number">3.2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;结果：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-代码块指定语言"><a href="#3-代码块指定语言" class="headerlink" title="3. 代码块指定语言"></a>3. 代码块指定语言</h3><p>常见支持的语言：<code>python</code>、<code>javascript</code>、<code>java</code>、<code>html</code>、<code>css</code>、<code>sql</code>、<code>bash</code> 等，不指定语言则默认纯文本。</p><p><strong>效果展示</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 代码示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段 HTML 文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="八、分割线"><a href="#八、分割线" class="headerlink" title="八、分割线"></a>八、分割线</h2><p>用于分隔文档不同章节或内容块，样式简洁，支持三种写法（效果一致，推荐用 <code>---</code>）。</p><table><thead><tr><th>语法示例</th><th>效果展示</th><th>说明</th></tr></thead><tbody><tr><td><code>---</code></td><td>—</td><td>最常用，需单独占一行，前后建议空一行（避免与标题混淆）</td></tr><tr><td><code>***</code></td><td>***</td><td>效果同上，与 <code>---</code> 无区别</td></tr><tr><td><code>___</code>（三个下划线）</td><td>___</td><td>效果同上，不常用（易与强调混淆）</td></tr></tbody></table><h2 id="九、表格（基础表格-对齐-合并单元格）"><a href="#九、表格（基础表格-对齐-合并单元格）" class="headerlink" title="九、表格（基础表格 &#x2F; 对齐 &#x2F; 合并单元格）"></a>九、表格（基础表格 &#x2F; 对齐 &#x2F; 合并单元格）</h2><p>用于展示结构化数据（如对比、统计），支持自定义对齐方式，部分平台支持合并单元格。</p><h3 id="1-基础表格"><a href="#1-基础表格" class="headerlink" title="1. 基础表格"></a>1. 基础表格</h3><p>核心结构：<code>表头行 + 分隔线行 + 内容行</code>，<code>|</code> 分隔列，分隔线行用 <code>-</code> 填充，<code>:</code> 控制对齐。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 姓名 | 年龄 | 职业 | 城市 |</span><br><span class="line">|------|------|------|------|</span><br><span class="line">| 张三 | 25   | 程序员 | 北京 |</span><br><span class="line">| 李四 | 30   | 产品经理 | 上海 |</span><br><span class="line">| 王五 | 28   | 设计师 | 广州 |</span><br></pre></td></tr></table></figure><p><strong>效果展示（默认左对齐）</strong>：</p><table><thead><tr><th>姓名</th><th>年龄</th><th>职业</th><th>城市</th></tr></thead><tbody><tr><td>张三</td><td>25</td><td>程序员</td><td>北京</td></tr><tr><td>李四</td><td>30</td><td>产品经理</td><td>上海</td></tr><tr><td>王五</td><td>28</td><td>设计师</td><td>广州</td></tr></tbody></table><h3 id="2-自定义对齐（核心）"><a href="#2-自定义对齐（核心）" class="headerlink" title="2. 自定义对齐（核心）"></a>2. 自定义对齐（核心）</h3><p>通过分隔线行的 <code>:</code> 位置控制对齐，<code>:</code> 在哪侧就向哪侧对齐，两侧都有 <code>:</code> 则居中。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐列 | 居中对齐列 | 右对齐列 |</span><br><span class="line">|:---------|:----------:|---------:|  &lt;!-- 分隔线行：: 控制对齐 --&gt;</span><br><span class="line">| 内容1    | 内容2      | 内容3    |</span><br><span class="line">| 长文本示例：左对齐会靠左显示 | 长文本示例：居中对齐会居中 | 长文本示例：右对齐会靠右显示 |</span><br><span class="line">| 100      | 200        | 300      |</span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><table><thead><tr><th>左对齐列</th><th>居中对齐列</th><th>右对齐列</th></tr></thead><tbody><tr><td>内容 1</td><td>内容 2</td><td>内容 3</td></tr><tr><td>长文本示例：左对齐会靠左显示</td><td>长文本示例：居中对齐会居中</td><td>长文本示例：右对齐会靠右显示</td></tr><tr><td>100</td><td>200</td><td>300</td></tr></tbody></table><h3 id="3-合并单元格（进阶）"><a href="#3-合并单元格（进阶）" class="headerlink" title="3. 合并单元格（进阶）"></a>3. 合并单元格（进阶）</h3><p>Markdown 原生不支持合并单元格，需借助 HTML 语法（部分平台支持，如 Typora、语雀）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;td rowspan=&quot;2&quot;&gt;合并2行（纵向）&lt;/td&gt;  &lt;!-- rowspan：合并行数 --&gt;</span></span><br><span class="line"><span class="code">    &lt;td&gt;普通单元格1&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;td&gt;普通单元格2&lt;/td&gt;</span></span><br><span class="line"><span class="code">  &lt;/tr&gt;</span></span><br><span class="line"><span class="code">  &lt;tr&gt;</span></span><br><span class="line"><span class="code">    &lt;td&gt;普通单元格3&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;td&gt;普通单元格4&lt;/td&gt;</span></span><br><span class="line"><span class="code">  &lt;/tr&gt;</span></span><br><span class="line"><span class="code">  &lt;tr&gt;</span></span><br><span class="line"><span class="code">    &lt;td colspan=&quot;3&quot;&gt;合并3列（横向）&lt;/td&gt;  &lt;!-- colspan：合并列数 --&gt;</span></span><br><span class="line"><span class="code">  &lt;/tr&gt;</span></span><br><span class="line"><span class="code">&lt;/table&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><table><tr><td rowspan="2">合并2行（纵向）</td><td>普通单元格1</td><td>普通单元格2</td></tr><tr><td>普通单元格3</td><td>普通单元格4</td></tr><tr><td colspan="3">合并3列（横向）</td></tr></table>    <h2 id="十、其他常用元素（脚注-目录-数学公式）"><a href="#十、其他常用元素（脚注-目录-数学公式）" class="headerlink" title="十、其他常用元素（脚注 &#x2F; 目录 &#x2F; 数学公式）"></a>十、其他常用元素（脚注 &#x2F; 目录 &#x2F; 数学公式）</h2><h3 id="1-脚注（文档注释）-有些平台并不支持"><a href="#1-脚注（文档注释）-有些平台并不支持" class="headerlink" title="1. 脚注（文档注释）(有些平台并不支持)"></a>1. 脚注（文档注释）(有些平台并不支持)</h3><p>用于添加补充说明，不影响正文阅读，点击脚注标记可跳转至注释处。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是一段需要补充说明的正文[^1]，还有另一段[^2]。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">脚注1的具体内容（通常放在文档末尾）</span></span><br><span class="line">[<span class="symbol">^2</span>]: <span class="link">脚注2的具体内容，支持换行和简单样式（如 **加粗**）</span></span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>：</p><p>这是一段需要补充说明的正文<a href="%E8%84%9A%E6%B3%A81%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%EF%BC%88%E9%80%9A%E5%B8%B8%E6%94%BE%E5%9C%A8%E6%96%87%E6%A1%A3%E6%9C%AB%E5%B0%BE%EF%BC%89">^1</a>，还有另一段 [^2]。</p><p>[^2]: 脚注 2 的具体内容，支持换行和简单样式（如 <strong>加粗</strong>）</p><h3 id="2-自动目录（TOC）"><a href="#2-自动目录（TOC）" class="headerlink" title="2. 自动目录（TOC）"></a>2. 自动目录（TOC）</h3><p>部分平台支持通过 <code>[TOC]</code> 自动生成目录，目录会关联所有标题，点击可跳转（如 Typora、语雀）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[TOC]  &lt;!-- 自动生成目录，位置通常在文档开头 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">## 二级标题2</span></span><br></pre></td></tr></table></figure><p><strong>效果展示</strong>（以 Typora 为例）：</p><p>会生成一个包含所有标题的列表，点击标题名可直接跳转到对应位置。</p><h3 id="3-数学公式（LaTeX-语法）"><a href="#3-数学公式（LaTeX-语法）" class="headerlink" title="3. 数学公式（LaTeX 语法）"></a>3. 数学公式（LaTeX 语法）</h3><p>用于插入数学公式，支持行内公式和块级公式（部分平台支持，如 Typora、GitHub）。</p><table><thead><tr><th>类型</th><th>语法示例</th><th>效果展示</th></tr></thead><tbody><tr><td>行内公式</td><td><code>质能方程：$E=mc^2$</code></td><td>质能方程：(E&#x3D;mc^2)</td></tr><tr><td>块级公式</td><td><code>$$\sum_&#123;i=1&#125;^n x_i = x_1 + x_2 + ... + x_n$$</code></td><td>(\sum_{i&#x3D;1}^n x_i &#x3D; x_1 + x_2 + … + x_n)</td></tr></tbody></table><h2 id="语法兼容性说明"><a href="#语法兼容性说明" class="headerlink" title="语法兼容性说明"></a>语法兼容性说明</h2><ul><li>基础语法（标题、加粗、列表、链接等）在所有平台（GitHub、Typora、语雀、Notion 等）均支持；</li><li>进阶语法（高亮、脚注、数学公式、合并单元格）部分平台支持，建议根据使用场景选择（如写技术文档用 Typora，写在线笔记用语雀）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown速查表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化Hexo博客永久链接的方法</title>
      <link href="/posts/49656.html"/>
      <url>/posts/49656.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo默认的永久链接格式层级比较复杂，深度太大不利于 SEO，而且默认链接的格式是根据日期定义，一旦我们修改文章的日期，那么链接就会改变。</p><p>[^SEO]:  全称为 Search Engine Optimization（搜索引擎优化），是通过优化网站结构、内容、链接等要素，提升网站在搜索引擎自然搜索结果中排名的技术。对于博客而言，合理的链接结构（如层级浅、包含关键词）能帮助搜索引擎更高效地抓取和理解页面内容，从而提升文章的曝光度。</p><p><strong>这将会造成</strong> </p><ol><li>最直接的后果：原链接失效，出现 404 错误</li><li>间接影响：搜索引擎收录与博客权重受损</li></ol><p><strong>修改文章日期 &#x3D; 破坏链接永久性</strong>，会直接导致 404 错误和搜索引擎收录问题。</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>优化方法有很多种，这里我只写一种优化方法<em><strong>hexo-abbrlink</strong></em>，也是最方便最推荐的方法。</p><hr><p>利用hexo-abbrlink插件可以将Hexo生成的<strong>永久链接</strong>转化为一个<strong>随机值</strong></p><p><strong>核心优势</strong>：链接不依赖文章日期、标题，修改这些信息后哈希值不变，永久链接始终有效，避免 404 和 SEO 权重丢失。</p><table><thead><tr><th>对比维度</th><th>Hexo 默认永久链接</th><th>hexo-abbrlink 插件生成链接</th></tr></thead><tbody><tr><td><strong>链接生成逻辑</strong></td><td>依赖文章「日期（年 &#x2F; 月 &#x2F; 日）+ 标题」动态变量，格式通常为 <code>:year/:month/:day/:title/</code></td><td>基于 CRC16&#x2F;CRC32 算法生成文章唯一哈希值，格式可自定义（如 <code>posts/:abbrlink/</code>）</td></tr><tr><td><strong>典型链接示例</strong></td><td><code>https://xxx.com/2025/09/26/hexo-link-opt/</code></td><td><code>https://xxx.com/posts/abc123/</code>（hex 格式）或 <code>https://xxx.com/posts/123456/</code>（dec 格式）</td></tr><tr><td><strong>链接永久性</strong></td><td>差：修改文章日期 &#x2F; 标题后，链接直接变更，原链接失效</td><td>优：哈希值与文章绑定，修改日期 &#x2F; 标题不影响链接，永久有效</td></tr><tr><td><strong>SEO 友好性</strong></td><td>较差：层级深（4-5 级），不利于爬虫抓取；标题含特殊字符时易出现链接乱码</td><td>较优：层级浅（1-2 级），爬虫抓取效率高；哈希值简洁无乱码，可搭配关键词路径（如 <code>tech/abc123</code>）</td></tr><tr><td><strong>用户可读性</strong></td><td>一般：可通过日期 + 标题初步判断文章主题，但链接冗长</td><td>一般：哈希值无语义，但可通过自定义路径（如 <code>java/def456</code>）补充主题信息</td></tr><tr><td><strong>修改灵活性</strong></td><td>差：修改日期 &#x2F; 标题必变链接，需手动处理 301 重定向</td><td>优：支持自由修改文章元信息（日期、标题），无需调整链接，无额外操作成本</td></tr><tr><td><strong>兼容性与配置成本</strong></td><td>无配置成本：Hexo 原生支持，无需额外安装插件</td><td>低配置成本：需安装插件 + 简单配置（选算法、定义路径），文档清晰易上手</td></tr><tr><td><strong>适用场景</strong></td><td>文章发布后几乎不修改日期 &#x2F; 标题，追求链接含语义信息的场景</td><td>需频繁调整文章元信息（如补档旧文、修正时间）、注重链接稳定性和 SEO 效率的场景</td></tr></tbody></table><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 npm 安装插件</span></span><br><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>修改Hexo配置文件的 permalink: 字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br></pre></td></tr></table></figure><p>在_config.yml里增加 hexo-abbrlink 插件的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment">#支持crc16和crc32算法（默认crc16）</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment">#支持dec和hex值（默认dec）</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default) </span></span><br><span class="line">  <span class="comment"># Generate categories from directory-tree</span></span><br><span class="line">  <span class="comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">  <span class="attr">auto_category:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#true(default)</span></span><br><span class="line">     <span class="attr">depth:</span>        <span class="comment">#3(default)</span></span><br><span class="line">     <span class="attr">over_write:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">auto_title:</span> <span class="literal">false</span> <span class="comment">#enable auto title, it can auto fill the title by path</span></span><br><span class="line">  <span class="attr">auto_date:</span> <span class="literal">false</span> <span class="comment">#enable auto date, it can auto fill the date by time today</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span> <span class="comment">#enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>生成的链接将如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">crc16</span> <span class="string">&amp;</span> <span class="string">hex</span></span><br><span class="line"><span class="string">https://post.zz173.com/posts/66c8.html</span></span><br><span class="line"></span><br><span class="line"><span class="string">crc16</span> <span class="string">&amp;</span> <span class="string">dec</span></span><br><span class="line"><span class="string">https://post.zz173.com/posts/65535.html</span></span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">crc32</span> <span class="string">&amp;</span> <span class="string">hex</span></span><br><span class="line"><span class="string">https://post.zz173.com/posts/8ddf18fb.html</span></span><br><span class="line"></span><br><span class="line"><span class="string">crc32</span> <span class="string">&amp;</span> <span class="string">dec</span></span><br><span class="line"><span class="string">https://post.zz173.com/posts/1690090958.html</span></span><br></pre></td></tr></table></figure><p>也可以在文章的 front-matter 部分手动填写 abbrlink 字段的值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">优化</span> <span class="string">Hexo</span> <span class="string">的永久链接</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="string">hexo-permalinks</span> <span class="comment">#注意这部分</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2025-09-26 00:00:00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时永久链接格式就是 <a href="https://lxzblog.click/posts/hexo-permalinks.html">https://lxzblog.click/posts/hexo-permalinks.html</a></p><p>本文参考文章：<a href="https://blog.dejavu.moe/posts/hexo-permalinks/">优化 Hexo 网站的永久链接格式</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串的常用方法</title>
      <link href="/posts/23085.html"/>
      <url>/posts/23085.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-String-常用方法总结"><a href="#Java-String-常用方法总结" class="headerlink" title="Java String 常用方法总结"></a>Java String 常用方法总结</h1><p>基于提供的代码，整理出以下常用的 String 类方法及功能：</p><h2 id="1-字符串替换"><a href="#1-字符串替换" class="headerlink" title="1. 字符串替换"></a>1. 字符串替换</h2><ul><li><p><strong><code>replace(CharSequence target, CharSequence replacement)</code></strong></p><ul><li>替换所有匹配的子字符串（非正则匹配）</li><li>示例：<code>str.replace(&quot;东风&quot;, &quot;刘海柱&quot;)</code></li></ul></li><li><p><strong><code>replaceAll(String regex, String replacement)</code></strong></p><ul><li>支持正则表达式替换，替换所有匹配的子串</li><li>示例：<ul><li>替换字母：<code>replaceAll(&quot;[a-zA-Z]&quot;, &quot;@&quot;)</code></li><li>替换手机号：<code>replaceAll(&quot;1\\d&#123;10&#125;&quot;, &quot;----替换内容----&quot;)</code></li><li>去除空格：<code>replaceAll(&quot;\\s&quot;, &quot;&quot;)</code></li></ul></li></ul></li></ul><h2 id="2-字符串分割"><a href="#2-字符串分割" class="headerlink" title="2. 字符串分割"></a>2. 字符串分割</h2><ul><li><strong><code>split(String regex)</code></strong><ul><li><p>按正则表达式分割字符串，返回字符串数组</p></li><li><p>注意：特殊字符（如<code>.</code>, <code>|</code>）需要转义（<code>\\.</code>, <code>\\|</code>）</p></li><li><p>示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;java,c++,c#&quot;</span>.split(<span class="string">&quot;,&quot;</span>) → [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;c#&quot;</span>]</span><br><span class="line"><span class="string">&quot;java|c++|c#&quot;</span>.split(<span class="string">&quot;\\|&quot;</span>) → [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;c#&quot;</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-子串操作"><a href="#3-子串操作" class="headerlink" title="3. 子串操作"></a>3. 子串操作</h2><ul><li><p><strong><code>substring(int beginIndex)</code></strong></p><ul><li>从指定索引开始截取到字符串末尾</li><li>示例：<code>&quot;0123456789&quot;.substring(2) → &quot;23456789&quot;</code></li></ul></li><li><p><strong><code>substring(int beginIndex, int endIndex)</code></strong></p><ul><li>截取从<code>beginIndex</code>（包含）到<code>endIndex</code>（不包含）的子串</li><li>示例：<code>&quot;0123456789&quot;.substring(2,5) → &quot;234&quot;</code></li></ul></li><li><p>结合<code>indexOf</code>定位子串：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSub.substring(strSub.indexOf(<span class="string">&quot;往事&quot;</span>)) <span class="comment">// 从&quot;往事&quot;开始截取</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-字符与字符串转换"><a href="#4-字符与字符串转换" class="headerlink" title="4. 字符与字符串转换"></a>4. 字符与字符串转换</h2><ul><li><strong>字符数组 → 字符串</strong><ul><li><code>new String(char[] value)</code>：<code>new String(dataChar)</code></li><li><code>String.valueOf(char[] data)</code>：<code>String.valueOf(dataChar2)</code></li></ul></li></ul><h2 id="5-类型转换"><a href="#5-类型转换" class="headerlink" title="5. 类型转换"></a>5. 类型转换</h2><ul><li><strong>基本类型 → 字符串</strong><ul><li>拼接空字符串：<code>int x = 99; String y = x + &quot;&quot;</code></li><li><code>String.valueOf(基本类型)</code>：<code>String.valueOf(x)</code></li></ul></li></ul><h2 id="6-空格处理"><a href="#6-空格处理" class="headerlink" title="6. 空格处理"></a>6. 空格处理</h2><ul><li><strong><code>trim()</code></strong><ul><li>去除字符串两端的空格（中间空格保留）</li><li>示例：<code>&quot; 我 两端 有空 &quot;.trim() → &quot;我 两端 有空&quot;</code></li></ul></li></ul><h2 id="7-其他常用方法（扩展）"><a href="#7-其他常用方法（扩展）" class="headerlink" title="7. 其他常用方法（扩展）"></a>7. 其他常用方法（扩展）</h2><ul><li>**<code>indexOf(String str)</code>**：查找子串首次出现的索引</li><li>**<code>lastIndexOf(String str)</code>**：查找子串最后出现的索引</li><li>**<code>length()</code>**：返回字符串长度</li><li>**<code>charAt(int index)</code>**：返回指定索引的字符</li><li>**<code>contains(CharSequence s)</code>**：判断是否包含指定子串</li><li><strong><code>startsWith(String prefix)</code></strong> &#x2F; **<code>endsWith(String suffix)</code>**：判断是否以指定字符串开头 &#x2F; 结尾</li><li><strong><code>equals(Object anObject)</code></strong> &#x2F; **<code>equalsIgnoreCase(String anotherString)</code>**：比较字符串是否相等（后者忽略大小写）</li></ul><p>这些方法覆盖了字符串处理的大部分常见场景，包括替换、分割、截取、转换等操作。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java String 对象创建与内存分配笔记</title>
      <link href="/posts/56117.html"/>
      <url>/posts/56117.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-String-对象创建与内存分配笔记"><a href="#Java-String-对象创建与内存分配笔记" class="headerlink" title="Java String 对象创建与内存分配笔记"></a>Java String 对象创建与内存分配笔记</h1><h2 id="一、核心概念：字符串常量池（Constant-Pool）"><a href="#一、核心概念：字符串常量池（Constant-Pool）" class="headerlink" title="一、核心概念：字符串常量池（Constant Pool）"></a>一、核心概念：字符串常量池（Constant Pool）</h2><ul><li><strong>作用</strong>：存储字符串常量（如<code>&quot;abc&quot;</code>），实现对象共享，避免重复创建相同内容的字符串，节省内存</li><li><strong>加载时机</strong>：类加载时，字符串常量会被自动读取并放入常量池</li><li><strong>核心规则</strong>：常量池中相同内容的字符串<strong>仅存在 1 个</strong>，后续使用相同常量时直接复用，不新建</li></ul><h2 id="二、String-对象创建的两种方式及内存分析"><a href="#二、String-对象创建的两种方式及内存分析" class="headerlink" title="二、String 对象创建的两种方式及内存分析"></a>二、String 对象创建的两种方式及内存分析</h2><h3 id="方式-1：直接赋值（String-s-abc-）"><a href="#方式-1：直接赋值（String-s-abc-）" class="headerlink" title="方式 1：直接赋值（String s = &quot;abc&quot;）"></a>方式 1：直接赋值（<code>String s = &quot;abc&quot;</code>）</h3><ul><li><strong>内存过程</strong>：<ol><li>检查常量池：若不存在<code>&quot;abc&quot;</code>，则在常量池创建 1 个<code>&quot;abc&quot;</code>对象</li><li>若常量池已存在<code>&quot;abc&quot;</code>，则直接让变量<code>s</code>指向常量池中的该对象</li></ol></li><li><strong>对象数量</strong>：仅在首次赋值时创建 1 个（常量池），后续赋值不新建对象</li></ul><h3 id="方式-2：new关键字创建（String-s-new-String-abc-）"><a href="#方式-2：new关键字创建（String-s-new-String-abc-）" class="headerlink" title="方式 2：new关键字创建（String s = new String(&quot;abc&quot;)）"></a>方式 2：<code>new</code>关键字创建（<code>String s = new String(&quot;abc&quot;)</code>）</h3><ul><li><strong>内存过程</strong>（分首次和后续）：<ol><li><strong>首次执行</strong>（常量池无<code>&quot;abc&quot;</code>）：<ul><li>先在常量池创建 1 个<code>&quot;abc&quot;</code>对象（类加载时或首次遇到常量时）</li><li>再在<strong>堆内存</strong>创建 1 个新的<code>String</code>对象（内容与常量池一致）</li><li>变量<code>s</code>最终指向堆中的对象</li><li><strong>对象总数</strong>：2 个（常量池 1 个 + 堆 1 个）</li></ul></li><li><strong>后续执行</strong>（常量池已有<code>&quot;abc&quot;</code>）：<ul><li>不再创建常量池对象，仅在堆内存新建 1 个<code>String</code>对象</li><li>变量<code>s</code>指向堆中的新对象</li><li><strong>对象总数</strong>：1 个（仅堆中新建）</li></ul></li></ol></li></ul><h2 id="三、典型案例分析"><a href="#三、典型案例分析" class="headerlink" title="三、典型案例分析"></a>三、典型案例分析</h2><h3 id="案例-1：两次new创建相同常量"><a href="#案例-1：两次new创建相同常量" class="headerlink" title="案例 1：两次new创建相同常量"></a>案例 1：两次<code>new</code>创建相同常量</h3><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>); <span class="comment">// 2个对象（常量池&quot;xyz&quot; + 堆1个）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>); <span class="comment">// 1个对象（仅堆1个，复用常量池）</span></span><br></pre></td></tr></table></figure><ul><li><strong>总对象数</strong>：3 个（常量池 1 个 + 堆 2 个）</li></ul><h3 id="案例-2：字符串拼接（new-String-hello-new-String-world-）"><a href="#案例-2：字符串拼接（new-String-hello-new-String-world-）" class="headerlink" title="案例 2：字符串拼接（new String(&quot;hello&quot;) + new String(&quot;world&quot;)）"></a>案例 2：字符串拼接（<code>new String(&quot;hello&quot;) + new String(&quot;world&quot;)</code>）</h3><ul><li><strong>内存过程</strong>（共创建 6 个对象）：<ol><li>常量池：创建<code>&quot;hello&quot;</code>和<code>&quot;world&quot;</code>（2 个）</li><li>堆内存：<ul><li><code>new String(&quot;hello&quot;)</code> → 堆 1 个</li><li><code>new String(&quot;world&quot;)</code> → 堆 1 个</li><li>底层隐式创建<code>StringBuilder</code>对象（用于拼接）→ 堆 1 个</li><li><code>StringBuilder.toString()</code> → 生成新的<code>&quot;helloworld&quot;</code>对象（堆 1 个，<strong>常量池无此对象</strong>）</li></ul></li></ol></li><li><strong>关键注意</strong>：拼接结果<code>&quot;helloworld&quot;</code>仅在堆中存在，不会放入常量池</li></ul><h2 id="四、核心总结"><a href="#四、核心总结" class="headerlink" title="四、核心总结"></a>四、核心总结</h2><table><thead><tr><th>创建方式</th><th>常量池对象</th><th>堆对象</th><th>总对象数（首次 &#x2F; 后续）</th></tr></thead><tbody><tr><td>直接赋值 <code>String s = &quot;a&quot;</code></td><td>1 个（复用）</td><td>0 个</td><td>1 个 &#x2F; 0 个</td></tr><tr><td><code>new String(&quot;a&quot;)</code></td><td>1 个（复用）</td><td>1 个（每次新）</td><td>2 个 &#x2F; 1 个</td></tr><tr><td>拼接 <code>new String(&quot;a&quot;)+new String(&quot;b&quot;)</code></td><td>2 个（”a”&#x2F;“b”）</td><td>4 个（2 个 String + 1 个 StringBuilder + 1 个拼接结果）</td><td>6 个</td></tr></tbody></table><ul><li>核心区别：<code>==</code>比较对象地址（常量池 vs 堆不同则为 false），<code>equals()</code>比较内容（相同则为 true）</li><li>常量池仅存储<strong>编译期确定的字符串常量</strong>，运行时拼接结果（如<code>new</code>拼接）不会进入常量池</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于日期的总结</title>
      <link href="/posts/16771.html"/>
      <url>/posts/16771.html</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，<code>Date</code>、<code>LocalDate</code>以及它们对应的格式化类（<code>SimpleDateFormat</code>、<code>DateTimeFormatter</code>）是处理日期时间的重要工具，它们在设计和使用上有显著区别。以下是总结：</p><h3 id="1-Date-类（java-util-Date）"><a href="#1-Date-类（java-util-Date）" class="headerlink" title="1. Date 类（java.util.Date）"></a>1. <code>Date</code> 类（java.util.Date）</h3><ul><li><p><strong>特点</strong>：</p><ul><li>是 Java 早期的日期时间类，包含日期和时间信息（精确到毫秒）。</li><li>线程不安全，不推荐在多线程环境中使用。</li><li>设计存在缺陷，许多方法（如<code>getYear()</code>、<code>getMonth()</code>）已过时。</li><li>时区处理不够直观，默认依赖系统时区。</li></ul></li><li><p><strong>对应的格式化类：<code>SimpleDateFormat</code></strong></p><ul><li><p>用于<code>Date</code>与字符串之间的转换。</p></li><li><p><strong>Pattern 示例</strong>：</p><ul><li><code>yyyy-MM-dd</code>：年 - 月 - 日（如<code>2023-10-05</code>）</li><li><code>yyyy-MM-dd HH:mm:ss</code>：年 - 月 - 日 时：分: 秒（如<code>2023-10-05 14:30:25</code>）</li><li><code>MM/dd/yyyy</code>：月 &#x2F; 日 &#x2F; 年（如<code>10/05/2023</code>）</li></ul></li><li><p><strong>示例代码</strong>：</p><p>  java</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> sdf.format(date); <span class="comment">// 格式化Date为字符串</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">parsedDate</span> <span class="operator">=</span> sdf.parse(dateStr); <span class="comment">// 解析字符串为Date</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-LocalDate-类（java-time-LocalDate）"><a href="#2-LocalDate-类（java-time-LocalDate）" class="headerlink" title="2. LocalDate 类（java.time.LocalDate）"></a>2. <code>LocalDate</code> 类（java.time.LocalDate）</h3><ul><li><p><strong>特点</strong>：</p><ul><li>是 Java 8 引入的<code>java.time</code>（JSR 310）API 中的类，仅包含日期信息（年、月、日），不包含时间和时区。</li><li>不可变对象，线程安全，推荐在新代码中使用。</li><li>提供了丰富的日期计算方法（如<code>plusDays()</code>、<code>minusMonths()</code>）。</li></ul></li><li><p><strong>对应的格式化类：<code>DateTimeFormatter</code></strong></p><ul><li><p>用于<code>LocalDate</code>（及其他<code>java.time</code>类）与字符串之间的转换。</p></li><li><p>预定义了多种常用格式（如<code>ISO_LOCAL_DATE</code>对应<code>yyyy-MM-dd</code>）。</p></li><li><p><strong>Pattern 示例</strong>（与<code>SimpleDateFormat</code>类似，但更严格）：</p><ul><li><code>yyyy-MM-dd</code>：年 - 月 - 日</li><li><code>dd/MM/yyyy</code>：日 &#x2F; 月 &#x2F; 年</li><li><code>MMMM dd, yyyy</code>：月份全称 日，年（如<code>October 05, 2023</code>）</li></ul></li><li><p><strong>示例代码</strong>：</p><p>  java</p><p>  运行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> localDate.format(formatter); <span class="comment">// 格式化LocalDate为字符串</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">parsedDate</span> <span class="operator">=</span> LocalDate.parse(dateStr, formatter); <span class="comment">// 解析字符串为LocalDate</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="核心区别对比"><a href="#核心区别对比" class="headerlink" title="核心区别对比"></a>核心区别对比</h3><table><thead><tr><th>特性</th><th><code>Date</code> + <code>SimpleDateFormat</code></th><th><code>LocalDate</code> + <code>DateTimeFormatter</code></th></tr></thead><tbody><tr><td>引入版本</td><td>Java 1.0</td><td>Java 8+</td></tr><tr><td>包含信息</td><td>日期 + 时间（毫秒级）</td><td>仅日期（年 &#x2F; 月 &#x2F; 日）</td></tr><tr><td>线程安全性</td><td>线程不安全</td><td>线程安全（不可变）</td></tr><tr><td>时区处理</td><td>依赖系统默认时区，不够直观</td><td>需显式指定时区（如<code>ZonedDateTime</code>）</td></tr><tr><td>方法设计</td><td>多方法过时，设计老旧</td><td>方法丰富，支持链式调用</td></tr><tr><td>格式化灵活性</td><td>中等，但易出线程安全问题</td><td>高，预定义格式多，更严格</td></tr></tbody></table><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul><li>新代码中优先使用<code>java.time</code>包下的类（如<code>LocalDate</code>、<code>LocalDateTime</code>）及<code>DateTimeFormatter</code>，它们更安全、易用。</li><li>若需处理时间，<code>LocalDate</code>不适用，可使用<code>LocalDateTime</code>（包含日期 + 时间）或<code>ZonedDateTime</code>（带时区）。</li><li>避免在多线程中使用<code>SimpleDateFormat</code>，若必须使用<code>Date</code>，可通过<code>ThreadLocal</code>保证线程安全。</li></ul><p>分享</p><p>如何在Java中将字符串解析为Date类型？</p><p>除了SimpleDateFormat，Java中还有哪些类可以用于格式化日期时间？</p><p>在Java 8中引入的新日期时间API（java.time包）有哪些优势？</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="/posts/46023.html"/>
      <url>/posts/46023.html</url>
      
        <content type="html"><![CDATA[<h3 id="String-类的核心特性说明"><a href="#String-类的核心特性说明" class="headerlink" title="String 类的核心特性说明"></a>String 类的核心特性说明</h3><h4 id="一、接口与修饰符实现"><a href="#一、接口与修饰符实现" class="headerlink" title="一、接口与修饰符实现"></a>一、接口与修饰符实现</h4><ol><li><p><strong>final 修饰</strong></p><p> String 类被<code>final</code>关键字修饰，意味着它<strong>不能被继承</strong>，所有方法无法被重写，保证了类行为的稳定性。</p></li><li><p><strong>序列化支持</strong></p><p> 实现<code>Serializable</code>接口（空接口），表示 String 对象<strong>可被序列化</strong>，支持网络传输或持久化存储。</p></li><li><p><strong>比较与排序能力</strong></p><p> 实现<code>Comparable&lt;String&gt;</code>接口，可通过<code>compareTo()</code>方法进行字符串比较，支持自然排序。</p></li><li><p><strong>字符串基础操作定义</strong></p><p> 实现<code>CharSequence</code>接口，规定了字符串必须实现的核心方法，包括：</p><ul><li><code>length()</code>：返回长度</li><li><code>toString()</code>：返回字符串本身</li><li><code>charAt(int index)</code>：获取指定位置字符等</li></ul></li><li><p><strong>JDK 12 + 新增接口</strong></p><p> 实现<code>Constable</code>和<code>ConstantDesc</code>接口，支持在常量表达式中使用字符串，增强编译期常量处理能力。</p></li></ol><h4 id="二、内部数据结构"><a href="#二、内部数据结构" class="headerlink" title="二、内部数据结构"></a>二、内部数据结构</h4><ul><li><strong>JDK 8 及之前</strong>：底层使用<code>private final char[] value</code>存储字符（每个字符占 2 字节）。</li><li><strong>JDK 9 及之后</strong>：优化为<code>private final byte[] value</code>（默认 UTF-8 编码，根据字符范围动态占用 1-2 字节），减少内存占用。</li></ul><h4 id="三、不可变性（Immutable）"><a href="#三、不可变性（Immutable）" class="headerlink" title="三、不可变性（Immutable）"></a>三、不可变性（Immutable）</h4><p>String 对象是<strong>常量</strong>，创建后其值无法修改，核心原因：</p><ol><li>类被<code>final</code>修饰，禁止继承重写方法。</li><li>底层存储数组<code>value</code>被<code>private final</code>修饰，无法修改引用指向，且无对外暴露修改数组的方法。</li></ol><h4 id="四、不可变设计的优势"><a href="#四、不可变设计的优势" class="headerlink" title="四、不可变设计的优势"></a>四、不可变设计的优势</h4><ol><li><p><strong>线程安全</strong></p><p> 多线程环境下无需额外同步，可安全共享 String 对象（不会因并发修改导致数据不一致）。</p></li><li><p><strong>安全性保障</strong></p><p> 避免因一处修改导致所有引用该对象的地方受影响（例如网络请求参数、文件路径等关键字符串）。</p></li><li><p><strong>字符串常量池复用</strong></p><p> 不可变性使常量池中的字符串可被多个引用共享，减少内存消耗。</p></li></ol><h4 id="五、字符串的两种创建方式"><a href="#五、字符串的两种创建方式" class="headerlink" title="五、字符串的两种创建方式"></a>五、字符串的两种创建方式</h4><table><thead><tr><th>创建方式</th><th>底层逻辑</th></tr></thead><tbody><tr><td><code>String s = &quot;中国&quot;;</code></td><td>1. 先检查<strong>字符串常量池</strong>中是否存在 “中国”；<br><br>2. 存在则直接返回常量池中的对象引用；<br><br>3. 不存在则在常量池创建 “中国”，再返回引用。</td></tr><tr><td><code>String s = new String(&quot;中国&quot;);</code></td><td>1. 先执行上述 “字面量创建” 步骤（确保常量池中有 “中国”）；<br><br>2. 在<strong>堆内存</strong>中创建新的 String 对象，引用常量池中的 “中国”；<br><br>3. 变量<code>s</code>指向堆中的新对象。</td></tr></tbody></table><h4 id="六、与-StringBuffer-的对比"><a href="#六、与-StringBuffer-的对比" class="headerlink" title="六、与 StringBuffer 的对比"></a>六、与 StringBuffer 的对比</h4><ul><li><strong>String</strong>：不可变，适合少量操作或共享场景。</li><li><strong>StringBuffer</strong>：可变（底层数组无<code>final</code>修饰），适合频繁修改字符串的场景（如拼接、插入），且线程安全（方法被<code>synchronized</code>修饰）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日期处理</title>
      <link href="/posts/53229.html"/>
      <url>/posts/53229.html</url>
      
        <content type="html"><![CDATA[<p>常用的几个类</p><p>Date &#x2F;&#x2F;util包的</p><p>SimpleDateFormat  &#x2F;&#x2F;text包下的</p><p>calendar &#x2F;&#x2F; util包下的</p><h1 id="2、Date"><a href="#2、Date" class="headerlink" title="2、Date"></a>2、<strong>Date</strong></h1><p>日期格式化可用的字符说明</p><p>yyyy 年</p><p>MM 月</p><p>dd  日</p><p>hh  1~12小时制 (1-12)</p><p>HH  24小时制</p><p>mm  分</p><p>ss   秒</p><p>S   毫秒</p><p>E   星期几</p><p>D   一年中的第几天</p><p>F 一个月中的第几个星期(会把这个月总共过的天数除以7)</p><p>w 一年中的第几个星期</p><p>W一月中的第几个星期</p><p>a  上下午表示</p><p>k   和HH差不多 表示一天24小时制</p><p>K   和hh差不多 表示一天12小时制</p><p>z    表示时区</p><h1 id="2、JDK1-8-JDK8-关于日期的处理"><a href="#2、JDK1-8-JDK8-关于日期的处理" class="headerlink" title="2、JDK1.8(JDK8)关于日期的处理"></a>2、<strong>JDK1.8(JDK8)关于日期的处理</strong></h1><p>JDK8引入了一套关于日期处理的API 位于java.time包下 这个包下的类都是不可变且线程安全的</p><p>1. Instant 代表时间戳</p><p>2. LocalDate 代表日期 不包含时间的  2020-02-02</p><p>3. LocalTime 代表时间 比如 时分秒 但是 不包含年月日</p><p>4. LocalDataTime 包含日期和时间 但是没有时区信息</p><p>5. ZoneDateTime 包含完整日起 时间 时区 偏移量是以UTC格林威治时间为基准</p><p>6. DateTimeFormat  有用日期格式化和SimpleDateFormat 很像</p><p>7. MonthDay   月,日</p><p>8. YearMonth   年,月</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现深克隆</title>
      <link href="/posts/63091.html"/>
      <url>/posts/63091.html</url>
      
        <content type="html"><![CDATA[<p>关键点：</p><p>1. 要实现Cloneable 哪怕他是一个空接口</p><p>2. 自己定义一个克隆用的方法 且在方法内部 调用 super.clone()</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test11</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="number">1</span>, <span class="string">&quot;小羊&quot;</span>);  </span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">s2</span> <span class="operator">=</span> s1.clone();  </span><br><span class="line">        s2.age = <span class="number">2</span>;  </span><br><span class="line">        s2.name = <span class="string">&quot;大羊&quot;</span>;  </span><br><span class="line">        s1.speak();  </span><br><span class="line">        s2.speak();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;  </span><br><span class="line">    <span class="type">int</span> age;  </span><br><span class="line">    String name;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;,今年&quot;</span> + age + <span class="string">&quot;岁了&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Sheep <span class="title function_">clone</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> (Sheep) <span class="built_in">super</span>.clone();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>System类</title>
      <link href="/posts/32435.html"/>
      <url>/posts/32435.html</url>
      
        <content type="html"><![CDATA[<p>1. 他不能被继承</p><p>2. 他是java.long包 自带的</p><p>3. 构造方法私有化</p><p>我们之前用过以下的三种东西</p><p>System.out  标准输出流</p><p>System.in  标准输入流</p><p>System.err  错误输出流</p><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><p>public static native void arraycopy(Object src,int srcPro,Object dest, int length) 数组扩容</p><p>public static native long currentTimeMillis() </p><p>public static native long nanoTime() 获取时间 以纳秒的形式返回</p><p>public void gc() 垃圾回收期</p><p>Map&lt;String,String&gt; getnev() 得到当前环境变量的相关的配置</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>打包jar包指令</title>
      <link href="/posts/26592.html"/>
      <url>/posts/26592.html</url>
      
        <content type="html"><![CDATA[<p>以下是将 Java 项目正确打包为可使用的 JAR 文件的详细步骤，适用于普通 Java 项目（非 Maven&#x2F;Gradle 管理）：</p><h3 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a><strong>前提准备</strong></h3><p>假设你的项目结构如下（以之前的<code>ArrayUtil.java</code>为例）：</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myproject/                  # 项目根目录</span><br><span class="line">└── src/                    # 源代码目录</span><br><span class="line">    └── util/               # 包名目录</span><br><span class="line">        └── ArrayUtil.java  # 你的Java源文件（含main方法或工具类）</span><br></pre></td></tr></table></figure><h3 id="步骤-1：编译-Java-源文件为-class-文件"><a href="#步骤-1：编译-Java-源文件为-class-文件" class="headerlink" title="步骤 1：编译 Java 源文件为 class 文件"></a><strong>步骤 1：编译 Java 源文件为 class 文件</strong></h3><ol><li><p>打开命令行（Windows：cmd；Mac&#x2F;Linux：Terminal）</p></li><li><p>进入项目根目录<code>myproject</code>：</p><p> bash</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/myproject  <span class="comment"># 替换为你的项目实际路径</span></span><br></pre></td></tr></table></figure></li><li><p>编译<code>ArrayUtil.java</code>，生成<code>.class</code>文件（会自动创建与包结构一致的目录）：</p><p> bash</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d ./classes src/util/ArrayUtil.java</span><br></pre></td></tr></table></figure><ul><li><code>-d ./classes</code>：指定编译后的<code>.class</code>文件输出到<code>classes</code>目录（会自动创建）</li><li>执行后，会生成<code>classes/util/ArrayUtil.class</code></li></ul></li></ol><h3 id="步骤-2：创建-MANIFEST-MF-文件（可选，用于可执行-JAR）"><a href="#步骤-2：创建-MANIFEST-MF-文件（可选，用于可执行-JAR）" class="headerlink" title="步骤 2：创建 MANIFEST.MF 文件（可选，用于可执行 JAR）"></a><strong>步骤 2：创建 MANIFEST.MF 文件（可选，用于可执行 JAR）</strong></h3><p>如果需要通过<code>java -jar</code>直接运行 JAR（即 JAR 包含主程序入口），需创建清单文件：</p><ol><li><p>在项目根目录创建<code>META-INF</code>文件夹：</p><p> bash</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p META-INF  <span class="comment"># Windows可手动创建</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>META-INF</code>文件夹中创建<code>MANIFEST.MF</code>文件，内容如下：</p><p> plaintext</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: util.ArrayUtil  # 主类的完整包名+类名（含main方法的类）</span><br></pre></td></tr></table></figure><ul><li>注意：文件最后必须留一个空行，否则会失效</li></ul></li></ol><h3 id="步骤-3：使用-jar-命令打包-class-文件"><a href="#步骤-3：使用-jar-命令打包-class-文件" class="headerlink" title="步骤 3：使用 jar 命令打包 class 文件"></a><strong>步骤 3：使用 jar 命令打包 class 文件</strong></h3><ol><li><p>进入<code>classes</code>目录（存放<code>.class</code>文件的目录）：</p><p> bash</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> classes</span><br></pre></td></tr></table></figure></li><li><p>执行打包命令：</p><ul><li><p><strong>如果是普通 JAR（作为库引用，不需要 main 方法）</strong>：</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf ../myutil.jar *</span><br></pre></td></tr></table></figure></li><li><p><strong>如果是可执行 JAR（需要 main 方法，需指定 MANIFEST）</strong>：</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvfm ../myutil.jar ../META-INF/MANIFEST.MF *</span><br></pre></td></tr></table></figure></li><li><p>命令说明：</p><ul><li><code>c</code>：创建新 JAR 包</li><li><code>v</code>：显示打包过程（可选）</li><li><code>f</code>：指定输出的 JAR 文件名（这里是<code>myutil.jar</code>）</li><li><code>m</code>：指定 MANIFEST.MF 文件（仅可执行 JAR 需要）</li><li><code>*</code>：打包当前目录下的所有文件（即包结构和<code>.class</code>文件）</li></ul></li></ul></li></ol><h3 id="步骤-4：验证-JAR-包"><a href="#步骤-4：验证-JAR-包" class="headerlink" title="步骤 4：验证 JAR 包"></a><strong>步骤 4：验证 JAR 包</strong></h3><ol><li><p>查看 JAR 包内容，确认包含<code>.class</code>文件：</p><p> bash</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -tf ../myutil.jar</span><br></pre></td></tr></table></figure><p> 正常输出应包含：<code>util/ArrayUtil.class</code>（及其他类文件）</p></li><li><p>测试使用：</p><ul><li><p><strong>普通 JAR（作为库）</strong>：在其他项目中引用</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译依赖该JAR的Java文件</span></span><br><span class="line">javac -<span class="built_in">cp</span> ../myutil.jar YourJavaFile.java</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">java -<span class="built_in">cp</span> ../myutil.jar:. YourMainClass</span><br></pre></td></tr></table></figure></li><li><p><strong>可执行 JAR</strong>：直接运行</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ../myutil.jar</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a><strong>常见问题解决</strong></h3><ul><li>如果提示 “找不到主类”：检查<code>MANIFEST.MF</code>中的<code>Main-Class</code>是否正确（包名 + 类名是否匹配）</li><li>如果提示 “ClassNotFoundException”：确认 JAR 包中是否包含对应的<code>.class</code>文件（用<code>jar -tf</code>检查）</li><li>如果有第三方依赖：需在<code>MANIFEST.MF</code>中通过<code>Class-Path</code>指定依赖 JAR 的路径，或使用 Maven&#x2F;Gradle 打 “胖 JAR”（包含所有依赖）</li></ul><p>按照以上步骤，就能生成可正常使用的 JAR 包了。</p><p>分享</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Object类</title>
      <link href="/posts/56687.html"/>
      <url>/posts/56687.html</url>
      
        <content type="html"><![CDATA[<h3 id="Obj-是java所有类的基类-也就是父类"><a href="#Obj-是java所有类的基类-也就是父类" class="headerlink" title="Obj 是java所有类的基类 也就是父类"></a>Obj 是java所有类的基类 也就是父类</h3><p>它常用的方法</p><p><strong>equals() 对象比较</strong></p><p><strong>toString</strong></p><p><strong>hashCode</strong></p><p><strong>wait</strong></p><p><strong>notify</strong></p><p><strong>notifyAll</strong></p><p><strong>clone</strong></p><p><strong>getClass</strong></p><p><strong>finallize 垃圾回收</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Aware感知接口的Q&amp;A</title>
      <link href="/posts/34409.html"/>
      <url>/posts/34409.html</url>
      
        <content type="html"><![CDATA[<h3 id="Q：Aware感知接口的作用是什么？"><a href="#Q：Aware感知接口的作用是什么？" class="headerlink" title="Q：Aware感知接口的作用是什么？"></a><strong>Q：<code>Aware</code>感知接口的作用是什么？</strong></h3><p>A：<code>Aware</code>接口是 Spring 提供的一种机制，让 Bean 能够 “感知” 并获取 Spring 容器内部的核心组件或上下文信息。这些信息包括两类：一是容器核心组件（如<code>ApplicationContext</code>、<code>Environment</code>等）；二是 Bean 自身的元数据（如 Bean 在容器中的名称、类加载器等）。</p><h3 id="Q：为什么需要Aware接口？"><a href="#Q：为什么需要Aware接口？" class="headerlink" title="Q：为什么需要Aware接口？"></a><strong>Q：为什么需要<code>Aware</code>接口？</strong></h3><p>A：Spring 的核心思想是 “反转控制（IoC）”，通常 Bean 无需知道容器的存在。但在特殊场景下（如手动获取其他 Bean、读取配置、获取自身在容器中的名称等），Bean 需要主动与容器交互，<code>Aware</code>接口就提供了这样的 “沟通窗口”。</p><h3 id="Q：常见的Aware接口有哪些？分别用于什么场景？"><a href="#Q：常见的Aware接口有哪些？分别用于什么场景？" class="headerlink" title="Q：常见的Aware接口有哪些？分别用于什么场景？"></a><strong>Q：常见的<code>Aware</code>接口有哪些？分别用于什么场景？</strong></h3><p>A：常见的<code>Aware</code>接口及用途如下：</p><ul><li><code>ApplicationContextAware</code>：获取 Spring 容器上下文（最常用）；</li><li><code>BeanNameAware</code>：获取当前 Bean 在容器中的名称；</li><li><code>EnvironmentAware</code>：获取环境配置（系统变量、配置文件等）；</li><li><code>ResourceLoaderAware</code>：获取资源加载器（用于读取文件资源）；</li><li><code>BeanFactoryAware</code>：获取 Bean 工厂（容器的底层实现）。</li></ul><h3 id="Q：使用Aware接口有什么注意事项？"><a href="#Q：使用Aware接口有什么注意事项？" class="headerlink" title="Q：使用Aware接口有什么注意事项？"></a><strong>Q：使用<code>Aware</code>接口有什么注意事项？</strong></h3><p>A：① 避免过度使用：<code>Aware</code>接口会让 Bean 与 Spring 框架强耦合，破坏 “Bean 对容器透明” 的原则，业务代码应优先使用<code>@Autowired</code>等依赖注入方式；② 触发时机：<code>Aware</code>接口的方法在 Bean 初始化阶段被容器调用（早于<code>@PostConstruct</code>方法），此时依赖注入已完成，但初始化流程尚未结束。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 容器 </category>
          
          <category> 有助于理解的 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tips（分层架构和职责划分）</title>
      <link href="/posts/26229.html"/>
      <url>/posts/26229.html</url>
      
        <content type="html"><![CDATA[<p>在 Spring 项目中，这些文件夹（包）是按照<strong>分层架构</strong>和<strong>职责划分</strong>来组织代码的，目的是让项目结构清晰、职责明确，符合面向对象设计思想和 Spring 的最佳实践。下面分别解释每个包的含义和实际应用：</p><h3 id="1-bean-或-entity（实体层）"><a href="#1-bean-或-entity（实体层）" class="headerlink" title="1. bean 或 entity（实体层）"></a>1. <code>bean</code> 或 <code>entity</code>（实体层）</h3><ul><li><p><strong>含义</strong>：存放 Java 实体类（POJO - Plain Old Java Object），对应数据库中的表结构。</p></li><li><p><strong>作用</strong>：用于封装数据，作为数据传输的载体。</p></li><li><p><strong>实际应用</strong>：</p><p>  java</p><p>  运行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bean/User.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//  getter/setter/构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个类的字段通常与数据库表的列一一对应，比如<code>User</code>类对应<code>user</code>表。</p></li></ul><h3 id="2-config（配置层）"><a href="#2-config（配置层）" class="headerlink" title="2. config（配置层）"></a>2. <code>config</code>（配置层）</h3><ul><li><p><strong>含义</strong>：存放 Spring 的配置类，替代传统的 XML 配置文件。</p></li><li><p><strong>作用</strong>：配置 Bean 的创建、依赖注入、AOP、事务管理等核心功能。</p></li><li><p><strong>实际应用</strong>：</p><p>  java</p><p>  运行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/SpringConfig.java</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 标识为配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span> <span class="comment">// 扫描指定包下的Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 可以手动定义Bean，如数据源、事务管理器等</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-controller（控制层）"><a href="#3-controller（控制层）" class="headerlink" title="3. controller（控制层）"></a>3. <code>controller</code>（控制层）</h3><ul><li><p><strong>含义</strong>：接收用户请求，调用服务层处理，返回响应结果。</p></li><li><p><strong>作用</strong>：作为前端与后端的交互入口，负责参数校验、请求分发。</p></li><li><p><strong>实际应用</strong>：</p><p>  java</p><p>  运行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/UserController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 注入服务层对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserById(id); <span class="comment">// 调用服务层方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  前端通过<code>/users/1</code>接口请求时，会触发该方法。</p></li></ul><h3 id="4-dao（数据访问层，Data-Access-Object）"><a href="#4-dao（数据访问层，Data-Access-Object）" class="headerlink" title="4. dao（数据访问层，Data Access Object）"></a>4. <code>dao</code>（数据访问层，Data Access Object）</h3><ul><li><p><strong>含义</strong>：直接操作数据库，负责数据的 CRUD（增删改查）。</p></li><li><p><strong>作用</strong>：隔离业务逻辑与数据库操作，通常与数据库交互。</p></li><li><p><strong>实际应用</strong>：</p><p>  java</p><p>  运行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dao/UserDao.java</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 标识为数据访问层Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(Long id)</span>; <span class="comment">// 查询用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  实际开发中，常用 MyBatis 或 JPA 实现接口，无需手动写 SQL（如 MyBatis 的 XML 映射文件）。</p></li></ul><h3 id="5-factory（工厂层，可选）"><a href="#5-factory（工厂层，可选）" class="headerlink" title="5. factory（工厂层，可选）"></a>5. <code>factory</code>（工厂层，可选）</h3><ul><li><p><strong>含义</strong>：存放工厂类，用于创建复杂对象或控制对象的创建逻辑。</p></li><li><p><strong>作用</strong>：当 Bean 的创建过程复杂（如需要动态参数、多步骤初始化）时，用工厂模式封装创建逻辑。</p></li><li><p><strong>实际应用</strong>：</p><p>  java</p><p>  运行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factory/UserFactory.java</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setPassword(<span class="string">&quot;default123&quot;</span>); <span class="comment">// 默认密码</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其他组件可通过注入<code>UserFactory</code>来创建<code>User</code>对象。</p></li></ul><h3 id="6-service（服务层）"><a href="#6-service（服务层）" class="headerlink" title="6. service（服务层）"></a>6. <code>service</code>（服务层）</h3><ul><li><p><strong>含义</strong>：存放业务逻辑代码，协调多个 DAO 完成复杂业务。</p></li><li><p><strong>作用</strong>：是 Controller 和 DAO 之间的桥梁，负责事务管理、业务规则校验。</p></li><li><p><strong>实际应用</strong>：</p><p>  java</p><p>  运行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/UserService.java</span></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">// 标识为服务层Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 注入数据访问层对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 事务管理</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑：如判断id是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;无效ID&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userDao.selectById(id); <span class="comment">// 调用DAO层方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="这些包如何协同工作？"><a href="#这些包如何协同工作？" class="headerlink" title="这些包如何协同工作？"></a>这些包如何协同工作？</h3><ol><li><p><strong>用户请求流程</strong>：<br> 前端请求 → <code>Controller</code> 接收 → 调用 <code>Service</code> 处理业务 → <code>Service</code> 调用 <code>DAO</code> 操作数据库 → <code>DAO</code> 返回数据 → <code>Service</code> 处理结果 → <code>Controller</code> 返回响应。</p></li><li><p><strong>Spring 的作用</strong>：</p><ul><li>通过<code>@Component</code>、<code>@Service</code>等注解，Spring 自动扫描这些包，将类实例化为 Bean 并放入 IoC 容器。</li><li>通过<code>@Autowired</code>实现 Bean 之间的依赖注入（如 Controller 注入 Service，Service 注入 DAO），无需手动<code>new</code>对象。</li><li><code>config</code>包中的配置类告诉 Spring 如何管理这些 Bean（如扫描范围、事务规则）。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种分层结构是 Spring 项目的经典设计，核心思想是 <strong>“高内聚、低耦合”</strong>：</p><ul><li>每层只关注自己的职责（如 Controller 只处理请求，Service 只处理业务）。</li><li>层与层之间通过接口交互，方便后续修改（如换数据库时只需改 DAO 层，不影响 Service 和 Controller）。</li></ul><p>实际开发中，可能还会根据需求增加<code>util</code>（工具类）、<code>exception</code>（异常处理）等包，但核心分层思想不变。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 容器 </category>
          
          <category> 有助于理解的 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>容器-注册</title>
      <link href="/posts/28165.html"/>
      <url>/posts/28165.html</url>
      
        <content type="html"><![CDATA[<p>默认，分层注解能起作用的前提是，这些组件必须在主程序所在的包 及其 子包结构下</p><h3 id="Spring为我们提供了快速的MVC分层注解"><a href="#Spring为我们提供了快速的MVC分层注解" class="headerlink" title="Spring为我们提供了快速的MVC分层注解"></a>Spring为我们提供了快速的MVC分层注解</h3><pre><code>1、@ControlLer控制器2、@Service 服务层3、@Repository持久层4、@Component 组件（这些注解都是组件的意思，注解是给人看的，都能存入组件）</code></pre><h3 id="ComponentScan-———–-组件批量扫描"><a href="#ComponentScan-———–-组件批量扫描" class="headerlink" title="@ComponentScan      ———– 组件批量扫描"></a>@ComponentScan      ———– 组件批量扫描</h3><pre><code>例：@ComponentScan（basePackages=&quot;com.atguigu.spring.controller）按照包的路径扫描组件批量扫描，只扫利用Spring 相关注解注册到容器中的组件（不常用，老实把组件放到 主程序所在的包里面 比较好）</code></pre><h3 id="第三方组件想要导入容器中，没办法快速标注分册注解"><a href="#第三方组件想要导入容器中，没办法快速标注分册注解" class="headerlink" title="第三方组件想要导入容器中，没办法快速标注分册注解"></a>第三方组件想要导入容器中，没办法快速标注分册注解</h3><pre><code>1.@Bean,自己new，注册给容器2.@Import(CoreConstants.class) 即可导入组件 （注解标注一次就可以了）</code></pre><h2 id="Scope-调整组件的作用域"><a href="#Scope-调整组件的作用域" class="headerlink" title="Scope 调整组件的作用域"></a>Scope 调整组件的作用域</h2><pre><code>1、@Scope(&quot;prototype&quot;)：非单实例：容器启动的时候不会创建非单实例组件的对象。什么时候获取，什么时候创建2、@Scope（&quot;singleton&quot;）：单实例：默认值容器启动的时候会创建单实例组件的对象。容器启动完成之前就会创建好    @Lazy：懒加载（单例模式可以继续调整为懒加载）        容器启动完成之前不会创建懒加载组件的对象，-&gt; 什么时候获取，什么时候创建3、@Scope（&quot;request&quot;)：同一个请求单实例4、@Scope（&quot;session&quot;)：同一次会话单实例</code></pre><hr><pre><code>单实例：获取到的只有一个对象，唯一多实例：什么时候获取，什么时候创建一个实例对象</code></pre><ul><li>FactoryBean在容器中放的组件的类型，是接口中泛型指定的类型，组件的名字是工厂自己的名字<br><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5C2025-09-08_19-31-35-0.png" alt="2025-09-08_19-31-35-0.png"></li><li>场景：如果制造某些对象比较复杂的时候，利用工厂方法进行创建</li><li>FactoryBean &lt; T&gt;</li></ul><h3 id="条件注解-Conditional-条件注册"><a href="#条件注解-Conditional-条件注册" class="headerlink" title="条件注解@Conditional -条件注册"></a>条件注解@Conditional -条件注册</h3><p><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5C2025-09-08_20-26-54-0.png" alt="2025-09-08_20-26-54-0.png"></p><p><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5C2025-09-08_20-27-35-0.png" alt="2025-09-08_20-27-35-0.png"><br>WindowsCondition类 继承Condition接口，<br>在组件上面放置@Conditional(WindowsCondition.class) 就可以根据WindowsCondition类中的逻辑来判断，组件是否要放到容器中</p><p>官方提前给了很多“预制”的派生注解</p><h1 id="注册组件的各种方式"><a href="#注册组件的各种方式" class="headerlink" title="&#x3D;&#x3D;注册组件的各种方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;注册组件的各种方式&#x3D;&#x3D;</h1><table><thead><tr><th></th><th>注册组件的各种方式<br></th><th></th></tr></thead><tbody><tr><td>实验</td><td>内容</td><td>目标</td></tr><tr><td>实验1</td><td>@Bean</td><td>理解单例</td></tr><tr><td>实验2</td><td>获取Bean</td><td>理解组件获取方式</td></tr><tr><td>实验3</td><td>@Configuration</td><td>理解MVC分层模型对应注解</td></tr><tr><td>实验4</td><td>@Controller</td><td>↑</td></tr><tr><td>实验5</td><td>@Service</td><td>↑</td></tr><tr><td>实验6</td><td>@Respository</td><td>↑</td></tr><tr><td>实验7</td><td>@Component</td><td>↑</td></tr><tr><td>实验8</td><td>@ComponentScan</td><td>理解批量扫描</td></tr><tr><td>实验9</td><td>@Import</td><td>理解按需导入</td></tr><tr><td>实验10</td><td>@Scope</td><td>理解组件作用域</td></tr><tr><td>实验11</td><td>@Lazy</td><td>理解懒加载</td></tr><tr><td>实验12</td><td>FactoryBean</td><td>理解工厂Bean</td></tr><tr><td>实验13</td><td>@Conditional【难点】</td><td>理解条件注册</td></tr></tbody></table><h1 id="Conditional-派生注解"><a href="#Conditional-派生注解" class="headerlink" title="&#x3D;&#x3D;Conditional 派生注解&#x3D;&#x3D;"></a>&#x3D;&#x3D;Conditional 派生注解&#x3D;&#x3D;</h1><table><thead><tr><th>@Conditional 派生注解</th><th>作用</th></tr></thead><tbody><tr><td>@ConditionalOnCloudPlatform</td><td>判定是否指定的云平台，支持：NONE、CLOUD_FOUNDRY、HEROKU、SAP、NOMAD、KUBERNETES、AZURE_APP_SERVICE</td></tr><tr><td>@ConditionalOnRepositoryType</td><td>判定是否指定的JPA类型，支持：AUTO、IMPERATIVE、NONE、REACTIVE</td></tr><tr><td>@ConditionalOnJava</td><td>判断Java版本范围，支持：EQUAL_OR_NEWER、OLDER_THAN</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中没有指定组件，则判定true</td></tr><tr><td>@ConditionalOnMissingFilterBean</td><td>容器中没有指定的Filter组件，则判定true</td></tr><tr><td>@ConditionalOnGraphQlSchema</td><td>如果GraphQL开启，则判定true</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>如果容器中指定组件只有一个，则判定true</td></tr><tr><td>@ConditionalOnClass</td><td>如果存在某个类，则判定true</td></tr><tr><td>@ConditionalOnCheckpointRestore</td><td>判断是否导入了 org.crac.Resource ，导入则判定true</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>如果不是Web应用，则判定true</td></tr><tr><td>@ConditionalOnEnabledResourceChain</td><td>如果web-jars存在或者resource.chain开启，则判定true</td></tr><tr><td>@Conditional 派生注解</td><td>作用</td></tr><tr><td>@Profile</td><td>如果是指定Profile标识，则判定true；【后面会说】</td></tr><tr><td>@ConditionalOnMissingClass</td><td>如果不存在某个类，则判定true</td></tr><tr><td>@ConditionalOnWebApplication</td><td>如果是Web应用，则判定true</td></tr><tr><td>@ConditionalOnResource</td><td>如果系统中存在某个资源文件，则判定true</td></tr><tr><td>@ConditionalOnNotWarDeployment</td><td>如果不是war的部署方式，则判定true</td></tr><tr><td>@ConditionalOnDefaultWebSecurity</td><td>如果启用了默认的Security功能，则判断true</td></tr><tr><td>@ConditionalOnExpression</td><td>如果表达式计算结果为true，则判定true</td></tr><tr><td>@ConditionalOnWarDeployment</td><td>如果是war的部署方式，则判定true</td></tr><tr><td>@ConditionalOnBean</td><td>如果容器中有指定组件，则判定true</td></tr><tr><td>@ConditionalOnThreading</td><td>如果指定的threading激活，则判定true</td></tr><tr><td>@ConditionalOnProperty</td><td>如果存在指定属性，则判定true</td></tr><tr><td>@ConditionalOnJndi</td><td>如果JNDI位置存在，则判定true</td></tr></tbody></table><hr><p>补充：<br>配置类：存框架底层的配置<br>@Configuration 告诉Spring容器，这是一个配置类</p><p>给容器中注册一个自己的组件，容器中的每个组件都有自己的名字，方法名就是组件的名字。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>maven核心掌握总结</title>
      <link href="/posts/18155.html"/>
      <url>/posts/18155.html</url>
      
        <content type="html"><![CDATA[<p><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5CtmpD9F5.png" alt="tmpD9F5.png"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引入自己的工程</title>
      <link href="/posts/52392.html"/>
      <url>/posts/52392.html</url>
      
        <content type="html"><![CDATA[<p>需要先install 下载到本地仓库之后再引用<br><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5Ctmp73BC.png" alt="tmp73BC.png"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聚合关系的实现和作用</title>
      <link href="/posts/35239.html"/>
      <url>/posts/35239.html</url>
      
        <content type="html"><![CDATA[<p>1.聚合概念</p><pre><code>Maven聚合是指将多个项目组织到一个父级项目中，通过触发父工程的构建统一按顺序触发子工程构建的过程！！</code></pre><p>2.聚合作用</p><pre><code>a.统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。b.优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。</code></pre><p>3.聚合语法</p><pre><code>父项目中包含的子项目列表。</code></pre><p><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5CtmpEA59.png" alt="tmpEA59.png"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>maven的继承特性</title>
      <link href="/posts/29535.html"/>
      <url>/posts/29535.html</url>
      
        <content type="html"><![CDATA[<p>当多个子工程中导入依赖的版本可能不一致，要解决版本不同的问题</p><p>思路1：直接在父工程中引入依赖<br>    问题：所有的子工程都引入依赖，使得不需要的子工程被迫引入了该依赖<br>思路2：父工程不引入依赖，只做依赖版本的声明，（并没有引入依赖）<br>    子工程只需要写gav标签中的ga，版本v去父工程中找到。</p><p>它背后的需求是：<br>    - 多个模块要使用同一个框架，它们应该是同一个版本，所以整个项目中使用的框架版本需要<br>    统一管理。<br>    - 使用框架时所需要的jar包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最<br>    终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</p><pre><code>通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的jar包；又能够将以往的经验沉淀下来，节约时间和精力。</code></pre><p>一般父工程的<packaging>都是pom，父工程不打包，也不写代码</p><p>直接在父工程的项目下新建模块，就自动是父子工程的关系了：<br>    <img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5CtmpE247.png" alt="tmpE247.png"><br>    （子工程的配置文件）</p><p>在父工程的pom.xml 文件中声明版本信息（声明和导入不一样）：<br>    <img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5Ctmp1829.png" alt="tmp1829.png"></p><p><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5C2025-09-07_11-09-34-0.png" alt="2025-09-07_11-09-34-0.png"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目构建管理 &amp; 插件配置</title>
      <link href="/posts/52853.html"/>
      <url>/posts/52853.html</url>
      
        <content type="html"><![CDATA[<p>构建概念：<br>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过<br>程中包括编译源代码、链接依赖库、打包和部署等多个步骤。<br><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5CtmpEA45.png" alt="tmpEA45.png"></p><p>主动触发场景：</p><ul><li>重新编译：编译不充分，部分文件没有被编译！</li><li>打包：独立部署到外部服务器软件，打包部署</li><li>部署本地或者私服仓库：maven工程加入到本地或者私服仓库，供其他工程使用</li></ul><p>命令方式构建：<br>    ![[Pasted image 20250907102205.png]]<br>    1. 命令执行需要我们进入到项目的根路径（进到项目所在文件夹） （pom.xml 平级）<br>    2. 部署 必须是jar包形式</p><p>可视化方式构建：<br>    <img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5CtmpE04.png" alt="tmpE04.png"></p><p>maven工程的本地部署：<br>    清理  编译  测试  打包  报告  部署<br>    <img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5CtmpE39C.png" alt="tmpE39C.png">(比较麻烦 看下文)<br>构建命令周期：触发周期后的命令会自动触发同一周期前的命令<br>    简化触发构建命令过程！</p><pre><code>有序的构建命令容器    清理 clean    构建 compile test package install/deploy    报告 site    （顺序）    打包：package  不需要 compile test package即mvn clean package (打包)mvn clean compile(编译) 类似这样触发命令</code></pre><p>自定义配置构建插件（构建项目是用插件操作的）：<br>    <img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5Ctmp8E3D.png" alt="tmp8E3D.png"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>依赖导入失败场景和解决方案</title>
      <link href="/posts/26278.html"/>
      <url>/posts/26278.html</url>
      
        <content type="html"><![CDATA[<p>3.3依赖导入失败场景和解决方案</p><p>在使用Maven构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种：</p><p>1.下载依赖时出现网络故障或仓库服务器启机等原因，导致无法连接至Maven仓库，从而无法<br>下载依赖。</p><p>2.依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致Maven下载的<br>依赖项与实际需要的不一致，从而引发错误。</p><p>3.本地Maven仓库或缓存被污染或损坏，导致Maven无法正确地使用现有的依赖项，并且也无<br>法重新下载！</p><p>解决方案：<br>1.检查网络连接和Maven仓库服务器状态。</p><p>2.确保依赖项的版本号与项目对应的版本号匹配，并检查POM文件中的依赖项是否正确</p><p>3.清除本地Maven仓库缓存（lastUpdated文件），因为只要存在lastupdated缓存文件，刷<br>新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的<br>文件，刷新重新下载即可！<br>&#x3D;&#x3D;（有一个一键删除的脚本，需要的话去 视频链接下载）&#x3D;&#x3D;</p><p>如有不明白看bilibili</p><p><a href="https://www.bilibili.com/video/BV1AP411s7D7?spm_id_from=333.788.player.switch&vd_source=5e4f6f78c6de6ba4386afe617a1f26be&p=8">https://www.bilibili.com/video/BV1AP411s7D7?spm_id_from=333.788.player.switch&amp;vd_source=5e4f6f78c6de6ba4386afe617a1f26be&amp;p=8</a></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>依赖传递和依赖冲突</title>
      <link href="/posts/9926.html"/>
      <url>/posts/9926.html</url>
      
        <content type="html"><![CDATA[<p>依赖传递：导入依赖，会自动导入依赖的依赖（compile dependenices）<br>    简化依赖的导入 确保依赖的版本无冲突<br>依赖冲突：发现已经存在的依赖（重复依赖）会终止依赖传递！避免循环依赖和重复依赖的问题</p><p>依赖冲突发生场景：重复依赖！！</p><p>依赖冲突的解决原则：</p><p>第一原则：谁短谁优先！引用的路径长度</p><p>第二原则：谁上谁优先！dependencies声明的先后顺序<br><img src="file:///C:%5CUsers%5CLpro%5CAppData%5CLocal%5CTemp%5Ctmp6B64.png" alt="tmp6B64.png"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xml文件</title>
      <link href="/posts/27564.html"/>
      <url>/posts/27564.html</url>
      
        <content type="html"><![CDATA[<p><project xmlns="http://maven.apache.org/POM/4.0.0"           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <modelVersion>4.0.0</modelVersion>  </p><pre><code>&lt;!-- gavp属性 --&gt;  &lt;!-- groupId: 公司或组织域名倒序 --&gt;  &lt;!-- artifactId: 项目名称 --&gt;  &lt;!-- version: 项目版本 --&gt;  &lt;!-- packaging: 打包方式 --&gt;  &lt;groupId&gt;com.atguigu&lt;/groupId&gt;  &lt;artifactId&gt;maven-javase-project-01&lt;/artifactId&gt;  &lt;!-- 构建过程 - 部署（的时候） - 修改版本号 --&gt;  &lt;!-- 版本号对应 三层结构  模块.功能.bug修复 --&gt;  &lt;version&gt;1.0.0&lt;/version&gt;  &lt;!-- maven工程的打包方式 java jar[默认值] | web war | 不打包 pom --&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;!-- 声明版本号 --&gt;  &lt;properties&gt;      &lt;!-- 声明一个变量！ 声明完变量之后，在其他的位置可以引用 $&#123;jackson.version&#125;            注意：声明的标签建议两层以上命名！version 1.15.2 推荐：技术名称.version      --&gt;        &lt;jackson.version&gt;2.15.2&lt;/jackson.version&gt;      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;      &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;      &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;  &lt;/properties&gt;  &lt;!-- 第三方依赖信息声明      dependencies: 项目依赖的集合      dependency: 每个依赖项      [gav]:以来的信息，就是其他的maven工程      第三方依赖信息怎么知道？      1. 从maven提供的查询官网查询 http://mvnrepository.com/        2. maven插件maven-search 安装插件，使用插件查询（tool）      扩展：          1.提取版本号，统一管理          2.可选属性scope              scope: 引入依赖的作用域              默认值：compile              compile: 编译时依赖              test: 测试时依赖              provided: 已经提供，不需要引入              runtime: 运行时依赖              system: 系统依赖              import: 导入依赖           总结：它是一种锦上添花的手段，如果掌握不好，就默认值，全部生效，不会出错            --&gt;   ![[tmp20A3.png]] &lt;dependencies&gt;      &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;          &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;          &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;          &lt;scope&gt;compile&lt;/scope&gt;      &lt;/dependency&gt;      &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;          &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;          &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;      &lt;/dependency&gt;    &lt;/dependencies&gt;  </code></pre></project>![[tmp20A3.png]]]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GAV的核心概念</title>
      <link href="/posts/38944.html"/>
      <url>/posts/38944.html</url>
      
        <content type="html"><![CDATA[<p>在 Maven 中，<strong>GAV</strong> 是三个核心概念的缩写，用于唯一标识一个 Maven 项目或依赖，是 Maven 管理依赖的基础。这三个字母分别代表：</p><ul><li><p><strong>G</strong>：GroupId（组织 &#x2F; 团体 ID）<br>  通常是项目所属组织的域名倒写（如公司域名 <code>com.example</code>），用于区分不同组织的项目，避免命名冲突。<br>  例：<code>org.springframework</code>、<code>com.alibaba</code></p></li><li><p><strong>A</strong>：ArtifactId（构件 ID）<br>  表示项目或依赖的具体名称，通常是项目的简称或模块名。<br>  例：<code>spring-boot-starter-web</code>、<code>fastjson</code></p></li><li><p><strong>V</strong>：Version（版本号）<br>  表示项目或依赖的版本，用于区分同一项目的不同迭代版本。<br>  例：<code>2.7.0</code>、<code>1.2.83</code></p></li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>GAV 三者组合形成了一个依赖的唯一标识，就像 “坐标” 一样，让 Maven 能精准定位并从仓库中找到对应的依赖。</p><p>在 <code>pom.xml</code> 中，每个依赖的配置正是通过 GAV 来声明的：</p><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="comment">&lt;!-- G --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     <span class="comment">&lt;!-- A --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                     <span class="comment">&lt;!-- V --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Maven 正是通过解析这三个属性，实现了依赖的自动下载、版本管理和冲突解决，是 Maven 生态中最基础也最核心的概念之一。</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建web项目</title>
      <link href="/posts/57022.html"/>
      <url>/posts/57022.html</url>
      
        <content type="html"><![CDATA[<p>手动创建Web项目</p><pre><code>1. 创建一个javase maven工程2. 补全文件结构   main       webapp           WEB-INF               web.xml3. pom.xml       packaging war4. 刷新 webapp多了一个小蓝点</code></pre><p>用插件创建Web项目</p><p>没有找到 JBLjavaToweb 插件（可能是新版没有）<br>可以在创建maven项目的时候直接选中webapp的模板</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>other</title>
      <link href="/posts/20709.html"/>
      <url>/posts/20709.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="cbfdcf4472ca4de0dc9c6765915e3154f7fa7d793fb8f65f8adc4c7394a7b3a6">10d79030e8222445804370796b90fca1d27859c754f435ebb6d2eafc059248b99a966d5eff52d776925f8be7dba9a0180130b8f8a371e54d210b9a25a1b229c5988dd3e3457b9848d4f35f7d4916862d10e77993c3475439ce9a03e090870b00017c6c5b33f2030d86f32586009cfb0f108fe23a08efb9a4a7e3f060b77ad00bc4df0624783e271cdfcc0e21b6547af4ba56ab2507ded33814e64aacfcf0289e905bb3c64a9d2fafa375f5589023be53ec92d7e1b54e2bd7042c0f6cd3e9072e5fdbb8cdf95135c41156032d940f4178442603a1d051d19795e6a9fa91022db1413be8aec602b251728a0be8c025a06c22ea68b48db6cc4c517f67eea2afc774c799f0c50c13e8ac9dc979ac5a726d8bc3b06e52177b548d12b8e9c8c35c54516fa0bc1b8c6755ef0ec8b8a5ea6dedf82ae1ca6dd4189e8ba6d661fc4b3a0acf3f08a51f73ffff88ce0794c55853f7cdc7c3c3a1952f98654123060e941c290aa0d3aa45d8b913ca11c8df7991a23e6a7262b13e15e3cd52c80acbaf131d8755d5c74e637167823c0e8ea7094864cbd4e05e32b97bd0aa7aae96c4e99109845a3cb7395fc7a044a7c07067ccabfb532f0ed6dd2a80911ca07726e17c0fb127dd68c11ae2a77a056d367c15975e9827e72c80d26a00e2d8ec24760e293a7570d4f5f4d0c6917cbec3a669f8c835a7ef8031ae1f8cdecdf48c431d7455d8a7488c545d62b400d44a3bfcd8ba2ac56693180527771c3c5f85af7be613d0021b9b0ee0bf9c2e6ea0f4ee6b04a4b2beeae097b93a9675436b92edfdb547d7a5b422e0e67f6dcf8c581374c6be26b287bb4da1944a465d0bd76c4e39b5af8b17233468c26841dd7464e6881f0b27d951a974a8cf70f04a42d8027526785789e19cf9b5e976114e43f94cc05a655d9d321e708f57ed4bdb691d39837125254782d70889e1967c6215f2ec280200a5de34b1ea730772433af40563b91d29e4dbc8b8a8d82538eb134b329182d262090e90b45d4bbff6af346b13f908f82e06d3f8dd0429fcc6bc9c84811c97785567528ade81509995603b99839fff267f8f9fefe233d82d73e9c618e338f80ebdb93fe2b37161befd207c62056e4d456d2651b6ac41891717bcac20e9a3fa61558a9225ea18ce801bdaba217509f8505dbdd25a68555b636b1f9dc9ed907fd15ad13da1d4253b16c445aa5cf0a45e0e38d11c18a42e840c4d33f754deb9c973cd8d79d47416c2c8c3782a562eeeb068949b462c79c6041ff4964ddb5b1b245621c36fe89f257e9e637ac492c50d04f6118111ee03c0b466f2a8587043a58443eeb24434ab1827e40cb0c8e487f4c473cf8d44311cbb69dbb2322753e65593a61137dba08141146407c54fad226b001d53b376f7c544fdacee1ec29fc476a6079a98b3f1868a2e163884a0b2125b22306fcffc3f66045d9270daaac0734f4b87c8e790c031a1cda0f8f1f985130e7282fc39043865ea2b842b299d8a2793e4eaeee84164f17f1f125238e48b26de549444c0ff40d3e9d03a1ec972d7f9dd128191efae7bae7f189f8851a5c6ddba95ab12ebaed13d9097d35906881814c5fd3518f7009292dc8ff6e540f4cc7b2ba49bf55d5b97b68b36bab8cdad4279758cbda3833a9afa003443849c2d0f52a53b58435137d6a2aa906dde2110ec3b786b8fad968ee58481fc9959c84fddf2948a478545e0f1ba5f63a42d6e30cee77d649c77b0332faefe3f28af92bdcc3d9bf09d1f3883968b5f68a58164784b7243c14285188be75549c5e15c817575c2936ac2fc584c722304f3413aa08651bda858303fce932b62093527fb31676eea934ba1ad09df8ef60a36b08dee61fa8eaa5184bb6ee6029adb09e5887c164fcb0b2bfe557efa3e0180af61fd34d26538adecf76da10f3e00c5322d6dcc368dd2b633cf3b920d736c8e3872fc907bb41a9f20780aa008c7b78b9dc7693cc1300b2d4507a5bf68517ae2506b61b654a1fa74f8012cf3f645d7950ea0c912af10bb2f2e1ee9fe5f7184d3a17443c227e30d46b3625af789f50a50a5d887480d9828a7bb5edf4c39908fe1f13bed70e55fcb70219ae288d3fec15c516bee02e68908b6f0f8d92661f5a43fcfedc6ae982524c2c928b2ecac94f4e94d45978b4391e3560a6a132508563392fb681a5cae9a218c0ba83ab8719a19ea8f784e24852e69625c99b96433e6d6d6c4fb2184e0ec56766b554a9a5b4d9ee88b630479d831de2c869c43b8b54d901f8b7289d7bf6272be041341083be2ffa7cc04ab417de140a67a90a10a3c8c436c3b2c57b80c55ab28f3015b930923ca320a1c2a3f9ce8167e0fec7665051343fc416bc0f544c0e53b93daa9e421626737eb6b4cd39c088dae0bfd797ad9b5dfda3457642eac62804bdccdcba3521969f9d5eb545641c89dacf2446bfc668802502013c72eef29d426433864bc7ee5df32c85c144e7fd8a96802e07ec25a6204272912984f16eb22d2e9bd74532dfe2036a2acd1838c7098c483b025e2e3f50d3124d2508205cab03ba06181fa6c918c5c5c0e043a550b083a38337fa72d3d040d30e9bb37e64baa66616db68caf413466919316b913e8c9f1b12e9fec91b60cbd39ffc1a20fd6c4746d285c3a58d1dd515321d21d2ff024b19d81b0d1f962be1f01d91a7b363a1189cf44e020b1b660c275c91b442a9dc3b0347984ec6723a023f53b78d54212ab947e57c255b84ea6e7516060eabc0eaf634eadc513ff5bf7202d06024db1131e0d7a57839c9e968c85c05d6f1c183ea054f63fe87e7a2d84efa8cde3d01afdf69a8237a728384a5a39747102c8b785d2389a48f7436eda8cb238665947c5ee5fff5391786f52b63793d17f0ffb1fd1956eb76fb99a1b467127f939fe738af1f392512c200359d643c360b7b653f9f19a68c91c64ce8786f3bf6ed2725c0dd34a05530dd24a55401f95e1e2df289b503ed3a8bda575a8aaa3cd7db2caf24e331f2d3dd82113541fbfe92453220f826f57643df6f814d67c89a361a815924e770f34e05d33dc08c483fcb89621969eb26f2033a3f3aea7c81a6da17ceaa93581238ac690a76c37ce5513fb0bd30cb7c5304023996047e3b2e168adfd4d6ed49e63c3754a702be03b93684c3115b8fd6f5617376ad47c0fae4a2841004b5d84a365f3ebb8d08577af23f831d382b8371c363b9f906e0900d143022398fce1cce6d874b740c16b33236729a0467a44bf15404ff3ca80e4e0bcb57a0684fe8e40d1990c7570477b9ba4f3c05d1d07409a2a51f71f397b73799a1ba474c6935f4c2216a53e6d48ab4fb880d4a4735588b2c294e04a3197b5d1e00d1dc8feaeb3999e06ca62b7a508f3311904f6184fb75ebac0b414b1a474a0af92d763113ec484f809d139b38911013a4dccab4982397a10fa6a28fbb1af1f737617b24e06617f12bed8e549b85d55bf023495702e03961a933a99d3e14c00b257fb4ca7f4f29e9ee16cae76ad3fa31ad282b61bcf156932b393070f911a73bd48b457d848152fb14fa211413fa87578673ed7574ceba86ee8002cba22819cdf8e09bbf553a9aeb1500a3c4f583c7e5a9eeaec4ecbee2d5f35d274b43c1f69efb1d35d5ba138cee52116cbb0ceacaa7d6041faa8d794a5734fbe9d2d4435cb3524e00cea0a1aedd4bc6c3d0266148259add57d3c173add5af9213f6fe417084dc8eb525f5393354d21825c948c964c6e3d5fd9773635158808e8b6847d07b03f0ce425c11d475fc7b2a441c196813d7c2cb46516c73b995605a4c6695d5f0f7e6755b91f2c78b0ff3d8761f202b59b1fbaacf6d05eb82e3ab19f85488d7979b00ebcaa78f4ece70aff851f6773c491b73e1c7e90996804432e819baf412ca5c9dd86209e3fbe9adfb405df76523bc0b9f94f120606eb8bd8c8f0bb48c2f4f994934285a092ba6e498c862e6c395df87df881192d38f99e195427412d5f506eead4868b817f53db69a7a9a948771728798972f878f33fa3a03b2017ab76f9274ec01d67c28fd1216a8f7f0e8b5d029868a1a372092cd9f326cfd18b0e3fd0101106a4865c0abb161598042b8c80d9e1e07c4af016ada5f1a67d424c6847639838a40a63597842375a2ad212b4b46f49efbf220dba94c00b243f57fabb8b0ed7e4c543d0d5db5d74cebe7c3354b61ffbbc0cce0377999a8b02138ac4b05a490d39c9eb9603f61e6177f37ae2b7e4dae8e69f4dfe82c5d755c38a275e92043b71b449487c85ca76068d6ffb4218c71c609e691d648af6e697cb0947da938e5a6bff18e0d270773540ce86102604c7d11243ad0679c468fa598c39231cbe4430c79be07059ed816eafcd22351996e2bda6db3888384324728509e208306df6009fb4c5509085b0624b9652e90f2eee7786446d860f40b13726596833155de7e97e2b5f0b8c8a7e9cc41ac7dc410b42aa3d34182dc4c807a9a8f39fda828f83e5fa08ebbaeca16492c1fbdc04aebc5df2c475119d11cac1e80b073810006caf18562d089ef1550615dc2008d35859f67ee1a581b27a83df375183fef763ed5b2a4c4e3c38d33f3496e664512e9e61e1926a22cca2b3f5d4db46d9f8e6fd51a7c389fc3398d04d2bf05a3ce91c4afe708dfeabd44609c1333fcc3e51d1db5ad9e9fde6ba972c15eaebdb9e83d1f3b265d7a6dd944ba335a22650c5e099dc11440231b0fbb7f425aa1b732504122ab1366324109bc9491f1b8861407ff857dfdeab19659ace235847d3cd024f9580cddf50c04c4b8a22ef7e41e8036d6e1b3ced360853471a884d6e86cf384fe863658c28f15b2b773a5b48330cd2731ac49b3429d26963943a2dc81d5a988e202ce1762854c8fb15e7c4779f0840bdcd0d5e2bb7aaacd91fb96ca4e58e20c9d2f0b0fc6a5650cd9edc3bfe7a3d4dceb30904c407509a9c2fd5fcff226f5c812439a3209f8440a40eb2cf36c185771892d4236626d33ea6a1262498e52fcecaea5daf92075b5c28a74ca3fe901725cd0d5fca1e4aa16925d7e4f6556563dc98a2b2d0e3693b02497e21aa7e881bcdf332cd8fd8fc5d6dae998946a6e915048972fde760d80c7c6a3344c8397dd38d627b425eb35a514c838dc8bff55937ea87830e2133c1e4c0ea54c086e8996ed37446f8d7c9dbd2b7c3a914d08e4513d5d51587cc3c8b77211fa793b93d2df90aad819a2ca6cee975fa1aaa6fcef4b26fad6dc2aa4e6906b225a8aade54a3d23bcece31a1d27cf90587a7172641794e62e01c0958e3771639beea4648d21bcd51fad328fb0dd19171f51d32bc079a4fc052ee330c5a56b78ec96c10c133e4652ad60ccfdb9adff8e64965a4ab2157978f52177cf9a9c31a5574ef1f76b416034d5a2ba5d4cd6339037be119790bba64d39331571c515fb7db10cd29731dc5cd99db0f8afc2fee24926932638c4d9d24d27b3375c78c666c3a3f2d2b651b56bccbb2c2607f0f3871649162ba58c84ef320f54e293516ed7814463d4603e35c8f6ba31ae4c98535a9bc04f2c088650f21bda5d0ad092fb2d076442f3e253af7e733c2934c19f5e5e7dfec5dfb3bd37b2639c0268a184ddae0c19d03cd83bb920647fab84a71b10b5eed66d057d35418aa9cad13e1b02dcc4291ce2c42b1b96276ae4218a7e80402d911e8da7832a2293fc099feae00c72aecd5a14fcf451fe861ee31dfb9f0a15d8a542585392533a367acf9ce128dee88eef132f6a0e94a797261dccc63c5aee597cf469414854c8eade9ca917676da549a0178bab9aad571e32289fb19e93b63957e458c80e7a7e83c69e3e153941cc379e1403bde7f53c8ba8f6a7cd857a9a03c937ece04ffb540850c440dd2f2dc2ced2170eac18519974fcde6a5a2f1a1a7778415e1df6a30aa8e0176bda2634e36eee553a762cede2ed44a0f9e24bc0012b7c12ab582a2abff931d137645cad87dfc5aa77338381b3cb7639f0726a009b9e71aa69d7227fa618516cab1fcc454a02eab466f3b20be8acf5371a3c738bd94eefd4504fb6dca197d4d1247d4dadc16ad74c4b4198b5873f5d92a194a51c3b803bd790429e4ab90007b880de1de4989801027f40ec787ed04a7783339b7ef82322b9fa7366d731451d8d056a6b7ca38e90f4da6f42ddf6ad7b1d186c3cb1f57e4b5e78d4e0a878a22c3524678030ab412c866c5626a1cdf1573d701c2db3add88e02df6cb788feff2a3a59a9f89656325b19b82eb4d1e3cba54c22f403ce9fdb86b45289591db8b887c11a01fc0c5f42838ea52ff630ef67a1e4f0737ae48437d263541687196ba8684326703b5873f4cd2ab60fa64fe104082eed8a6210209fdb02f0ef131393d656ecd70b9b360e747ec7d5b3cd4411be2a8769c92fdb70a403389311b8e26089fb735bed49b8890a96008367f75e922f87a1f518c08cddff30cf28c193d0a44cc61d2638648298874cea7ce8ae3f9562aa54bcd5edc4630361af47392a751f1802e56a17b03030b97b6bccd7029dbd0119b16eb5a777965608a8ae1063ed50a762705e781b2f88b46e97f52d22d0da1f6a6b0e440229fc532baf1340cbc9e3fe3142196227de5f9532d5ab012c10a6120d8903f585174e34bcd67dbdc74d7bc79b6dfd99cf6f2efa18baccbe8bcb1f74a0b53f6df0dc7ec128cd150834495392706b3661bc195c677127ea9bbca44e933a6ba8ec4beb42403d4608c0ff03b706ed942a45408bd9fe2c120049b5cbcc8cb90e540b650fb69895fce28cfb8efcff4bb55f52eea49934bcec7dc2efe414293dde72a64c58a9e9919a1e502baa2e5b6f91b58f2217426e7c1a4940b54d28a4af56af2377bb17cc6fe9460dd4d5553d296325b53294fa4b2644d59a64e08d74cea7901d57cf3c4a3329dcbc21b00fda038fb19bf336d92fca796e0b622c1abb2ac6fe4b7f86de0d0f9ea31650a32a157c8430ae236c8eeda5f32cfbf3c87200238c5e8b8cebf7b7dc18cf262fdec349bbd80783c151228d90c0e43ae07dd3af3dd85b6526d938d70fdebfce5f701a28a09d8312bc3fdb74d5651a542bf565057bf04c1abdae27a21d83b76a21b6e3266586180f09caa89c91440bfb2a79de938640b12def08135b59a3056f649d9fbfc6787d277f02a6585af067e44fe591618ab3173a19c380e0206c5a6aa66179d1f1e1df4d7ce3b653712b621e8f9d95bfcfbcc93d56ff7f5444247113141ea031669153a316cfb8453bdc5508e14797c519a3c6d7791c57888598b56a23cf80e7cfb9ad5a811a236cb12e7d48680db1737dfe131dbec823cb829f54ca24e7d698931cdae3cf12d43967a27ff15a487964189d8ecb6c1e0017e2d4c51ba5e02330ea486959602a9fa81346a79691ab69ee9cd4ec13f9ad8d20cbb69caeed57850ec93f92e8101cdaf3eaf46d55eac5a2e64311ee16878237dcac493f3880c00966d1f0800b52b7135f9b5daa59f5e9fe6acaf0edff5627f5a16921b2a5159e8a8d70b00a4a7f4a1e9c1596981f35ca54f2be100ec52dc42a5d11a73fc9d4e453c18fa2c2bd000d2a2b313a333abd289b591e5abe03ab0e9d02da34713d0a48830d48faaad5d63e20770ccbb18b892abc52748bb632c9c398dae1e54d3c76ab3c8e521310ce218fd41122c15724ec2c93d4d29f43da47d879828618fe3e7bffe12f1c90247545ca3233e90e2d21863130b476ad1aaef719549f8a0eaac2ae21633fe3b5c1616ea6a0779c276b23062acae477dbb866cd522e080add8ee605786e95fc042f6c3b152e4855caa63c8a9b59547e1f7dfd99bbe67b6c624283ec92b24f75e9bf498ba3a7c9528fc2c7c4eb979e319eba8d834ded805cc646048862023865e0c81c8e01ebdc7d1e60b73658052481b93be197606c5e34e101dee3b389e998d7f0ac2a4910ea962cda3b410e84600967c940af11ec3019d8398cba81970e4feb1f77cd6134220a42199abefeead1387feb86fdf04754f4f060ced4f0b0e775d5a35bd3b0105b51511276366d793fdf112d99defb551be7a6d6b8dcf3cff74b5152a160e7498974d5085e969f2b0b71d1399857396c70b90fc8ea0d410fe2b6307fc6aa888c58d3f3661a0762759ec162fa54b74992a766dde4a7133383590246e8f17de0774c20890cbe25fad5dc67b491ff059c8d41addf430e70dce4cbcff7db01dee5a161e149c871d8c04776f5343d1aa6ef73fd3135b8348193f0523e43e67153be244f75109bd804c5e82efb36d37cfb3dffd505173781f9cb7f444974b75d72b2995eb746c50964c8cefa817e14e2d92a4a48bc23148ee6e49b90a8f97c34fe153ec76082375389c96c9352b6f23abeb018bf450748d42e290d6bda5f4796fc8c9f863f36bbd93adfc94b8f54ba6b8b5d1aab981a06d5ddc3667927810e92c621d824badd9da29b94957de556aa5a04b9ec1237ef0bca9211a32c4e1fe35accd5d1f4ae971be70ff8aebf76a0c56a6c02ed829bd971bee19a89f37c47050e6647e50d794ce23f769f598c91a70a71822b0cb5d31953ec26bfa8085ba2adb0de3151fa8ac90837c9b449cc5efb33cd9e2f4247e9199fa49bec467772f1acc3e2787067bfb18f36e3afe24c9eface7bf2563548b859faffc7ca5123da97ded785b857edf6812b64c8c0bc08318497dfe682715d17438c3e52aa8ed61666960ac2ccff7194a63b2cf85b17ad7a4fffb4dfd855911a80854bceeffa84f9b0141a8fc5763db919a92f3a1fe331d590e571b6c1a70ef6f8010d099dae3667807107ff4594bb3f77fecaf84029e24fcd6d14351ef4948bd9c70d097484d06c19b316d734a367a806a994d1de83aa828e899859f4ba974a388493e77b2a04eb553312ad4b1d494e0693667b8956b5d46a6017a143b7cf26d01e93039f58f30c215f81bde9658571926c5ef5fb607eecc8ab04fcd5314ae7529948ffc7eede3a8ae5cb8ff0430b68edadf97809d8749c0be60a04045533bb8202e343b4f01b981cc477dc4482ca3e02b9f2f035468335e00d8f41265b4846dbe4dbfafd53dd5aec8ddc24b105037b79418dabc29d0bfa472886ea7ff59a0a0b7e5a6d13d2f12f34841aede6f72e5d23e4b2cf3737f849a057162a69b2560af41b1d33bdf4af10787676ed75fa2d5234591cd03b3ade4372f7912de8c22cd4818837982d763c64de807cf430a903b78ed17b6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 技术 </category>
          
          <category> Web开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
